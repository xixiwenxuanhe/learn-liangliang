<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="09 结果如何？线程的秘密告白" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>09 结果如何？线程的秘密告白 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/01%20%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%88%9d%e9%98%b6%ef%bc%9a%e8%a7%a3%e8%b0%9c%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b8%96%e7%95%8c.md.html" id="01 多线程初阶：解谜多线程世界.md.html">01 多线程初阶：解谜多线程世界.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/02%20%e7%ba%bf%e7%a8%8b%e6%b1%a0%e6%8e%8c%e6%95%85%ef%bc%9a%e7%ae%a1%e7%90%86%e5%b9%b6%e5%8f%91%e7%9a%84%e7%a7%98%e7%b1%8d.md.html" id="02 线程池掌故：管理并发的秘籍.md.html">02 线程池掌故：管理并发的秘籍.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/03%20%e9%94%81%e7%9a%84%e5%a5%a5%e7%a7%98%ef%bc%9asynchronized%20%e7%9a%84%e7%a7%98%e5%af%86.md.html" id="03 锁的奥秘：synchronized 的秘密.md.html">03 锁的奥秘：synchronized 的秘密.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/04%20%e9%94%81%e7%9a%84%e5%a5%a5%e7%a7%98%ef%bc%9aLock%20%e6%8e%a5%e5%8f%a3%e7%9a%84%e7%a7%98%e5%af%86.md.html" id="04 锁的奥秘：Lock 接口的秘密.md.html">04 锁的奥秘：Lock 接口的秘密.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/05%20%e6%8e%a7%e5%88%b6%e5%b9%b6%e5%8f%91%e6%b5%81%e7%a8%8b%ef%bc%8c%e5%b9%b6%e5%8f%91%e7%9a%84%e5%b7%a7%e5%a6%99%e7%bc%96%e7%bb%87.md.html" id="05 控制并发流程，并发的巧妙编织.md.html">05 控制并发流程，并发的巧妙编织.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/06%20ThreadLocal%20%e4%b9%8b%e7%8f%8d%e5%ae%9d%ef%bc%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e9%9a%90%e7%a7%98%e5%ae%9d%e5%ba%93.md.html" id="06 ThreadLocal 之珍宝：线程的隐秘宝库.md.html">06 ThreadLocal 之珍宝：线程的隐秘宝库.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/07%20CAS%ef%bc%9a%e6%af%94%e8%82%a9%e8%80%8c%e7%ab%8b%e7%9a%84%e5%8e%9f%e5%ad%90%e9%ad%94%e6%b3%95.md.html" id="07 CAS：比肩而立的原子魔法.md.html">07 CAS：比肩而立的原子魔法.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/08%20%e5%ae%b9%e5%99%a8%e7%9a%84%e9%ad%94%e5%8a%9b%ef%bc%9a%e5%b9%b6%e5%8f%91%e4%b8%96%e7%95%8c%e7%9a%84%e5%ae%9d%e5%ba%93.md.html" id="08 容器的魔力：并发世界的宝库.md.html">08 容器的魔力：并发世界的宝库.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/09%20%e7%bb%93%e6%9e%9c%e5%a6%82%e4%bd%95%ef%bc%9f%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%a7%98%e5%af%86%e5%91%8a%e7%99%bd.md.html" id="09 结果如何？线程的秘密告白.md.html">09 结果如何？线程的秘密告白.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/10%20AQS%ef%bc%9a%e4%bf%9d%e8%af%81%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e7%9a%84%e7%bb%88%e6%9e%81%e5%a5%a5%e7%a7%98%ef%bc%88%e4%b8%8a%ef%bc%89.md.html" id="10 AQS：保证并发安全的终极奥秘（上）.md.html">10 AQS：保证并发安全的终极奥秘（上）.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/11%20AQS%ef%bc%9a%e4%bf%9d%e8%af%81%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e7%9a%84%e7%bb%88%e6%9e%81%e5%a5%a5%e7%a7%98%ef%bc%88%e4%b8%ad%ef%bc%89.md.html" id="11 AQS：保证并发安全的终极奥秘（中）.md.html">11 AQS：保证并发安全的终极奥秘（中）.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%ef%bc%9aJUC%20%e5%85%a5%e9%97%a8%e4%b8%8e%e8%bf%9b%e9%98%b6/12%20AQS%ef%bc%9a%e4%bf%9d%e8%af%81%e5%b9%b6%e5%8f%91%e5%ae%89%e5%85%a8%e7%9a%84%e7%bb%88%e6%9e%81%e5%a5%a5%e7%a7%98%ef%bc%88%e4%b8%8b%ef%bc%89.md.html" id="12 AQS：保证并发安全的终极奥秘（下）.md.html">12 AQS：保证并发安全的终极奥秘（下）.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="09 结果如何？线程的秘密告白" id="title">09 结果如何？线程的秘密告白</h1>
<div><p>我们在前几节中学习了线程如何组织以及如何保证线程安全，但是我们介绍的线程的使用方式几乎全部是 <code>Runnable</code> 接口，虽然我们也稍微讲了一下 <code>Callable</code> 的使用方式。</p>
<p>那么，本章节将重点讲解 Callable 接口的详细用法。</p>
<h2 id="一-callable-接口">一、Callable 接口</h2>
<p>存在即合理，我们之前所学的 Runnable 接口存在以下两个缺陷：</p>
<ol>
<li>Runnable 接口不能返回返回值；</li>
<li>Runnable 接口不允许抛出一个异常。</li>
</ol>
<p>以上的两个缺陷导致于 Runnable 接口在一些特定的开发场景中，实现某一些特定功能很麻烦。比如，我现在有 100w 的数据，需要你采用线程池将 100w 的数据拆分为 10 个线程执行，当其中一个线程出问题后，需要将错误信息，以及出错的区间返回！</p>
<p>如果使用 Runnable 接口来实现就会比较麻烦，需要借助我们之前讲的 <code>CountDownLatch</code> 等类似的工具来进行计数实现，而且 Runnable 还无法返回出错的信息和区间。但如果采用本节课即将讲到的 Callable 接口来实现这个功能，整体就会简单很多。</p>
<p>我们先学习一下它的基础使用方式：</p>
<pre><code class="language-java">public class CallableTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask&lt;String&gt; stringFutureTask = new FutureTask&lt;&gt;(new Task());
        new Thread(stringFutureTask).start();
        //获取线程的返回结果
        System.out.println(stringFutureTask.get());
    }

    private static class Task implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            return "我是执行结果";
        }
    }
}
</code></pre>
<p>从上述的代码可以看到，我们将 Callable 包装成了一个 FutureTask，后续对于 Callable 的操作主要集中在 FutureTask 上。</p>
<p>Callable 获取结果的时候会抛出两个异常，ExecutionException、InterruptedException。其中 InterruptedException 是当线程被中断或者任务被取消的时候抛出的异常，当任务抛出异常的时候会触发 ExecutionException，当任务被取消的时候，会出现一个 TimeoutException。</p>
<p>接下来，我们将针对 FutureTask 的主要常用的 API 做一个详细的介绍。</p>
<ol>
<li><strong>boolean cancel(boolean mayInterruptIfRunning)：</strong>
<ul>
<li>作用是用于取消与 <code>Future</code> 关联的计算任务。</li>
<li>参数 <code>mayInterruptIfRunning</code> 用于确定是否中断正在执行任务的线程。</li>
<li>如果任务已经完成或已经被取消，或者由于其他原因不能被取消，则此方法返回 <code>false</code> ；否则，任务将被取消，并返回 <code>true</code> 。</li>
</ul></li>
<li><strong>boolean isCancelled()：</strong>
<ul>
<li>作用是用于检查与此 <code>Future</code> 关联的计算任务是否已被取消。</li>
<li>如果任务已经被取消，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul></li>
<li><strong>boolean isDone()：</strong>
<ul>
<li>作用是用于检查与此 <code>Future</code> 关联的计算任务是否已经完成。</li>
<li>如果任务已经完成（包括正常完成、取消或由于异常而完成），则返回 <code>true</code>。</li>
</ul></li>
<li><strong>V get()：</strong>
<ul>
<li>作用是用于获取与此 <code>Future</code> 关联的计算结果。</li>
<li>如果计算尚未完成，则此方法将阻塞当前线程，直到计算完成为止。</li>
<li>如果计算已经完成，它会立即返回结果。</li>
<li>如果计算抛出异常，此方法也会抛出相应的异常。</li>
</ul></li>
<li><strong>V get(long timeout, TimeUnit unit)：</strong>
<ul>
<li>作用是用于获取与此 <code>Future</code> 关联的计算结果，但是在指定的时间内如果计算尚未完成，则抛出 <code>TimeoutException</code> 异常。</li>
<li>参数 <code>timeout</code> 表示超时时间， <code>unit</code> 表示时间单位。</li>
</ul></li>
</ol>
<p>注意，这里的 <code>Future</code> 任务虽然提供了取消任务的能力，但是当任务没有处于阻塞状态的时候，实际上任务并不会停止，它只能取消能够响应中断任务的任务。加入类似的任务是一个死循环，此时程序无法被停止。</p>
<p>下面我们学习正确停止死循环的两个方式（重点请关注一个注意点，<strong>响应中断任务</strong>）。</p>
<ol>
<li>使用判断线程存活的方式来验证是否需要继续执行：</li>
</ol>
<pre><code class="language-java">public class StopTest {
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        FutureTask&lt;String&gt; stringFutureTask = new FutureTask&lt;String&gt;(new Task());
        new Thread(stringFutureTask).start();
        //获取线程的返回结果
        Thread.sleep(1000);
        System.out.println(stringFutureTask.cancel(true));
        System.out.println("任务被停止");
        System.out.println(stringFutureTask.get());
    }

    private static class Task implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("线程正在运行");
            }
            return "运行完成";
        }
    }
}
</code></pre>
<ol>
<li>采用睡眠中断的形式来响应取消的指令：</li>
</ol>
<pre><code class="language-java">public class StopTest2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
        FutureTask&lt;String&gt; stringFutureTask = new FutureTask&lt;String&gt;(new Task());
        new Thread(stringFutureTask).start();
        //获取线程的返回结果
        Thread.sleep(1000);
        System.out.println(stringFutureTask.cancel(true));
        System.out.println("任务被停止");
        System.out.println(stringFutureTask.get());
    }

    private static class Task implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            while (true) {
                System.out.println("线程正在运行");
                Thread.sleep(500);
            }
        }
    }
}
</code></pre>
<p>与第一种案例不同的是，这里使用了 sleep 来阻塞程序，当发起取消任务申请的时候，Task 会抛出中断异常，从而会从 call 方法的循环中跳出，并结束程序。当任务被取消成功后，调用 get 方法获取结果会抛出异常 CancellationException！</p>
<h2 id="二-线程池使用-callable">二、线程池使用 Callable</h2>
<p>后面我们学习如何配合线程池来使用 Callable 接口，线程池使用 Callable 与直接使用类似，基础使用如下：</p>
<pre><code class="language-java">public class ThreadPoolCallable {
    private final static AtomicInteger IDX = new AtomicInteger(0);

    private final static ThreadPoolExecutor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(1, 3, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
            return new Thread(r, "test-" + IDX.getAndIncrement());
        }
    }, new ThreadPoolExecutor.AbortPolicy());


    public static void main(String[] args) throws Exception {
        Future&lt;String&gt; submit = THREAD_POOL_EXECUTOR.submit(new Task());
        System.out.println(submit.get());

    }

    private static class Task implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            try {
                Thread.sleep(2000);
            }catch (Exception e) {
                e.printStackTrace();
            }
            return "我是返回结果";
        }
    }
}
</code></pre>
<p>与我们之前使用线程池提交任务不同的是，这里使用的是 submit 来提交任务，提交任务完成后返回一个 <code>Future</code> ，内部的 API 与上文同理，这里不做太多的解释。</p>
<p>接下来，我们将针对 <code>Future</code> 来设计几个使用案例来加深你的印象。</p>
<h2 id="三-案例">三、案例</h2>
<h3 id="1-超时案例">1. 超时案例</h3>
<p>我们有一个系统，需要调用第三方的接口获取数据，但是因为我们系统的用户体验要求，如果 3 秒内接口没有返回，就返回一个第三方接口网络异常；如果 3 秒内返回了，就返回第三方数据访问成功。</p>
<pre><code class="language-java">public class ThreadPoolCallableCase1 {
    private final static AtomicInteger IDX = new AtomicInteger(0);

    private final static ThreadPoolExecutor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(10, 20, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1024), r -&gt; new Thread(r, "open-api-" + IDX.getAndIncrement()), new ThreadPoolExecutor.AbortPolicy());


    public static void main(String[] args) {

        ThreadPoolCallableCase1 threadPoolCallableCase1 = new ThreadPoolCallableCase1();
        System.out.println(threadPoolCallableCase1.getData());
    }

    public String getData(){
        Future&lt;String&gt; submit = THREAD_POOL_EXECUTOR.submit(new Task());
        try {
            return submit.get(3, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            return "手动中断任务";
        } catch (ExecutionException e) {
            return "第三方异常";
        } catch (TimeoutException e) {
            //超时了就取消任务
            System.out.println(submit.cancel(true));
            return "第三方接口网络超时";
        }
    }

    private static class Task implements Callable&lt;String&gt; {

        @Override
        public String call() throws Exception {
            try {
                Thread.sleep((long) (Math.random() * 7000));
            }catch (Exception e) {
                System.out.println("任务被主动中断");
            }
            return "第三方数据返回成功";
        }
    }
}
</code></pre>
<p>这里可以看到，我们使用了带有等待时间的 get 方法来获取数据，当在规定时间内还没有返回数据的时候，此时就会抛出第三方接口网络超时的异常信息。</p>
<h3 id="2-并行计算下的结果获取">2. 并行计算下的结果获取</h3>
<p>假设我们存在 10w 的数据，现在要将其分为 10 个线程处理，每一个线程处理 1w 的数据写入数据库，当数据全部写入成功后，返回写入成功；当数据某一批写入失败，需要返回哪一个区间写入失败。</p>
<pre><code class="language-java">public class ThreadDbTest {
    private final static AtomicInteger IDX = new AtomicInteger(0);

    private final static ThreadPoolExecutor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(10, 20, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(1024), r -&gt; new Thread(r, "open-api-" + IDX.getAndIncrement()), new ThreadPoolExecutor.AbortPolicy());


    public static void main(String[] args) {

        List&lt;Future&lt;String&gt;&gt; futures = new ArrayList&lt;&gt;();

        Future&lt;String&gt; submit1 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(1, 10000, true));
        Future&lt;String&gt; submit2 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(10001, 20000, true));
        Future&lt;String&gt; submit3 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(20001, 30000, true));
        Future&lt;String&gt; submit4 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(30001, 40000, true));
        Future&lt;String&gt; submit5 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(40001, 50000, false));
        Future&lt;String&gt; submit6 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(50001, 60000, true));
        Future&lt;String&gt; submit7 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(70001, 80000, true));
        Future&lt;String&gt; submit8 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(80001, 90000, true));
        Future&lt;String&gt; submit9 = THREAD_POOL_EXECUTOR.submit(new BatchWriteDbTask(90001, 100000, true));

        futures.add(submit1);
        futures.add(submit2);
        futures.add(submit3);
        futures.add(submit4);
        futures.add(submit5);
        futures.add(submit6);
        futures.add(submit7);
        futures.add(submit8);
        futures.add(submit9);

        for (Future&lt;String&gt; future : futures) {
            try {
                System.out.println(future.get());
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }

    }

    public static class BatchWriteDbTask implements Callable&lt;String&gt; {


        private final Integer minIndex;
        private final Integer maxIndex;

        /**
         * 模拟使用， 当为true的时候就写入成功 当为false就写入失败
         */
        private final boolean isSuccess;

        public BatchWriteDbTask(Integer minIndex, Integer maxIndex, boolean isSuccess) {
            this.minIndex = minIndex;
            this.maxIndex = maxIndex;
            this.isSuccess = isSuccess;
        }


        @Override
        public String call() throws Exception {
            System.out.println("开始批量写入数据 " + minIndex + "至" + maxIndex);
            if(!isSuccess) {
                throw new Exception("数据 " + minIndex + "至" + maxIndex + "写入失败，请手动处理。");
            }
            Thread.sleep(5000);
            return "数据"  + minIndex  + "至" + maxIndex + "写入成功";
        }
    }
}
</code></pre>
<p>我们查看最终的运行结果：</p>
<pre><code class="language-txt">开始批量写入数据 1至10000
开始批量写入数据 20001至30000
开始批量写入数据 10001至20000
开始批量写入数据 30001至40000
开始批量写入数据 40001至50000
开始批量写入数据 50001至60000
开始批量写入数据 70001至80000
开始批量写入数据 80001至90000
开始批量写入数据 90001至100000
数据1至10000写入成功
数据10001至20000写入成功
数据20001至30000写入成功
数据30001至40000写入成功
数据50001至60000写入成功
数据70001至80000写入成功
数据80001至90000写入成功
数据90001至100000写入成功
java.util.concurrent.ExecutionException: java.lang.Exception: 数据 40001至50000写入失败，请手动处理。
	at java.util.concurrent.FutureTask.report(FutureTask.java:122)
	at java.util.concurrent.FutureTask.get(FutureTask.java:192)
	at com.eight.ThreadDbTest.main(ThreadDbTest.java:44)
Caused by: java.lang.Exception: 数据 40001至50000写入失败，请手动处理。
	at com.eight.ThreadDbTest$BatchWriteDbTask.call(ThreadDbTest.java:76)
	at com.eight.ThreadDbTest$BatchWriteDbTask.call(ThreadDbTest.java:54)
</code></pre>
<p>从最终的运行结果中可以看到，我们程序中预设的 “<strong>40001 至 50000 写入失败</strong>”是被成功捕获异常并返回的。</p>
<p>因为是异步执行，所以程序返回 Future 的时候可能程序并未开始执行或者正在执行中，为了获取最终的计算结果，程序的整体我们使用了一个集合来存储 Future 结果集，然后任务全部提交后遍历这个集合，使用 get 方法来获取真正的执行结果。当任务执行完毕后，get 方法会停止阻塞返回运行结果；当程序运行出错的时候，此时 get 方法会抛出最终的异常信息以供检测使用。</p>
<h2 id="四-总结">四、总结</h2>
<p>本节课我们充分介绍了如何使用 <code>Future</code> 来进行获取线程的数据结果，包括对于 API 的介绍以及使用，我们还使用了几个例子使你加深印象，在异步计算中 <code>Future</code> 能够大大加快计算速度。Dubbo 就是使用 <code>Future</code> 来异步获取 API 的结果以及控制超时等能力的。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#91fdfdfda8a5a0a0a1a6d1f6fcf0f8fdbff2fefc" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9358f58bbc3f9c5a',t:'MTc0NTUzMjkyNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="24 数据的持久化存储" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>24 数据的持久化存储 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/01%20%e5%89%8d%e8%a8%80-%e6%95%99%e7%a8%8b%e5%86%85%e5%ae%b9%e5%af%bc%e8%af%bb.md.html" id="01 前言-教程内容导读.md.html">01 前言-教程内容导读.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/02%20Flutter%20%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e7%9a%84%e6%90%ad%e5%bb%ba.md.html" id="02 Flutter 开发环境的搭建.md.html">02 Flutter 开发环境的搭建.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/03%20%e6%96%b0%e6%89%8b%e6%9d%91%e5%9f%ba%e7%a1%80%20Dart%20%e8%af%ad%e6%b3%95%20%28%e4%b8%8a%29.md.html" id="03 新手村基础 Dart 语法 (上).md.html">03 新手村基础 Dart 语法 (上).md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/04%20%e6%96%b0%e6%89%8b%e6%9d%91%e5%9f%ba%e7%a1%80%20Dart%20%e8%af%ad%e6%b3%95%20%28%e4%b8%8b%29.md.html" id="04 新手村基础 Dart 语法 (下).md.html">04 新手村基础 Dart 语法 (下).md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/05%20Flutter%20%e8%ae%a1%e6%95%b0%e5%99%a8%e9%a1%b9%e7%9b%ae%e8%a7%a3%e8%af%bb.md.html" id="05 Flutter 计数器项目解读.md.html">05 Flutter 计数器项目解读.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/06%20%e7%8c%9c%e6%95%b0%e5%ad%97%e7%95%8c%e9%9d%a2%e4%ba%a4%e4%ba%92%e4%b8%8e%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90.md.html" id="06 猜数字界面交互与需求分析.md.html">06 猜数字界面交互与需求分析.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/07%20%e4%bd%bf%e7%94%a8%e7%bb%84%e4%bb%b6%e6%9e%84%e5%bb%ba%e9%9d%99%e6%80%81%e7%95%8c%e9%9d%a2.md.html" id="07 使用组件构建静态界面.md.html">07 使用组件构建静态界面.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/08%20%e7%8a%b6%e6%80%81%e6%95%b0%e6%8d%ae%e4%b8%8e%e7%95%8c%e9%9d%a2%e6%9b%b4%e6%96%b0.md.html" id="08 状态数据与界面更新.md.html">08 状态数据与界面更新.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/09%20%e6%a0%a1%e9%aa%8c%e7%bb%93%e6%9e%9c%e4%b8%8e%e6%8f%90%e7%a4%ba%e4%bf%a1%e6%81%af.md.html" id="09 校验结果与提示信息.md.html">09 校验结果与提示信息.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/10%20%e5%8a%a8%e7%94%bb%e4%bd%bf%e7%94%a8%e4%b8%8e%e7%8a%b6%e6%80%81%e5%91%a8%e6%9c%9f.md.html" id="10 动画使用与状态周期.md.html">10 动画使用与状态周期.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/11%20%e7%8c%9c%e6%95%b0%e5%ad%97%e6%95%b4%e7%90%86%e4%b8%8e%e6%80%bb%e7%bb%93.md.html" id="11 猜数字整理与总结.md.html">11 猜数字整理与总结.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/12%20%e7%94%b5%e5%ad%90%e6%9c%a8%e9%b1%bc%e7%95%8c%e9%9d%a2%e4%ba%a4%e4%ba%92%e4%b8%8e%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90.md.html" id="12 电子木鱼界面交互与需求分析.md.html">12 电子木鱼界面交互与需求分析.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/13%20%e7%94%b5%e5%ad%90%e6%9c%a8%e9%b1%bc%e9%9d%99%e6%80%81%e7%95%8c%e9%9d%a2%e6%9e%84%e5%bb%ba.md.html" id="13 电子木鱼静态界面构建.md.html">13 电子木鱼静态界面构建.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/14%20%e8%ae%a1%e6%95%b0%e5%8f%98%e5%8c%96%e4%b8%8e%e9%9f%b3%e6%95%88%e6%92%ad%e6%94%be.md.html" id="14 计数变化与音效播放.md.html">14 计数变化与音效播放.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/15%20%e5%bc%b9%e5%87%ba%e9%80%89%e9%a1%b9%e4%b8%8e%e5%88%87%e6%8d%a2%e7%8a%b6%e6%80%81.md.html" id="15 弹出选项与切换状态.md.html">15 弹出选项与切换状态.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/16%20%e7%94%a8%e6%bb%91%e5%8a%a8%e5%88%97%e8%a1%a8%e5%b1%95%e7%a4%ba%e8%ae%b0%e5%bd%95.md.html" id="16 用滑动列表展示记录.md.html">16 用滑动列表展示记录.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/17%20%e7%94%b5%e5%ad%90%e6%9c%a8%e9%b1%bc%e6%95%b4%e7%90%86%e4%b8%8e%e6%80%bb%e7%bb%93.md.html" id="17 电子木鱼整理与总结.md.html">17 电子木鱼整理与总结.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/18%20%e7%99%bd%e6%9d%bf%e7%bb%98%e5%88%b6%e7%95%8c%e9%9d%a2%e4%ba%a4%e4%ba%92%e4%b8%8e%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90.md.html" id="18 白板绘制界面交互与需求分析.md.html">18 白板绘制界面交互与需求分析.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/19%20%e8%ae%a4%e8%af%86%e8%87%aa%e5%ae%9a%e4%b9%89%e7%bb%98%e5%88%b6%e7%bb%84%e4%bb%b6.md.html" id="19 认识自定义绘制组件.md.html">19 认识自定义绘制组件.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/20%20%e9%80%9a%e8%bf%87%e6%89%8b%e5%8a%bf%e5%9c%a8%e7%99%bd%e6%9d%bf%e4%b8%8a%e7%bb%98%e5%88%b6.md.html" id="20 通过手势在白板上绘制.md.html">20 通过手势在白板上绘制.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/21%20%e7%99%bd%e6%9d%bf%e7%94%bb%e7%ac%94%e7%9a%84%e5%8f%82%e6%95%b0%e8%ae%be%e7%bd%ae.md.html" id="21 白板画笔的参数设置.md.html">21 白板画笔的参数设置.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/22%20%e6%92%a4%e9%94%80%e5%8a%9f%e8%83%bd%e4%b8%8e%e7%94%bb%e6%9d%bf%e4%bc%98%e5%8c%96.md.html" id="22 撤销功能与画板优化.md.html">22 撤销功能与画板优化.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/23%20%e5%ba%94%e7%94%a8%e7%95%8c%e9%9d%a2%e6%95%b4%e5%90%88.md.html" id="23 应用界面整合.md.html">23 应用界面整合.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/24%20%e6%95%b0%e6%8d%ae%e7%9a%84%e6%8c%81%e4%b9%85%e5%8c%96%e5%ad%98%e5%82%a8.md.html" id="24 数据的持久化存储.md.html">24 数据的持久化存储.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/25%20%e7%bd%91%e7%bb%9c%e6%95%b0%e6%8d%ae%e7%9a%84%e8%ae%bf%e9%97%ae.md.html" id="25 网络数据的访问.md.html">25 网络数据的访问.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Flutter%e5%85%a5%e9%97%a8%e6%95%99%e7%a8%8b/26%20%e6%95%99%e7%a8%8b%e6%80%bb%e7%bb%93%e4%b8%8e%e5%b1%95%e6%9c%9b.md.html" id="26 教程总结与展望.md.html">26 教程总结与展望.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="24 数据的持久化存储" id="title">24 数据的持久化存储</h1>
<div><h4 id="一-猜数字项目的配置信息存储">一、猜数字项目的配置信息存储</h4>
<p>在猜数字项目中，界面的状态数据有三个：</p>
<table>
<thead>
<tr>
<th>数据名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_guessing</code></td>
<td>bool</td>
<td>是否在猜数字游戏中</td>
</tr>
<tr>
<td><code>_value</code></td>
<td>int</td>
<td>待猜测的数字</td>
</tr>
<tr>
<td><code>_isBig</code></td>
<td>bool?</td>
<td>是否更大</td>
</tr>
</tbody>
</table>
<p>现在的目的是，在退出应用后：可以继续上次的游戏进程，那么需要记录 <code>_guessing</code> 和 <code>_value</code> 两个数据。对于这种简单的配置数据，可以通过 <a href="https://pub.flutter-io.cn/packages/shared_preferences" target="_blank">shared_preferences</a> 插件存储为 xml 配置文件。首先需要添加依赖：</p>
<pre><code class="language-yaml">dependencies:
  ...
  shared_preferences: ^2.1.1
</code></pre>
<hr/>
<h5 id="1-单例模式访问对象和存储配置">1. 单例模式访问对象和存储配置</h5>
<p>数据的持久化中，我们需要在很多地方对数据进行读取和写入。这里将该功能封装为一个类进行操作，并提供唯一的静态对象，方便访问。 如下所示，创建一个 <code>SpStorage</code> 的类，私有化构造并提供实例对象的访问途径：</p>
<pre><code class="language-dart">----&gt;[lib/storage]----
class SpStorage {
  SpStorage._(); // 私有化构造

  static SpStorage? _storage;

  // 提供实例对象的访问途径
  static SpStorage get instance {
    _storage = _storage ?? SpStorage._();
    return _storage!;
  }
}
</code></pre>
<hr/>
<h5 id="2-配置信息的存储">2. 配置信息的存储</h5>
<p>如下所示，在类中提供 <code>saveGuessConfig</code> 方法用于保存猜数字的配置信息。核心方法是使用 <code>SharedPreferences</code> 对象的 setString 方法，根据 key 值存储字符串。这里通过 <code>json.encode</code> 方法将 Map 对象编码成字符串：</p>
<pre><code class="language-dart">const String kGuessSpKey = 'guess-config';

class SpStorage {
  SpStorage._();

  // 略同...

  SharedPreferences? _sp;

  Future&lt;void&gt; initSpWhenNull() async {
    if (_sp != null) return;
    _sp = _sp ?? await SharedPreferences.getInstance();
  }

  Future&lt;bool&gt; saveGuess({
    required bool guessing,
    required int value,
  }) async {
    await initSpWhenNull();
    String content = json.encode({'guessing': guessing, 'value': value});
    return _sp!.setString(kGuessSpKey, content);
  }
}
</code></pre>
<hr/>
<p>由于 SpStorage 提供了静态的单例对象，所以在任何类中都可以通过 <code>SpStorage.instance</code> 得到实例对象。比如下面在 <code>_GuessPageState</code> 中生成随机数时，调用 <code>saveGuessConfig</code> 方法来存储记录，在如下文件中可以看到存储的配置信息：</p>
<blockquote>
<p>/data/data/com.toly1994.flutter_first_station/shared_prefs/FlutterSharedPreferences.xml</p>
</blockquote>
<p><img alt="image.png" src="assets/644e078ed1a6451694b7e1033c3b3752_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<pre><code class="language-ini">----&gt;[_GuessPageState#_generateRandomValue]----
void _generateRandomValue() {
  setState(() {
    _guessing = true;
    _value = _random.nextInt(100);
    SpStorage.instance.saveGuessConfig(guessing: _guessing,value: _value);
    print(_value);
  });
}
</code></pre>
<hr/>
<h5 id="3-访问配置与恢复状态">3. 访问配置与恢复状态</h5>
<p>光存储起来，只完成了一半，还需要读取配置，并根据配置来设置猜数字的状态数据。如下所示，在 SpStorage 类中提供 <code>readGuessConfig</code> 方法用于读取猜数字的配置信息。核心方法是使用 <code>SharedPreferences</code> 对象的 getString 方法，根据 key 值获取存储的字符串。这里通过 <code>json.decode</code> 方法将字符串解码成 Map 对象：</p>
<pre><code class="language-dart">class SpStorage {

  // 略同...
  
  Future&lt;Map&lt;String,dynamic&gt;&gt; readGuessConfig() async {
    await initSpWhenNull();
    String content = _sp!.getString(kGuessSpKey)??"{}";
    return json.decode(content);
  }

}
</code></pre>
<hr/>
<p>方便起见，这里在 <code>_GuessPageState</code> 的 <code>initState</code> 中读取配置文件，并为状态类赋值，完成存储数据的回显。在实际项目中，这些配置信息可以在闪屏页中提前读取。</p>
<pre><code class="language-scala">class _GuessPageState extends State&lt;GuessPage&gt; with SingleTickerProviderStateMixin,AutomaticKeepAliveClientMixin{

  @override
  void initState() {
    // 略...
    _initConfig();
  }

  void _initConfig() async{
    Map&lt;String,dynamic&gt; config = await SpStorage.instance.readGuessConfig();
    _guessing = config['guessing']??false;
    _value = config['value']??0;
    setState(() {

    });
  }
</code></pre>
<p>这样，在生成数字之后，杀死应用，然后打开应用，就可以看到仍会恢复到之前的猜数字状态中，这就是数据持久化的意义所在。当前代码位置: <a href="https://github.com/toly1994328/flutter_first_station/blob/98524f8ca1817166cae1e380739811d23d0921dd/lib/storage/sp_storage.dart" target="_blank">sp_storage.dart</a></p>
<hr/>
<h4 id="二-电子木鱼项目的配置信息存储">二、电子木鱼项目的配置信息存储</h4>
<p>在电子木鱼项目中，需要存储的配置数据有：</p>
<table>
<thead>
<tr>
<th>数据名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>counter</td>
<td>int</td>
<td>功德总数</td>
</tr>
<tr>
<td>activeImageIndex</td>
<td>int</td>
<td>激活图片索引</td>
</tr>
<tr>
<td>activeAudioIndex</td>
<td>int</td>
<td>激活音频索引</td>
</tr>
</tbody>
</table>
<h5 id="1-配置信息的存储">1. 配置信息的存储</h5>
<p>同样，在 <code>SpStorage</code> 中定义 <code>saveMuYUConfig</code> 方法存储木鱼配置的信息。通过 <code>SpStorage</code> 统一对配置信息进行操作，一方面可以集中配置读写的代码逻辑，方便使用，另一方面可以避免在每个状态类内部都获取 <code>SharedPreferences</code> 对象进行操作。</p>
<pre><code class="language-dart">const String kMuYUSpKey = 'muyu-config';

class SpStorage {
  // 略...

  Future&lt;bool&gt; saveMuYUConfig({
    required int counter,
    required int activeImageIndex,
    required int activeAudioIndex,
  }) async {
    await initSpWhenNull();
    String content = json.encode({
      'counter': counter,
      'activeImageIndex': activeImageIndex,
      'activeAudioIndex': activeAudioIndex,
    });
    return _sp!.setString(kMuYUSpKey, content);
  }
}
</code></pre>
<p>然后需要在配置数据发生变化的事件中保存配置，也就是在 <code>_MuyuPageState</code> 类中敲击木鱼、选择音频，选择图片三个场景，这三处的代码位置大家应该非常清楚。为了方便调用，这里写一个 <code>saveConfig</code> 方法来触发。然后操作界面，配置文件中就会存储对应的信息：</p>
<p><img alt="image.png" src="assets/0e58ec01a8264cdfbbff89e967e85cf0_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<pre><code class="language-less">---&gt;[_MuyuPageState]---
void saveConfig() {
  SpStorage.instance.saveMuYUConfig(
    counter: _counter,
    activeImageIndex: activeAudioIndex,
    activeAudioIndex: _activeAudioIndex,
  );
}
</code></pre>
<hr/>
<h5 id="2-配置信息的读取">2. 配置信息的读取</h5>
<p>同理，在 <code>SpStorage</code> 中读取配置信息：</p>
<pre><code class="language-dart">class SpStorage {
  // 略同...
  Future&lt;Map&lt;String, dynamic&gt;&gt; readMuYUConfig() async {
    await initSpWhenNull();
    String content = _sp!.getString(kMuYUSpKey) ?? "{}";
    return json.decode(content);
  }
}
</code></pre>
<p>并在 <code>_MuyuPageState</code> 初始化状态回调中，读取配置对状态数据进行设置。</p>
<pre><code class="language-scss">class _MuyuPageState extends State&lt;MuyuPage&gt;
    with AutomaticKeepAliveClientMixin {
  // 略同...
  @override
  void initState() {
    super.initState();
    _initAudioPool();
    _initConfig();
  }

  void _initConfig() async{
    Map&lt;String,dynamic&gt; config = await SpStorage.instance.readMuYUConfig();
    _counter = config['counter']??0;
    _activeImageIndex = config['activeImageIndex']??0;
    _activeAudioIndex = config['activeAudioIndex']??0;
    setState(() {
    });
  }
</code></pre>
<p>这样，电子木鱼的配置信息就存储和读取的功能就实现完毕了，当前代码位置: <a href="https://github.com/toly1994328/flutter_first_station/blob/fe21bfcba3add7006d331ce6092228019d8cef2a/lib/storage/sp_storage.dart" target="_blank">sp_storage.dart</a></p>
<blockquote>
<p>小练习：自己尝试完成白板绘制中颜色、线宽配置的数据持久化。</p>
</blockquote>
<hr/>
<h4 id="三-通过数据库进行存储">三、通过数据库进行存储</h4>
<p>上面属于通过文件的方式来持久化数据，比较适合存储一些小的配置数据。如果想存储大量的数据，并且希望可以进行复杂的查询，最好使用数据库来存储。这里将对木鱼点击时的功德数记录，使用 sqlite 数据库进行存储。不过不会介绍的太深，会创建数据库和表，存储数据、读取数据即可。毕竟数据库的操作是另一门学问，感兴趣的可以系统地学习一下。</p>
<hr/>
<h5 id="1-sqlite-数据库插件">1. sqlite 数据库插件</h5>
<p>目前来说，最完善的 sqlite 数据库插件是 <a href="https://pub.flutter-io.cn/packages/sqflite" target="_blank">sqlite</a> , 使用前首先需要添加依赖：</p>
<pre><code class="language-yaml">dependencies:
  ...
  sqflite: ^2.2.8+2
</code></pre>
<p><img alt="image.png" src="assets/9837220755b54a4e92f76ec15690bb34_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<p>对于数据库操作来说，全局提供一个访问对象即可，也可以通过单例模式来处理，如下定义 <code>DbStorage</code> 类：</p>
<pre><code class="language-dart">----&gt;[storage/db_storage/db_storage.dart]----
class DbStorage {
  DbStorage._();

  static DbStorage? _storage;

  static DbStorage get instance {
    _storage = _storage ?? DbStorage._();
    return _storage!;
  }
}
</code></pre>
<hr/>
<h5 id="2-数据库操作对象-dao">2. 数据库操作对象 Dao</h5>
<p>由于应用程序中可能存在多个数据表，一般每个表会通过一个类来单独操作。比如电子木鱼中的功德记录，是对一条条的 <code>MeritRecord</code> 对象进行记录，这里通过 <code>MeritRecordDao</code> 进行维护。在其构造函数中传入 <code>Database</code> 对象，以便在方法中操作数据库。</p>
<p>首先是数据库的创建语句，通过下面的 <code>createTable</code> 方法完成；使用 <code>Database</code> 的 <code>execute</code> 方法执行 sql 语句：</p>
<pre><code class="language-ini">----&gt;[storage/db_storage/dao/merit_record_dao.dart]----
import 'package:sqflite/sqflite.dart';

class MeritRecordDao {
  final Database database;

  MeritRecordDao(this.database);

  static String tableName = 'merit_record';

  static String tableSql = """
CREATE TABLE $tableName (
id VARCHAR(64) PRIMARY KEY,
value INTEGER, 
image TEXT,
audio TEXT,
timestamp INTEGER
)""";

  static Future&lt;void&gt; createTable(Database db) async{
   return db.execute(tableSql);
  }
}
</code></pre>
<hr/>
<p>然后在 DbStorage 中提供 open 方法打开数据库，如果数据库不存在的话 <code>openDatabase</code> 方法会创建数据库，并触发 <code>_onCreate</code> 回调。在其中可以使用 MeritRecordDao 执行数据表创建的逻辑。另外 DbStorage 持有 MeritRecordDao 类型对象，在数据库打开之后，初始化对象：</p>
<pre><code class="language-dart">----&gt;[storage/db_storage/db_storage.dart]----

class DbStorage {
  //略同...
  
  late Database _db;

  late MeritRecordDao _meritRecordDao;
  MeritRecordDao get meritRecordDao =&gt; _meritRecordDao;

  void open() async {
    String databasesPath = await getDatabasesPath();
    String dbPath = path.join(databasesPath, 'first_station.db');
    _db = await openDatabase(dbPath, version: 1, onCreate: _onCreate);
    _meritRecordDao = MeritRecordDao(_db);
  }

  void _onCreate(Database db, int version) async {
   await MeritRecordDao.createTable(db);
  }

}
</code></pre>
<p>像打开数据库、加载本地资源的操作，在实际项目中可以放在闪屏页中处理。不过这里方便起见，直接程序开始时打开数据库。现在运行项目之后，就可以看到数据库已经创建了：</p>
<p><img alt="image.png" src="assets/8589f031719d4a75a94b2fad7fc03d1c_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<pre><code class="language-csharp">void main() async{
  WidgetsFlutterBinding.ensureInitialized();
  await DbStorage.instance.open(); // 打开数据库
  runApp(const MyApp());
}
</code></pre>
<p>在 AndroidStudio 的 App inspection 中，可以查看当前运行项目在的数据库情况：</p>
<p><img alt="image.png" src="assets/26a2fddfdece46a7b88da25f82cdd29d_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<hr/>
<h5 id="3-数据的存储和读取方法">3. 数据的存储和读取方法</h5>
<p>如下所示，在 <code>MeritRecordDao</code> 中定义 <code>insert</code> 方法插入记录数据；定义 <code>query</code> 方法读取记录列表。</p>
<pre><code class="language-scss">class MeritRecordDao {
  // 略同...
  Future&lt;int&gt; insert(MeritRecord record) {
    return database.insert(
      tableName,
      record.toJson(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future&lt;List&lt;MeritRecord&gt;&gt; query() async {
    List&lt;Map&lt;String, Object?&gt;&gt; data = await database.query(
      tableName,
    );
    return data
        .map((e) =&gt; MeritRecord(
              e['id'].toString(),
              e['timestamp'] as int,
              e['value'] as int,
              e['image'].toString(),
              e['audio'].toString(),
            ))
        .toList();
  }
}
</code></pre>
<p>插入时需要传入 Map 对象，这里为 <code>MeritRecord</code> 类提供一个 toJson 的方法，以便将对象转为 Map :</p>
<pre><code class="language-arduino">class MeritRecord {
  final String id;
  final int timestamp;
  final int value;
  final String image;
  final String audio;

  MeritRecord(this.id, this.timestamp, this.value, this.image, this.audio);

  Map&lt;String, dynamic&gt; toJson() =&gt; {
    "id":id,
    "timestamp": timestamp,
    "value": value,
    "image": image,
    "audio": audio,
  };
}
</code></pre>
<hr/>
<h5 id="4-使用-dao-完成数据读写功能">4.使用 Dao 完成数据读写功能</h5>
<p>前面数据操作层准备完毕之后，使用起来就非常简单了。就剩两件事：</p>
<ul>
<li>在 <code>_MuyuPageState</code> 中点击时存入数据库。</li>
</ul>
<p><img alt="image.png" src="assets/468fd9890a4c44e7ad074e89f8eb02cb_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<ul>
<li>在 <code>_MuyuPageState</code> 中状态初始化时读取数据。</li>
</ul>
<p><img alt="image.png" src="assets/4bd86f6628404914b6b29dcbdd099b40_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<p>然后点击木鱼后就可以看到数据表中会存储对于的数据，应用退出之后也能从数据库中加载数据。</p>
<p><img alt="image.png" src="assets/4feea28eb9f843aaa7850ac3da3a5b58_tplv-k3u1fbpfcp-jj-mark_1890_0_0_0_q75.awebp"/></p>
<hr/>
<h4 id="四-本章小结">四、 本章小结</h4>
<p>本章主要介绍使用 shared_preferences 通过 xml 存储配置数据；以及使用 sqflite 通过 sqlite3 数据库存储数据记录。其中也涉及了对单例模式的使用，让程序中只有一个数据的访问对象，一方面可以简化使用方式，另一方面也可以避免多次连接数据库，造成无意义的浪费。</p>
<p>到这里数据的本地持久化就介绍的差不多了，当前代码位置 <a href="https://github.com/toly1994328/flutter_first_station/tree/f1b902ab5831d82477908ed1068ace2afd3bab4d/lib/storage/db_storage" target="_blank">db_storage.dart</a> 。对于新手而言这算比较复杂的，希望大家可以好好消化。当然这些只是最简单的 Demo 级应用，怎么简单怎么来。对实际项目来说，整体的应用结构，数据维护和传递的方式，逻辑触发的时机都需要认真的考量，本教程只在新手的指引，就不展开介绍了。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#543838386d6065656463143339353d387a373b39" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</hr></div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9359ef55fa61879a',t:'MTc0NTU0MzE1Ni4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
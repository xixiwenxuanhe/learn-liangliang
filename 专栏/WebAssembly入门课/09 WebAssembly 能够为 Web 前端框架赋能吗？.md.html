<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="09 WebAssembly 能够为 Web 前端框架赋能吗？" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>09 WebAssembly 能够为 Web 前端框架赋能吗？ </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e6%88%91%e4%bb%ac%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%ba%86%e8%a7%a3%20WebAssembly%ef%bc%9f.md.html" id="00 开篇词 我们为什么要了解 WebAssembly？.md.html">00 开篇词 我们为什么要了解 WebAssembly？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/01%20%e5%9f%ba%e7%a1%80%e7%af%87%ef%bc%9a%e5%ad%a6%e4%b9%a0%e6%ad%a4%e8%af%be%e7%a8%8b%e4%bd%a0%e9%9c%80%e8%a6%81%e4%ba%86%e8%a7%a3%e5%93%aa%e4%ba%9b%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%ef%bc%9f.md.html" id="01 基础篇：学习此课程你需要了解哪些基础知识？.md.html">01 基础篇：学习此课程你需要了解哪些基础知识？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/02%20%e5%8e%86%e5%8f%b2%e7%af%87%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%20WebAssembly%20%e8%bf%99%e6%a0%b7%e4%b8%80%e9%97%a8%e6%8a%80%e6%9c%af%ef%bc%9f.md.html" id="02 历史篇：为什么会有 WebAssembly 这样一门技术？.md.html">02 历史篇：为什么会有 WebAssembly 这样一门技术？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/03%20WebAssembly%20%e6%98%af%e4%b8%80%e9%97%a8%e6%96%b0%e7%9a%84%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e5%90%97%ef%bc%9f.md.html" id="03 WebAssembly 是一门新的编程语言吗？.md.html">03 WebAssembly 是一门新的编程语言吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/04%20WebAssembly%20%e6%a8%a1%e5%9d%97%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%84%e6%88%90%e7%bb%93%e6%9e%84%e5%88%b0%e5%ba%95%e6%9c%89%e5%a4%9a%e7%ae%80%e5%8d%95%ef%bc%9f.md.html" id="04 WebAssembly 模块的基本组成结构到底有多简单？.md.html">04 WebAssembly 模块的基本组成结构到底有多简单？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/05%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e7%bc%96%e7%a0%81%ef%bc%9aWebAssembly%20%e5%be%ae%e8%a7%82%e4%b8%96%e7%95%8c%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e8%a7%84%e5%88%99%e6%98%af%e4%bb%80%e4%b9%88%ef%bc%9f.md.html" id="05 二进制编码：WebAssembly 微观世界的基本数据规则是什么？.md.html">05 二进制编码：WebAssembly 微观世界的基本数据规则是什么？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/06%20WAT%ef%bc%9a%e5%a6%82%e4%bd%95%e8%ae%a9%e4%b8%80%e4%b8%aa%20WebAssembly%20%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%a8%a1%e5%9d%97%e7%9a%84%e5%86%85%e5%ae%b9%e6%98%93%e4%ba%8e%e8%a7%a3%e8%af%bb%ef%bc%9f.md.html" id="06 WAT：如何让一个 WebAssembly 二进制模块的内容易于解读？.md.html">06 WAT：如何让一个 WebAssembly 二进制模块的内容易于解读？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/07%20WASI%ef%bc%9a%e4%bd%a0%e5%90%ac%e8%af%b4%e8%bf%87%20WebAssembly%20%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%8e%a5%e5%8f%a3%e5%90%97%ef%bc%9f.md.html" id="07 WASI：你听说过 WebAssembly 操作系统接口吗？.md.html">07 WASI：你听说过 WebAssembly 操作系统接口吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/08%20API%ef%bc%9a%e5%9c%a8%20WebAssembly%20MVP%20%e6%a0%87%e5%87%86%e4%b8%8b%e4%bd%a0%e8%83%bd%e5%81%9a%e5%88%b0%e5%93%aa%e4%ba%9b%e4%ba%8b%ef%bc%9f.md.html" id="08 API：在 WebAssembly MVP 标准下你能做到哪些事？.md.html">08 API：在 WebAssembly MVP 标准下你能做到哪些事？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/09%20WebAssembly%20%e8%83%bd%e5%a4%9f%e4%b8%ba%20Web%20%e5%89%8d%e7%ab%af%e6%a1%86%e6%9e%b6%e8%b5%8b%e8%83%bd%e5%90%97%ef%bc%9f.md.html" id="09 WebAssembly 能够为 Web 前端框架赋能吗？.md.html">09 WebAssembly 能够为 Web 前端框架赋能吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/10%20%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b7%b2%e7%bb%8f%e6%8a%95%e5%85%a5%e7%94%9f%e4%ba%a7%e7%9a%84%20WebAssembly%20%e7%9c%9f%e5%ae%9e%e6%a1%88%e4%be%8b%ef%bc%9f.md.html" id="10 有哪些已经投入生产的 WebAssembly 真实案例？.md.html">10 有哪些已经投入生产的 WebAssembly 真实案例？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/11%20WebAssembly%20%e5%9c%a8%e7%89%a9%e8%81%94%e7%bd%91%e3%80%81%e5%a4%9a%e5%aa%92%e4%bd%93%e4%b8%8e%e4%ba%91%e6%8a%80%e6%9c%af%e6%96%b9%e9%9d%a2%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%9b%e6%96%b0%e5%ae%9e%e8%b7%b5%ef%bc%9f.md.html" id="11 WebAssembly 在物联网、多媒体与云技术方面有哪些创新实践？.md.html">11 WebAssembly 在物联网、多媒体与云技术方面有哪些创新实践？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/12%20%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%a7%80%e7%9a%84%20WebAssembly%20%e7%bc%96%e8%af%91%e5%99%a8%e4%b8%8e%e8%bf%90%e8%a1%8c%e6%97%b6%ef%bc%9f.md.html" id="12 有哪些优秀的 WebAssembly 编译器与运行时？.md.html">12 有哪些优秀的 WebAssembly 编译器与运行时？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/13%20LLVM%ef%bc%9a%e5%a6%82%e4%bd%95%e5%b0%86%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e8%af%ad%e8%a8%80%e7%bc%96%e8%af%91%e5%88%b0%20WebAssembly%ef%bc%9f.md.html" id="13 LLVM：如何将自定义的语言编译到 WebAssembly？.md.html">13 LLVM：如何将自定义的语言编译到 WebAssembly？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/14%20%e6%9c%89%e5%93%aa%e4%ba%9b%e6%ad%a3%e5%9c%a8%e8%a1%8c%e8%bf%9b%e4%b8%ad%e7%9a%84%20WebAssembly%20Post-MVP%20%e6%8f%90%e6%a1%88%ef%bc%9f.md.html" id="14 有哪些正在行进中的 WebAssembly Post-MVP 提案？.md.html">14 有哪些正在行进中的 WebAssembly Post-MVP 提案？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/15%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20WebAssembly%20%e5%9c%a8%e7%ba%bf%e5%a4%9a%e5%aa%92%e4%bd%93%e5%a4%84%e7%90%86%e5%ba%94%e7%94%a8%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9f.md.html" id="15 如何实现一个 WebAssembly 在线多媒体处理应用（一）？.md.html">15 如何实现一个 WebAssembly 在线多媒体处理应用（一）？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/16%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20WebAssembly%20%e5%9c%a8%e7%ba%bf%e5%a4%9a%e5%aa%92%e4%bd%93%e5%a4%84%e7%90%86%e5%ba%94%e7%94%a8%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9f.md.html" id="16 如何实现一个 WebAssembly 在线多媒体处理应用（二）？.md.html">16 如何实现一个 WebAssembly 在线多媒体处理应用（二）？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/17%20%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%20WebAssembly%20%e5%9c%a8%e7%ba%bf%e5%a4%9a%e5%aa%92%e4%bd%93%e5%a4%84%e7%90%86%e5%ba%94%e7%94%a8%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9f.md.html" id="17 如何实现一个 WebAssembly 在线多媒体处理应用（三）？.md.html">17 如何实现一个 WebAssembly 在线多媒体处理应用（三）？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/18%20%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%20Wasm%20%e5%ba%94%e7%94%a8%e7%9a%84%e8%b0%83%e8%af%95%e4%b8%8e%e5%88%86%e6%9e%90%ef%bc%9f.md.html" id="18 如何进行 Wasm 应用的调试与分析？.md.html">18 如何进行 Wasm 应用的调试与分析？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/19%20%e5%a6%82%e4%bd%95%e5%ba%94%e7%94%a8%20WASI%20%e5%8f%8a%e5%85%b6%e7%9b%b8%e5%85%b3%e7%94%9f%e6%80%81%ef%bc%9f.md.html" id="19 如何应用 WASI 及其相关生态？.md.html">19 如何应用 WASI 及其相关生态？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/20%20%e6%80%bb%e7%bb%93%e4%b8%8e%e7%ad%94%e7%96%91.md.html" id="20 总结与答疑.md.html">20 总结与答疑.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/WebAssembly%e5%85%a5%e9%97%a8%e8%af%be/%e7%bb%93%e6%9d%9f%e8%af%ad%20WebAssembly%ef%bc%8c%e6%9c%aa%e6%9d%a5%e5%b7%b2%e6%9d%a5.md.html" id="结束语 WebAssembly，未来已来.md.html">结束语 WebAssembly，未来已来.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="09 WebAssembly 能够为 Web 前端框架赋能吗？" id="title">09 WebAssembly 能够为 Web 前端框架赋能吗？</h1>
<div><p>你好，我是于航。</p>
<p>相信现在你已经知道，“WebAssembly” 是由 “Web” 与 “Assembly” 两个单词组成的。前面的 “Web” 代指 Web 平台；后面的 “Assembly” 在我们所熟悉的编程语言体系中，可以理解为“汇编”。</p>
<p>通常来说，汇编语言给人的第一感觉便是“底层，外加高性能”。而这，也正是第一次听说 Wasm 这门技术的开发者们的第一感受。</p>
<p>说到 Web 开发，那我们不得不提到层出不穷的 Web 前端开发框架。以 React、Vue.js 及 Angular 为代表的三大框架的出现，使得 Web 前端应用的开发模式，自 2013 年后便开始逐渐从“旧时代”的 jQuery、Prototype.js 走向了以 “MVVM” 框架为主的“新时代”。</p>
<p>既然我们说 Wasm 起源于 Web，并且它的出现会给未来的 Web 应用开发模式，带来一系列变化。那么，对于这些现阶段在我们日常工作中承担“主力”角色的 Web 前端框架来说，Wasm 会给它们带来怎样的变化呢？未来的 Web 前端开发框架会以怎样的方式与 Wasm 紧密融合呢？</p>
<p>相信这些问题，是每一个 Web 前端开发同学在接触 Wasm 这项技术之后，都会存在的疑问。今天，我们就来看一看，在如今的 Wasm MVP 标准下，对于这些基于 JavaScript 编写的现代 Web 前端框架我们能够做些什么。</p>
<h2 id="几种方案的思考">几种方案的思考</h2>
<p>在上一章的“核心原理篇”中，我们从不同的角度讲解了 Wasm 究竟是什么。那这里我们还是用最精简的方式来概括一下：“Wasm 是一种基于堆栈式虚拟机的二进制指令集，它被设计成为编程语言的可移植编译目标。借助 Web 平台提供的相关接口，我们可以在 Web 浏览器中高效地调用从 Wasm 模块中导出的函数”。</p>
<p>那我们就根据 Wasm 现阶段所具有的这些能力，来讨论一下 Wasm 对现代 Web 前端开发框架可以产生怎样的影响。我将会根据 Wasm 与框架之间的可能融合程度，来从不同的角度加以讨论。相应的，我们可以总结出如下四种方案：</p>
<ul>
<li>使用 Wasm 完全重写现有框架</li>
<li>使用 Wasm 重写现有框架的核心逻辑</li>
<li>使用 Wasm 配合框架增强应用的部分功能</li>
<li>使用其他语言构建 Web 前端框架</li>
</ul>
<p>接下来，我将依次和你讨论上面的这四种情况。</p>
<h3 id="使用-wasm-完全重写现有框架">使用 Wasm 完全重写现有框架</h3>
<p>在这个方案下，我们将使用 Wasm 完全重写现有的 Web 前端框架。而这就需要我们通过 JavaScript 之外的诸如 C/C++、Rust 等第三方静态类型语言，将框架的逻辑全部重写。先不谈能否实现，我们先来看看在这种方案下，前端框架的使用方式会发生怎样的改变。</p>
<p>在此之前，Web 前端框架的使用方式可以通过如下图来大致描述。</p>
<p><img alt="" src="assets/51d94a145ab0468cac206fb44acd7438.jpg"/></p>
<p>你可以看到，除去样式文件（CSS）以外，我们的 Web 应用程序仅由“框架代码”和“应用程序代码”两部分组成。这两部分代码全部由 JavaScript 语言进行编写。HTML 文件负责将这些 JavaScript 代码整合在一起，并确保在页面加载时执行它们。</p>
<p>当我们将 Web 前端框架使用 Wasm 完全重写后，事情又会变成另外一幅景象。此时的 Web 应用组成结构将如下图所示。</p>
<p><img alt="" src="assets/40c730771dca46dd8aeac2744f6a2b0a.jpg"/></p>
<p>除了使用 JavaScript 编写的“应用程序代码”，以及经过编译生成的 Wasm 字节码格式的框架代码以外，我们的项目中还会多出来一部分用作 “Glue Code”（胶水代码）的 JavaScript 代码。那这部分 Glue Code 主要用来做什么呢？这就要从现阶段的 Wasm 标准与 Web 浏览器的可交互性开始说起了。</p>
<h4 id="无法剥离的-javascript-代码">无法剥离的 JavaScript 代码</h4>
<p>在现阶段 Wasm 的 MVP 标准中，我们需要通过各类 JavaScript API 与 Web API 来在 Web 平台上与 Wasm 代码（模块）进行交互。这些 API 均只能够通过 JavaScript 代码来进行调用。而所有这些需要与 Wasm 模块直接进行的交互（互操作），都是由包含有 API 调用的 Glue Code 代码完成的。</p>
<p>恰巧在目前 Wasm 的 MVP 标准中，我们也同样无法直接在 Wasm 字节码中操作 HTML 页面上的 DOM 元素。因此，对于这部分 Web 框架最核心的功能，便也是需要通过借助 Glue Code 调用 Web API 来帮助我们完成的。</p>
<p>为了达到这个目的，我们需要将 DOM 操作相关的逻辑封装成 JavaScript 函数，然后再通过 Wasm 模块的 Import Section 导入到模块中供其使用。</p>
<p>因此，框架代码与 Glue Code 之间的协作方式可能会类似如下代码形式。首先是框架对应的 C++ 代码。</p>
<pre><code>// framework.cpp
extern void createEmptyDivElement();
int main(int argc, char** argv) {
  createEmptyDivElement();  // 创建一个空的 "div" 标签；
  createEmptyDivElement();
  ...
  return 0;
}
</code></pre>
<p>然后下面是 Glue Code 对应的 JavaScript 代码。</p>
<pre><code>// glue.js
...
WebAssembly.instantiateStreaming(wasmBytes, {
  env: {
    // 将函数导入到 Wasm 模块中；
    createEmptyDivElement: () =&gt; document.createElement('div'),
    ...
  }
})
</code></pre>
<p>可以看到，在 Glue Code 代码中，我们将封装好的用于调用 “document.createElement” 这个 Web API 去创建空 div 标签的 JavaScript 函数 “createEmptyDivElement”，传递给了用于实例化 Wasm 模块的 WebAssembly.instantiateStreaming 方法。</p>
<p>在框架所对应的 C++ 代码中，我们使用了这个从 JavaScript 环境导入到 Wasm 模块中的 “createEmptyDivElement” 函数。这里在代码中，所有通过 “extern” 指定的外部函数，都将会在编译至 Wasm 二进制模块后，从模块对应的 Import Section 中获取实际的函数体。</p>
<p>关于上述的代码示例，你大致有一个印象即可。我们会在“实战篇”中详细介绍一个 Wasm 项目从 0 到 1 的完整构建流程。</p>
<h4 id="跨上下文频繁调用的开销">跨上下文频繁调用的开销</h4>
<p>除了上面提到的，即使将 Web 前端框架完全重写并编译至 Wasm，我们也无法在完全脱离 JavaScript Glue Code 的情况下使用框架。另一个由此带来的问题在某些情况下可能会显得更加“致命”，那就是 “Wasm 与 JavaScript 两个上下文环境之间的函数调用开销”。</p>
<p>在早期的 Firefox 浏览器（版本 62 以前）上，由于实现问题，导致不管是使用 JavaScript 调用从 Wasm 模块中导出的函数，还是在 Wasm 模块内调用从 Web 浏览器导入到模块内的 JavaScript 函数，这两种方式的函数调用成本都十分高昂。在某些情况下，同样的函数调用过程会比 JavaScript 之间的函数调用过程慢约 20 倍。</p>
<p>但好在 Firefox 在 62 之后的版本中修复了这个问题。并着重优化了 JavaScript 与 Wasm 之间的函数调用效率。甚至在某些情况下，JavaScript 与 Wasm 之间的函数调用效率要高于 JavaScript 之间的函数效率。</p>
<p>虽然这个问题在 Firefox 上得到了修复，但不可否认的是，在其他浏览器厂商的 Wasm 实现中，也可能会出现类似的性能问题。</p>
<p>Web 前端框架作为一个需要与 DOM 元素，以及相关 Web API 强相互依赖的技术产品，可想而知其在实际使用过程中，必然会通过 Glue Code 去完成 Wasm 与 JavaScript 之间的频繁函数调用。而以性能为重的 Web 前端框架，则无法忽视这些由于频繁函数调用带来的性能损耗。</p>
<h3 id="使用-wasm-重写现有框架的核心逻辑">使用 Wasm 重写现有框架的核心逻辑</h3>
<p>在第二种方案下，我们将使用 Wasm 重写 Web 前端框架的核心逻辑，但并非全部。</p>
<p>如下图所示，在这种情况下，Web 应用的主要组成结构与上一种方案类似，唯一的不同是增加了 Web 框架所对应的 JavaScript 代码实现部分。</p>
<p><img alt="" src="assets/4386c88882a2458b9a8a006b01549419.jpg"/></p>
<p>相较于将整个框架都通过 Wasm 来实现，仅实现框架的核心逻辑部分，可以说更具有现实意义，而这也是现阶段大多数的框架开发者都在实践的方向。</p>
<p>所谓“核心逻辑”，其实依框架的具体实现不同，无法通过统一、准确的描述来定义。但可以遵循的原则是，这部分逻辑不会涉及与 DOM 或者 Web API 的频繁交互，但其本身却又是“计算密集（compute-intensive）”的。</p>
<p>这里的“计算密集”可以理解为：包含有大量的纯数学计算逻辑。我们知道，Wasm 十分擅长处理这样的计算密集型逻辑。一个很具有代表性的，可以被 Wasm 重写的组件便是 React Fiber 架构中的 Reconciler（主要用来计算 React 中 VDOM 之间的差异）。</p>
<h3 id="使用-wasm-配合框架增强应用的部分功能">使用 Wasm 配合框架增强应用的部分功能</h3>
<p>我们继续逐渐递减 Wasm 与框架的“耦合”程度。</p>
<p>在第三种方案中，从本质上来看，框架本身的代码不会有任何的变化。而 Wasm 也不再着重于优化框架本身的性能。相对地，框架与 Wasm 将会配合起来使用，以优化整个应用的某一部分功能。下面这张图是在这个方案下，一个 Web 应用的基本组成结构。</p>
<p><img alt="" src="assets/a940cc8b65284ec19b2184237642a774.jpg"/></p>
<p>可以看到，这里 Wasm 本身只是作为一个模块，用于优化应用的某方面功能。而 Web 框架本身的源代码组成形式不会发生任何改变，应用仍然还是使用 JavaScript 来构建其主体结构。</p>
<p>事实上，这是 Wasm 在 Web 上的一种最为典型和常见的应用方式。Wasm 并不尝试取代 JavaScript，而是通过利用其优势来补足或者加以提升 Web 应用在某方面的短板。一个最为常见的例子便是前端的“数据编解码”。</p>
<p>我们都知道，“编解码”实际上是十分单纯的数学计算，那么这便是 Wasm 能够大显身手的地方。通过替换 Web 应用中原有的基于 JavaScript 实现的编解码逻辑，使用 Wasm 来实现这部分逻辑则会有着明显的性能提升。而且由于这个过程不涉及与 Web API 的频繁交互，Wasm 所能够带来的性能提升程度更是显而易见的。</p>
<h3 id="使用其他语言构建-web-前端框架">使用其他语言构建 Web 前端框架</h3>
<p>最后一种方案相较于之前的几种可能会稍显激进，但随着 Wasm 发展而不断出现的，一批又一批基于此方案实现的 Web 前端框架，值得让我们重新重视起来。</p>
<p>在此方案下，我们将使用诸如 C++ 和 Rust 等静态类型语言来实现 Web 前端框架。不仅如此，我们也同样需要使用这些语言来编写我们的 Web 应用。类似的框架有基于 Rust 语言的 Yew、Seed，以及基于 Go 语言 Vugu 等等。</p>
<p>以相对较为“流行”的 Yew 框架为例，我们使用它来编写 Web 前端应用的大致思路，与 React 和 Vue.js 等传统 JavaScript Web 前端框架的形式十分类似。以下代码展示了如何使用 Rust 语言基于 Yew 框架，来构建一个基本的 Web 前端应用。</p>
<pre><code>use yew::prelude::*;

pub struct App {}
pub enum Msg {}

impl Component for App {
  type Message = Msg;
  type Properties = ();
  // 应用创建时执行的生命周期函数；
  fn create(_: Self::Properties, _: ComponentLink&lt;Self&gt;) -&gt; Self {
    App {}
  }
  // 应用视图更新时执行的生命周期函数；
  fn update(&amp;mut self, _msg: Self::Message) -&gt; ShouldRender {
    true
  }
  // 定义应用视图结构；
  fn view(&amp;self) -&gt; Html {
    html! {
      &lt;p&gt;{ "Hello, world!" }&lt;/p&gt;
    }
  }
}
</code></pre>
<p>相信即使你不懂 Rust，但如果你熟悉 React，仍然可以发现基于 Yew 构建的 Web 前端应用，它的代码组织结构与 React 十分类似，整个应用也同样被划分为不同的“生命周期”。</p>
<p>比如在上面的代码中，“create” 方法对应应用的创建时刻；update 方法对应应用的状态更新时刻，以及最后用于渲染应用 UI 的 view 方法等等。不仅如此，在 Yew 中也同样拥有组件的概念，使用方式与 React 类似。</p>
<p>相对来说，抛开语言本身带来的成本不谈，单从性能来看，在目前 Wasm 的 MVP 标准下，Yew 这类框架的潜力还没有实际的显露出来。Yew 希望能够借助 Wasm 的能力，将视图（VDOM）差异的计算过程以更高性能的方式进行实现。但鉴于目前 MVP 标准下的一些限制，实际上在最后的编译产物中，Glue Code 执行时所带来的成本则会与 Wasm 带来的性能提升相互抵消。</p>
<p>不仅如此，考虑到目前 JavaScript 在构建 Web 应用时的丰富生态和资源，单从性能角度进行考量而使用 Yew 等框架也不是一个实际可行的方案。因此，未来这类“跨语言” Web 前端框架的生态会变得如何，也只能够让我们拭目以待了。</p>
<h2 id="已有的讨论">已有的讨论</h2>
<p>在介绍了上述四种，Wasm 可能与 Web 前端框架相互结合的方案后。我们再回过头来，看一看目前仍然流行的几种 JavaScript Web 前端框架有没有进行与 Wasm 结合的相关尝试。这里我选择了 React、Vue.js 以及 Ember.js 这三种 Web 框架。</p>
<h3 id="react">React</h3>
<p>作为目前 Web 前端开发领域中最流行的框架之一。React 暂时还没有计划进行任何与 Wasm 相关的尝试。如下图所示，虽然社区中曾有人提议使用 Wasm 重写 React Fiber 架构中的 Reconciler 组件，但由于目前 Wasm 还无法直接操作 DOM 元素等标准上的限制，导致我们可预见，现阶段即使用 Wasm 重写 React 的 Fiber 算法，框架在实际处理 UI 更新时，可能也不会有着显著的性能提升。因此，对于 React 团队来说，投入产出比是一个值得考量的因素。</p>
<p><img alt="" src="assets/9cf3fd22593e400a872f14364e5f09f8.jpg"/></p>
<h3 id="vue-js">Vue.js</h3>
<p>同 React 类似，Vue.js 的社区内也曾有过类似的讨论，如下图所示。</p>
<p><img alt="" src="assets/68f1f940975d4c6d99585b3ad544e246.jpg"/></p>
<p>但与 React 所不同的是，Vue.js 与 Wasm 的“结合”方式根据框架的具体实现细节，可能有着更多的可能。不过一个不可否认的事实是，Wasm 仍然处在快速的发展阶段。同样的，基于 Wasm 构建的各类应用也同样处在不稳定的维护状态中（比如，上述帖子中提到的 Walt 实际上于 2019 年便不再继续更新）。而目前，正是一个“百花齐放”的时代。</p>
<h3 id="ember-js">Ember.js</h3>
<p>最后我们要来讲讲 Ember.js。</p>
<p>Ember.js 的用户虽然没有 React 与 Vue.js 那么多，但它却是第一个宣布尝试与 Wasm 进行“深度整合”的 Web 前端框架，Ember.js 在内部使用了名为 Glimmer VM 的渲染引擎。与 React 通过使用 Reconciler 组件计算 VDOM 差异来更新 UI 的策略有所不同，Glimmer VM 通过将模板的构建过程分解为独立的虚拟机 “OpCode” 操作，来对 UI 中呈现的动态值进行细粒度更新。</p>
<p><img alt="" src="assets/0e31ab7eb1404d8f83c262fe46edeb46.jpg"/></p>
<p>在 EmberConf 2018 年的技术会议上，来自 Ember.js 团队的 Yehuda Katz 向我们介绍了 Glimmer VM 与 Wasm 的整合情况。你通过上图可以看到，除了 OpCode 模块相关的部分逻辑仍然在使用 JavaScript 构建以外，整个 VM 的大部分功能都已经完成到 Wasm 的迁移。并且该 Wasm 版本的 Glimmer VM 也已经通过了所有的测试集 Case。</p>
<p>但计划赶不上变化，回到 2020 年，我们再来看 Glimmer VM，关于它与 Wasm 整合的消息貌似已经没有了太多的声音。</p>
<p>从 <a href="https://discuss.emberjs.com/t/what-is-the-current-state-of-more-advanced-glimmer-vm-features/18114" target="_blank">Ember.js 官方论坛</a>中我们可以看到，Ember.js 在与 Wasm 进行整合的过程中，其实遇到了很多问题，比如不支持 GC 导致 Wasm 线性内存中使用的资源无法被及时清理。Glimmer VM 还在继续为将来能够完全移植到 Wasm 做着准备。</p>
<p>但无论如何，这都不失为一次非常有意义的尝试。</p>
<h2 id="总结">总结</h2>
<p>好了，讲到这，今天的内容也就基本结束了。最后我来给你总结一下。</p>
<p>在这节课里呢，我主要给你介绍了 Wasm 与 Web 前端框架的一些“故事”。</p>
<p>“Wasm 能否影响，或者说会如何影响现有的、基于 JavaScript 构建的现代 Web 前端框架呢？”这是一个被很多 Web 前端工程师所提及的问题。在这节课中，我尝试按照 Wasm 与 Web 前端框架的“整合程度”不同，将两者能够相互结合的可能方式大致分为了四种方案。</p>
<p>在第一种方案中，我们尝试将整个 Web 框架的全部功能，使用同样的 Wasm 版本进行代替，而应用代码仍然使用 JavaScript 进行编写。但由于现阶段 Wasm MVP 标准的限制，在这种方案下，我们不得不借助 JavaScript Glue Code 的帮助来实现框架的部分功能。</p>
<p>而当 Glue Code 的代码越来越多时，JavaScript 函数与 Wasm 导出函数之间的相互调用会更加频繁，在某些情况下，这可能会产生严重的性能损耗。因此结合现实情况来看，整个方案的可用性并不高。</p>
<p>在第二种方案中，我们尝试仅使用 Wasm 来重写框架的核心部分，比如 React Fiber 架构中的 Reconciler 组件。这类组件通常并不含有过多需要与 Web API 打交道的地方，相对纯粹的计算逻辑更易于 Wasm 能力的发挥。同时这种方案也是现阶段大多数 Web 框架正在尝试的，与 Wasm 进行交互的“常规”方式。</p>
<p>在第三种方案中，我们仅使用 Wasm 来作为 Web 框架的辅助，以优化 Web 应用的某一方面功能。在这种方案中，框架本身的代码结构不会有任何的变化。实际上，这种方案也是传统 Web 应用在利用 Wasm 时的最常规方式。</p>
<p>在最后一个方案中，我们介绍了一种更为激进的方式。在这种方案下，包括 Web 框架和应用代码本身，都会由除 JavaScript 以外的，如 Rust、C++ 和 Go 等静态语言来编写。</p>
<p>但同样受限于现阶段 Wasm MVP 标准的限制，框架本身仍然离不开 JavaScript Glue Code 的帮助。同时考虑到实际的语言使用成本以及 JavaScript 生态的舍弃，这种方案的实际可行性仍有待时间的验证。</p>
<p>无论如何，相信随着 Wasm Post-MVP 标准的不断实现，上述各方案中使用的 Glue Code 代码量将会逐渐减少。随之提升的，便是 Web 框架以及应用的整体运行性能。</p>
<h2 id="课后思考"><strong>课后思考</strong></h2>
<p>最后，我们来做一个思考题吧。</p>
<p>除了我们今天介绍的这四种 Web 框架与 Wasm 的结合使用方式，你还有哪些奇思妙想呢？</p>
<p>今天的课程就结束了，希望可以帮助到你，也希望你在下方的留言区和我参与讨论，同时欢迎你把这节课分享给你的朋友或者同事，一起交流一下。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#ec808080d5d8dddddcdbac8b818d8580c28f8381" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9357d8d0388bd6b7',t:'MTc0NTUyMTI2Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="23 生成汇编代码（二）：把脚本编译成可执行文件" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>23 生成汇编代码（二）：把脚本编译成可执行文件 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%a0%e8%a6%81%e5%ad%a6%e4%b9%a0%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%ef%bc%9f.md.html" id="00 开篇词 为什么你要学习编译原理？.md.html">00 开篇词 为什么你要学习编译原理？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/01%20%e7%90%86%e8%a7%a3%e4%bb%a3%e7%a0%81%ef%bc%9a%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af.md.html" id="01 理解代码：编译器的前端技术.md.html">01 理解代码：编译器的前端技术.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/02%20%e6%ad%a3%e5%88%99%e6%96%87%e6%b3%95%e5%92%8c%e6%9c%89%e9%99%90%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%9a%e7%ba%af%e6%89%8b%e5%b7%a5%e6%89%93%e9%80%a0%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8.md.html" id="02 正则文法和有限自动机：纯手工打造词法分析器.md.html">02 正则文法和有限自动机：纯手工打造词法分析器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/03%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%ba%af%e6%89%8b%e5%b7%a5%e6%89%93%e9%80%a0%e5%85%ac%e5%bc%8f%e8%ae%a1%e7%ae%97%e5%99%a8.md.html" id="03 语法分析（一）：纯手工打造公式计算器.md.html">03 语法分析（一）：纯手工打造公式计算器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/04%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e8%a7%a3%e5%86%b3%e4%ba%8c%e5%85%83%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%ad%e7%9a%84%e9%9a%be%e7%82%b9.md.html" id="04 语法分析（二）：解决二元表达式中的难点.md.html">04 语法分析（二）：解决二元表达式中的难点.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/05%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e4%b8%80%e9%97%a8%e7%ae%80%e5%8d%95%e7%9a%84%e8%84%9a%e6%9c%ac%e8%af%ad%e8%a8%80.md.html" id="05 语法分析（三）：实现一门简单的脚本语言.md.html">05 语法分析（三）：实现一门简单的脚本语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/06%20%e7%bc%96%e8%af%91%e5%99%a8%e5%89%8d%e7%ab%af%e5%b7%a5%e5%85%b7%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%94%a8Antlr%e7%94%9f%e6%88%90%e8%af%8d%e6%b3%95%e3%80%81%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8.md.html" id="06 编译器前端工具（一）：用Antlr生成词法、语法分析器.md.html">06 编译器前端工具（一）：用Antlr生成词法、语法分析器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/07%20%e7%bc%96%e8%af%91%e5%99%a8%e5%89%8d%e7%ab%af%e5%b7%a5%e5%85%b7%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e7%94%a8Antlr%e9%87%8d%e6%9e%84%e8%84%9a%e6%9c%ac%e8%af%ad%e8%a8%80.md.html" id="07 编译器前端工具（二）：用Antlr重构脚本语言.md.html">07 编译器前端工具（二）：用Antlr重构脚本语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/08%20%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e7%94%9f%e5%ad%98%e6%9c%9f%ef%bc%9a%e5%ae%9e%e7%8e%b0%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e5%87%bd%e6%95%b0.md.html" id="08 作用域和生存期：实现块作用域和函数.md.html">08 作用域和生存期：实现块作用域和函数.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/09%20%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%ef%bc%9a%e5%ae%9e%e7%8e%b0%e6%95%b0%e6%8d%ae%e5%92%8c%e6%96%b9%e6%b3%95%e7%9a%84%e5%b0%81%e8%a3%85.md.html" id="09 面向对象：实现数据和方法的封装.md.html">09 面向对象：实现数据和方法的封装.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/10%20%e9%97%ad%e5%8c%85%ef%bc%9a%20%e7%90%86%e8%a7%a3%e4%ba%86%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%83%e5%b0%b1%e4%b8%8d%e5%8f%8d%e7%9b%b4%e8%a7%89%e4%ba%86.md.html" id="10 闭包： 理解了原理，它就不反直觉了.md.html">10 闭包： 理解了原理，它就不反直觉了.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/11%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%8a%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e4%b8%80%e4%b8%aa%e5%ae%8c%e5%96%84%e7%9a%84%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f%ef%bc%9f.md.html" id="11 语义分析（上）：如何建立一个完善的类型系统？.md.html">11 语义分析（上）：如何建立一个完善的类型系统？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/12%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%8b%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e5%81%9a%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9b%b8%e5%85%b3%e6%83%85%e5%86%b5%e7%9a%84%e5%a4%84%e7%90%86%ef%bc%9f.md.html" id="12 语义分析（下）：如何做上下文相关情况的处理？.md.html">12 语义分析（下）：如何做上下文相关情况的处理？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/13%20%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81%ef%bc%9a%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%bf%90%e8%a1%8c%e6%9c%9f%e7%9a%84%e5%8a%a8%e6%80%81%e7%89%b9%e6%80%a7.md.html" id="13 继承和多态：面向对象运行期的动态特性.md.html">13 继承和多态：面向对象运行期的动态特性.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/14%20%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af%e5%ba%94%e7%94%a8%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%8f%e6%98%8e%e5%9c%b0%e6%94%af%e6%8c%81%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%ef%bc%9f.md.html" id="14 前端技术应用（一）：如何透明地支持数据库分库分表？.md.html">14 前端技术应用（一）：如何透明地支持数据库分库分表？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/15%20%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af%e5%ba%94%e7%94%a8%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e6%8a%a5%e8%a1%a8%e5%b7%a5%e5%85%b7%ef%bc%9f.md.html" id="15 前端技术应用（二）：如何设计一个报表工具？.md.html">15 前端技术应用（二）：如何设计一个报表工具？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/16%20NFA%e5%92%8cDFA%ef%bc%9a%e5%a6%82%e4%bd%95%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%b7%a5%e5%85%b7%ef%bc%9f.md.html" id="16 NFA和DFA：如何自己实现一个正则表达式工具？.md.html">16 NFA和DFA：如何自己实现一个正则表达式工具？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/17%20First%e5%92%8cFollow%e9%9b%86%e5%90%88%ef%bc%9a%e7%94%a8LL%e7%ae%97%e6%b3%95%e6%8e%a8%e6%bc%94%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b.md.html" id="17 First和Follow集合：用LL算法推演一个实例.md.html">17 First和Follow集合：用LL算法推演一个实例.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/18%20%e7%a7%bb%e8%bf%9b%e5%92%8c%e8%a7%84%e7%ba%a6%ef%bc%9a%e7%94%a8LR%e7%ae%97%e6%b3%95%e6%8e%a8%e6%bc%94%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b.md.html" id="18 移进和规约：用LR算法推演一个实例.md.html">18 移进和规约：用LR算法推演一个实例.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/19%20%e6%a1%88%e4%be%8b%e6%80%bb%e7%bb%93%e4%b8%8e%e7%83%ad%e7%82%b9%e9%97%ae%e9%a2%98%e7%ad%94%e7%96%91%ef%bc%9a%e5%af%b9%e4%ba%8e%e5%b7%a6%e9%80%92%e5%bd%92%e7%9a%84%e8%af%ad%e6%b3%95%ef%bc%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e7%9a%84%e6%8e%a8%e5%af%bc%e4%b8%8d%e6%98%af%e5%b7%a6%e9%80%92%e5%bd%92%e7%9a%84%ef%bc%9f.md.html" id="19 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？.md.html">19 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/20%20%e9%ab%98%e6%95%88%e8%bf%90%e8%a1%8c%ef%bc%9a%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%90%8e%e7%ab%af%e6%8a%80%e6%9c%af.md.html" id="20 高效运行：编译器的后端技术.md.html">20 高效运行：编译器的后端技术.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/21%20%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9c%ba%e5%88%b6%ef%bc%9a%e7%aa%81%e7%a0%b4%e7%8e%b0%e8%b1%a1%e7%9c%8b%e6%9c%ac%e8%b4%a8%ef%bc%8c%e9%80%8f%e8%bf%87%e8%af%ad%e6%b3%95%e7%9c%8b%e8%bf%90%e8%a1%8c%e6%97%b6.md.html" id="21 运行时机制：突破现象看本质，透过语法看运行时.md.html">21 运行时机制：突破现象看本质，透过语法看运行时.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/22%20%e7%94%9f%e6%88%90%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%85%b6%e5%ae%9e%e4%b8%8d%e9%9a%be%e5%ad%a6.md.html" id="22 生成汇编代码（一）：汇编语言其实不难学.md.html">22 生成汇编代码（一）：汇编语言其实不难学.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/23%20%e7%94%9f%e6%88%90%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e6%8a%8a%e8%84%9a%e6%9c%ac%e7%bc%96%e8%af%91%e6%88%90%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6.md.html" id="23 生成汇编代码（二）：把脚本编译成可执行文件.md.html">23 生成汇编代码（二）：把脚本编译成可执行文件.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/24%20%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%ef%bc%9a%e5%85%bc%e5%ae%b9%e4%b8%8d%e5%90%8c%e7%9a%84%e8%af%ad%e8%a8%80%e5%92%8c%e7%a1%ac%e4%bb%b6.md.html" id="24 中间代码：兼容不同的语言和硬件.md.html">24 中间代码：兼容不同的语言和硬件.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/25%20%e5%90%8e%e7%ab%af%e6%8a%80%e6%9c%af%e7%9a%84%e9%87%8d%e7%94%a8%ef%bc%9aLLVM%e4%b8%8d%e4%bb%85%e4%bb%85%e8%ae%a9%e4%bd%a0%e9%ab%98%e6%95%88.md.html" id="25 后端技术的重用：LLVM不仅仅让你高效.md.html">25 后端技术的重用：LLVM不仅仅让你高效.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/26%20%e7%94%9f%e6%88%90IR%ef%bc%9a%e5%ae%9e%e7%8e%b0%e9%9d%99%e6%80%81%e7%bc%96%e8%af%91%e7%9a%84%e8%af%ad%e8%a8%80.md.html" id="26 生成IR：实现静态编译的语言.md.html">26 生成IR：实现静态编译的语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/27%20%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e6%af%94%e4%bb%96%e7%9a%84%e6%9b%b4%e9%ab%98%e6%95%88%ef%bc%9f.md.html" id="27 代码优化：为什么你的代码比他的更高效？.md.html">27 代码优化：为什么你的代码比他的更高效？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/28%20%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90%ef%bc%9a%e4%bd%a0%e5%86%99%e7%9a%84%e7%a8%8b%e5%ba%8f%ef%bc%8c%e5%ae%83%e6%9b%b4%e6%87%82.md.html" id="28 数据流分析：你写的程序，它更懂.md.html">28 数据流分析：你写的程序，它更懂.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/29%20%e7%9b%ae%e6%a0%87%e4%bb%a3%e7%a0%81%e7%9a%84%e7%94%9f%e6%88%90%e5%92%8c%e4%bc%98%e5%8c%96%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%82%e5%ba%94%e5%90%84%e7%a7%8d%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%ef%bc%9f.md.html" id="29 目标代码的生成和优化（一）：如何适应各种硬件架构？.md.html">29 目标代码的生成和优化（一）：如何适应各种硬件架构？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/30%20%e7%9b%ae%e6%a0%87%e4%bb%a3%e7%a0%81%e7%9a%84%e7%94%9f%e6%88%90%e5%92%8c%e4%bc%98%e5%8c%96%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%82%e5%ba%94%e5%90%84%e7%a7%8d%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%ef%bc%9f.md.html" id="30 目标代码的生成和优化（二）：如何适应各种硬件架构？.md.html">30 目标代码的生成和优化（二）：如何适应各种硬件架构？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/31%20%e5%86%85%e5%ad%98%e8%ae%a1%e7%ae%97%ef%bc%9a%e5%af%b9%e6%b5%b7%e9%87%8f%e6%95%b0%e6%8d%ae%e5%81%9a%e8%ae%a1%e7%ae%97%ef%bc%8c%e5%88%b0%e5%ba%95%e5%8f%af%e4%bb%a5%e6%9c%89%e5%a4%9a%e5%bf%ab%ef%bc%9f.md.html" id="31 内存计算：对海量数据做计算，到底可以有多快？.md.html">31 内存计算：对海量数据做计算，到底可以有多快？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/32%20%e5%ad%97%e8%8a%82%e7%a0%81%e7%94%9f%e6%88%90%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88Spring%e6%8a%80%e6%9c%af%e5%be%88%e5%bc%ba%e5%a4%a7%ef%bc%9f.md.html" id="32 字节码生成：为什么Spring技术很强大？.md.html">32 字节码生成：为什么Spring技术很强大？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/33%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%ef%bc%9a%e8%83%bd%e5%90%a6%e4%b8%8d%e5%81%9c%e4%b8%8b%e6%95%b4%e4%b8%aa%e4%b8%96%e7%95%8c%ef%bc%9f.md.html" id="33 垃圾收集：能否不停下整个世界？.md.html">33 垃圾收集：能否不停下整个世界？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/34%20%e8%bf%90%e8%a1%8c%e6%97%b6%e4%bc%98%e5%8c%96%ef%bc%9a%e5%8d%b3%e6%97%b6%e7%bc%96%e8%af%91%e7%9a%84%e5%8e%9f%e7%90%86%e5%92%8c%e4%bd%9c%e7%94%a8.md.html" id="34 运行时优化：即时编译的原理和作用.md.html">34 运行时优化：即时编译的原理和作用.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/35%20%e6%a1%88%e4%be%8b%e6%80%bb%e7%bb%93%e4%b8%8e%e7%83%ad%e7%82%b9%e9%97%ae%e9%a2%98%e7%ad%94%e7%96%91%ef%bc%9a%e5%90%8e%e7%ab%af%e9%83%a8%e5%88%86%e7%9c%9f%e7%9a%84%e6%af%94%e5%89%8d%e7%ab%af%e9%83%a8%e5%88%86%e9%9a%be%e5%90%97%ef%bc%9f.md.html" id="35 案例总结与热点问题答疑：后端部分真的比前端部分难吗？.md.html">35 案例总结与热点问题答疑：后端部分真的比前端部分难吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/36%20%e5%bd%93%e5%89%8d%e6%8a%80%e6%9c%af%e7%9a%84%e5%8f%91%e5%b1%95%e8%b6%8b%e5%8a%bf%e4%bb%a5%e5%8f%8a%e5%85%b6%e5%af%b9%e7%bc%96%e8%af%91%e6%8a%80%e6%9c%af%e7%9a%84%e5%bd%b1%e5%93%8d.md.html" id="36 当前技术的发展趋势以及其对编译技术的影响.md.html">36 当前技术的发展趋势以及其对编译技术的影响.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/37%20%20%e4%ba%91%e7%bc%96%e7%a8%8b%ef%bc%9a%e4%ba%91%e8%ae%a1%e7%ae%97%e4%bc%9a%e5%a6%82%e4%bd%95%e6%94%b9%e5%8f%98%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f%ef%bc%9f.md.html" id="37  云编程：云计算会如何改变编程模式？.md.html">37  云编程：云计算会如何改变编程模式？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/38%20%e5%85%83%e7%bc%96%e7%a8%8b%ef%bc%9a%e4%b8%80%e8%be%b9%e5%86%99%e7%a8%8b%e5%ba%8f%ef%bc%8c%e4%b8%80%e8%be%b9%e5%86%99%e8%af%ad%e8%a8%80.md.html" id="38 元编程：一边写程序，一边写语言.md.html">38 元编程：一边写程序，一边写语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e5%8a%a0%e9%a4%90%20%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%e7%bc%96%e7%a8%8b%e4%b8%8e%e6%a0%88%e5%b8%a7%e7%ae%a1%e7%90%86.md.html" id="加餐 汇编代码编程与栈帧管理.md.html">加餐 汇编代码编程与栈帧管理.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b%20%e5%9b%a0%e4%b8%ba%e7%83%ad%e7%88%b1%ef%bc%8c%e6%89%80%e4%bb%a5%e5%9d%9a%e6%8c%81.md.html" id="用户故事 因为热爱，所以坚持.md.html">用户故事 因为热爱，所以坚持.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%ac%ac%e4%ba%8c%e5%ad%a3%e5%9b%9e%e5%bd%92%20%e8%bf%99%e6%ac%a1%ef%bc%8c%e6%88%91%e4%bb%ac%e4%b8%80%e8%b5%b7%e5%ae%9e%e6%88%98%e8%a7%a3%e6%9e%90%e7%9c%9f%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e7%bc%96%e8%af%91%e5%99%a8.md.html" id="第二季回归 这次，我们一起实战解析真实世界的编译器.md.html">第二季回归 这次，我们一起实战解析真实世界的编译器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%bb%93%e6%9d%9f%e8%af%ad%20%e7%94%a8%e7%a8%8b%e5%ba%8f%e8%af%ad%e8%a8%80%ef%bc%8c%e6%8e%a8%e5%8a%a8%e8%bf%99%e4%b8%aa%e4%b8%96%e7%95%8c%e7%9a%84%e6%bc%94%e5%8c%96.md.html" id="结束语 用程序语言，推动这个世界的演化.md.html">结束语 用程序语言，推动这个世界的演化.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="23 生成汇编代码（二）：把脚本编译成可执行文件" id="title">23 生成汇编代码（二）：把脚本编译成可执行文件</h1>
<div><p>学完两节课之后，对于后端编译过程，你可能还会产生一些疑问，比如：</p>
<p>1.大致知道汇编程序怎么写，却不知道如何从AST生成汇编代码，中间有什么挑战。</p>
<p>2.编译成汇编代码之后需要做什么，才能生成可执行文件。</p>
<p>本节课，我会带你真正动手，基于AST把playscript翻译成正确的汇编代码，并将汇编代码编译成可执行程序。</p>
<p>通过这样一个过程，可以实现从编译器前端到后端的完整贯通，帮你对编译器后端工作建立比较清晰的认识。这样一来，你在日常工作中进行大型项目的编译管理的时候，或者需要重用别人的类库的时候，思路会更加清晰。</p>
<h2 id="从playscript生成汇编代码">从playscript生成汇编代码</h2>
<p><strong>先来看看如何从playscript生成汇编代码。</strong></p>
<p>我会带你把playscript的几个有代表性的功能，而不是全部的功能翻译成汇编代码，一来工作量少一些，二来方便做代码优化。这几个有代表性的功能如下：</p>
<p>1.支持函数调用和传参（这个功能可以回顾加餐）。</p>
<p>2.支持整数的加法运算（在这个过程中要充分利用寄存器提高性能）。</p>
<p>3.支持变量声明和初始化。</p>
<p>具体来说，要能够把下面的示例程序正确生成汇编代码：</p>
<pre><code>//asm.play
int fun1(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8){
    int c = 10; 
    return x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + c;
}

println("fun1:" + fun1(1,2,3,4,5,6,7,8));
</code></pre>
<p>在加餐中，我提供了一段手写的汇编代码，功能等价于这段playscript代码，并讲述了如何在多于6个参数的情况下传参，观察栈帧的变化过程，你可以看看下面的图片和代码，回忆一下：</p>
<p><img alt="" src="assets/7f5ba7fc911744ff9890f7ef1c6fddae.jpg"/></p>
<pre><code># function-call2-craft.s 函数调用和参数传递
    # 文本段,纯代码
    .section    __TEXT,__text,regular,pure_instructions

_fun1:
    # 函数调用的序曲,设置栈指针
    pushq   %rbp           # 把调用者的栈帧底部地址保存起来   
    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部

    movl    $10, -4(%rbp)  # 变量c赋值为10,也可以写成 movl $10, (%rsp)

    # 做加法
    movl    %edi, %eax     # 第一个参数放进%eax
    addl    %esi, %eax     # 加参数2
    addl    %edx, %eax     # 加参数3
    addl    %ecx, %eax     # 加参数4
    addl    %r8d, %eax     # 加参数5
    addl    %r9d, %eax     # 加参数6
    addl    16(%rbp), %eax  # 加参数7
    addl    24(%rbp), %eax  # 加参数8
    
    addl    -4(%rbp), %eax # 加上c的值

    # 函数调用的尾声,恢复栈指针为原来的值
    popq    %rbp           # 恢复调用者栈帧的底部数值
    retq                   # 返回

    .globl  _main          # .global伪指令让_main函数外部可见
_main:                                  ## @main
    
    # 函数调用的序曲,设置栈指针
    pushq   %rbp           # 把调用者的栈帧底部地址保存起来  
    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部
    
    subq    $16, %rsp      # 这里是为了让栈帧16字节对齐，实际使用可以更少

    # 设置参数
    movl    $1, %edi     # 参数1
    movl    $2, %esi     # 参数2
    movl    $3, %edx     # 参数3
    movl    $4, %ecx     # 参数4
    movl    $5, %r8d     # 参数5
    movl    $6, %r9d     # 参数6
    movl    $7, (%rsp)   # 参数7
    movl    $8, 8(%rsp)  # 参数8

    callq   _fun1                # 调用函数

    # 为pritf设置参数
    leaq    L_.str(%rip), %rdi   # 第一个参数是字符串的地址
    movl    %eax, %esi           # 第二个参数是前一个参数的返回值

    callq   _printf              # 调用函数

    # 设置返回值。这句也常用 xorl %esi, %esi 这样的指令,都是置为零
    movl    $0, %eax

    addq    $16, %rsp    # 缩小栈
    
    # 函数调用的尾声,恢复栈指针为原来的值
    popq    %rbp         # 恢复调用者栈帧的底部数值
    retq                 # 返回

    # 文本段,保存字符串字面量                                  
    .section    __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
    .asciz  "fun1 :%d \n"
</code></pre>
<p>接下来，我们动手写程序，从AST翻译成汇编代码（相关代码在playscript-java项目的<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java" target="_blank">AsmGen.java</a>类里）。</p>
<p><strong>我们实现加法运算的翻译过程如下：</strong></p>
<pre><code>case PlayScriptParser.ADD:
    //为加法运算申请一个临时的存储位置，可以是寄存器和栈
    address = allocForExpression(ctx);
    bodyAsm.append("\tmovl\t").append(left).append(", ").append(address).append("\n");  //把左边节点拷贝到存储空间
    bodyAsm.append("\taddl\t").append(right).append(", ").append(address).append("\n");  //把右边节点加上去
    break;
</code></pre>
<p><strong>这段代码的含义是：</strong>我们通过allocForExpression()方法，为每次加法运算申请一个临时空间（可以是寄存器，也可以是栈里的一个地址），用来存放加法操作的结果。接着，用mov指令把加号左边的值拷贝到这个临时空间，再用add指令加上右边的值。</p>
<p>生成汇编代码的过程，基本上就是基于AST拼接字符串，其中bodyAsm变量是一个StringBuffer对象，我们可以用StringBuffer的toString()方法获得最后的汇编代码。</p>
<p>按照上面的逻辑，针对“x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + c”这个表达式，形成的汇编代码如下：</p>
<pre><code> # 过程体
    movl    $10, -4(%rbp)
    movl    %edi, %eax       //x1
    addl    %esi, %eax       //+x2
    movl    %eax, %ebx    
    addl    %edx, %ebx       //+x3
    movl    %ebx, %r10d
    addl    %ecx, %r10d      //+x4
    movl    %r10d, %r11d 
    addl    %r8d, %r11d      //+x5
    movl    %r11d, %r12d
    addl    %r9d, %r12d      //+x6
    movl    %r12d, %r13d
    addl    16(%rbp), %r13d  //+x7
    movl    %r13d, %r14d
    addl    24(%rbp), %r14d  //+x8
    movl    %r14d, %r15d
    addl    -4(%rbp), %r15d  //+c，本地变量
</code></pre>
<p><strong>看出这个代码有什么问题了吗？</strong>我们每次执行加法运算的时候，都要占用一个新的寄存器。比如，x1+x2使用了%eax，再加x3时使用了%ebx，按照这样的速度，寄存器很快就用完了，使用效率显然不高。所以必须要做代码优化。</p>
<p>如果只是简单机械地翻译代码，相当于产生了大量的临时变量，每个临时变量都占用了空间：</p>
<pre><code>t1 := x1 + x2;
t2 := t1 + x3;
t3 := t2 + x4;
...
</code></pre>
<p><strong>进行代码优化</strong>可以让不再使用的存储位置（t1，t2，t3…）能够复用，从而减少临时变量，也减少代码行数，<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java#L164" target="_blank">优化后的申请临时存储空间的方法</a>如下：</p>
<pre><code>//复用前序表达式的存储位置
if (ctx.bop != null &amp;&amp; ctx.expression().size() &gt;= 2) {
    ExpressionContext left = ctx.expression(0);
    String leftAddress = tempVars.get(left);
    if (leftAddress!= null){
        tempVars.put(ctx, leftAddress); //当前节点也跟这个地址关联起来
        return leftAddress;
    }
}
</code></pre>
<p><strong>这段代码的意思是：</strong>对于每次加法运算，都要申请一个寄存器，如果加号左边的节点已经在某个寄存器中，那就直接复用这个寄存器，就不要用新的了。</p>
<p><strong>调整以后，生成的汇编代码就跟手写的一样了。</strong>而且，我们至始至终只用了%eax一个寄存器，代码数量也减少了一半，优化效果明显：</p>
<pre><code># 过程体
    movl    $10, -4(%rbp)
    movl    %edi, %eax
    addl    %esi, %eax
    addl    %edx, %eax
    addl    %ecx, %eax
    addl    %r8d, %eax
    addl    %r9d, %eax
    addl    16(%rbp), %eax
    addl    24(%rbp), %eax
    addl    -4(%rbp), %eax

    # 返回值
    # 返回值在之前的计算中,已经存入%eax
</code></pre>
<p><strong>对代码如何使用寄存器进行充分优化，是编译器后端一项必须要做的工作。</strong>这里只用了很粗糙的方法，不具备实用价值，后面可以学习更好的优化算法。</p>
<p>弄清楚了加法运算的代码翻译逻辑，我们再看看AsmGen.java中的<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java#L71" target="_blank">generate()</a>方法和<a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java#L107" target="_blank">generateProcedure()</a>方法，看看汇编代码完整的生成逻辑是怎样的。这样可以帮助你弄清楚整体脉络和所有的细节，比如函数的标签是怎么生成的，序曲和尾声是怎么加上去的，本地变量的地址是如何计算的，等等。</p>
<pre><code>public String generate() {
    StringBuffer sb = new StringBuffer();

    // 1.代码段的头
    sb.append("\t.section	__TEXT,__text,regular,pure_instructions\n");

    // 2.生成函数的代码
    for (Type type : at.types) {
        if (type instanceof Function) {
            Function function = (Function) type;
            FunctionDeclarationContext fdc = (FunctionDeclarationContext) function.ctx;
            visitFunctionDeclaration(fdc); // 遍历，代码生成到bodyAsm中了
            generateProcedure(function.name, sb);
        }
    }

    // 3.对主程序生成_main函数
    visitProg((ProgContext) at.ast);
    generateProcedure("main", sb);

    // 4.文本字面量
    sb.append("\n# 字符串字面量\n");
    sb.append("\t.section	__TEXT,__cstring,cstring_literals\n");
    for(int i = 0; i&lt; stringLiterals.size(); i++){
        sb.append("L.str." + i + ":\n");
        sb.append("\t.asciz\t\"").append(stringLiterals.get(i)).append("\"\n");
    }

    // 5.重置全局的一些临时变量
    stringLiterals.clear();
    
    return sb.toString();
}
</code></pre>
<p><strong>generate()方法是整个翻译程序的入口，它做了几项工作:</strong></p>
<p>1.生成一个.section伪指令，表明这是一个放文本的代码段。</p>
<p>2.遍历AST中的所有函数，调用generateProcedure()方法为每个函数生成一段汇编代码，再接着生成一个主程序的入口。</p>
<p>3.在一个新的section中，声明一些全局的常量（字面量）。整个程序的结构跟最后生成的汇编代码的结构是一致的，所以很容易看懂。</p>
<p><strong>generateProcedure()方法把函数转换成汇编代码，里面的注释也很清晰，开头的工作包括：</strong></p>
<p>1.生成函数标签、序曲部分的代码、设置栈顶指针、保护寄存器原有的值等。</p>
<p>2.接着是函数体，比如本地变量初始化、做加法运算等。</p>
<p>3.最后是一系列收尾工作，包括恢复被保护的寄存器的值、恢复栈顶指针，以及尾声部分的代码。</p>
<p>我们之前已经理解了一个函数体中的汇编代码的结构，所以看这段翻译代码肯定不费事儿。</p>
<pre><code>private void generateProcedure(String name, StringBuffer sb) {
    // 1.函数标签
    sb.append("\n## 过程:").append(name).append("\n");
    sb.append("\t.globl _").append(name).append("\n");
    sb.append("_").append(name).append(":\n");

    // 2.序曲
    sb.append("\n\t# 序曲\n");
    sb.append("\tpushq\t%rbp\n");
    sb.append("\tmovq\t%rsp, %rbp\n");

    // 3.设置栈顶
    // 16字节对齐
    if ((rspOffset % 16) != 0) {
        rspOffset = (rspOffset / 16 + 1) * 16;
    }
    sb.append("\n\t# 设置栈顶\n");
    sb.append("\tsubq\t$").append(rspOffset).append(", %rsp\n");

    // 4.保存用到的寄存器的值
    saveRegisters();

    // 5.函数体
    sb.append("\n\t# 过程体\n");
    sb.append(bodyAsm);

    // 6.恢复受保护的寄存器的值
    restoreRegisters();

    // 7.恢复栈顶
    sb.append("\n\t# 恢复栈顶\n");
    sb.append("\taddq\t$").append(rspOffset).append(", %rsp\n");

    // 8.如果是main函数，设置返回值为0
    if (name.equals("main")) {
        sb.append("\n\t# 返回值\n");
        sb.append("\txorl\t%eax, %eax\n");
    }

    // 9.尾声
    sb.append("\n\t# 尾声\n");
    sb.append("\tpopq\t%rbp\n");
    sb.append("\tretq\n");

    // 10.重置临时变量
    rspOffset = 0;
    localVars.clear();
    tempVars.clear();
    bodyAsm = new StringBuffer();
}
</code></pre>
<p>最后，你可以通过-S参数运行playscript-java，将asm.play文件生成汇编代码文件asm.s，再生成和运行可执行文件：</p>
<pre><code>java play.PlayScript -S asm.play -o asm.s   //生成汇编代码
gcc asm.s -o asm                            //生成可执行文件
./asm                                       //运行可执行文件
</code></pre>
<p>另外，我们的翻译程序只实现了少量的特性（加法运算、本地变量、函数……）。我建议基于这个代码框架做修改，增加其他特性，比如减法、乘法和除法，支持浮点数，支持if语句和循环语句等。学过加餐之后，你应该清楚如何生成这样的汇编代码了。</p>
<p>到目前为止，我们已经成功地编译playscript程序，并生成了可执行文件！为了加深你对生成可执行文件的理解，我们再做个挑战，用playscript生成目标文件，让C语言来调用。这样可以证明playscript生成汇编代码的逻辑是靠谱的，以至于可以用playscript代替C语言来写一个共用模块。</p>
<h2 id="通过c语言调用playscript模块">通过C语言调用playscript模块</h2>
<p>我们在编程的时候，经常调用一些公共的库实现一些功能，这些库可能是别的语言写的，但我们仍然可以调用。我们也可以实现playscript与其他语言的功能共享，在示例程序中实现很简单，微调一下生成的汇编代码，使用“.global _fun1”伪指令让_fun1过程变成全局的，这样其他语言写的程序就可以调用这个_fun1过程，实现功能的重用。</p>
<pre><code># convention-fun1.s 测试调用约定，_fun1将在外部被调用
    # 文本段,纯代码
    .section    __TEXT,__text,regular,pure_instructions
    
    .globl  _fun1          # .global伪指令让_fun1函数外部可见
_fun1:
    # 函数调用的序曲,设置栈指针
    pushq   %rbp           # 把调用者的栈帧底部地址保存起来   
    movq    %rsp, %rbp     # 把调用者的栈帧顶部地址,设置为本栈帧的底部

    movl    $10, -4(%rbp)  # 变量c赋值为10,也可以写成 movl $10, (%rsp)

    # 做加法
    movl    %edi, %eax     # 第一个参数放进%eax
    addl    %esi, %eax     # 加参数2
    addl    %edx, %eax     # 加参数3
    addl    %ecx, %eax     # 加参数4
    addl    %r8d, %eax     # 加参数5
    addl    %r9d, %eax     # 加参数6
    addl    16(%rbp), %eax  # 加参数7
    addl    24(%rbp), %eax  # 加参数8
    
    addl    -4(%rbp), %eax # 加上c的值

    # 函数调用的尾声,恢复栈指针为原来的值
    popq    %rbp           # 恢复调用者栈帧的底部数值
    retq                   # 返回
</code></pre>
<p>接下来再写一个C语言的函数来调用fun1()，其中的extern关键字，说明有一个fun1()函数是在另一个模块里实现的：</p>
<pre><code>/**
 * convention-main.c 测试调用约定。调用一个外部函数fun1
 */
#include &lt;stdio.h&gt;

//声明一个外部函数，在链接时会在其他模块中找到
extern int fun1(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8);

int main(int argc, char *argv[])
{
    printf("fun1: %d \n", fun1(1,2,3,4,5,6,7,8));
    return 0;
}
</code></pre>
<p>然后在命令行敲下面两个命令：</p>
<pre><code># 编译汇编程序
as convention-fun1.s -o convention-fun1.o

# 编译C程序
gcc convention-main.c convention-fun1.o -o convention
</code></pre>
<ul>
<li><p>第一个命令，把playscript生成的汇编代码编译成一个二进制目标文件。</p></li>
<li><p>第二个命令在编译C程序的时候，同时也带上这个二进制文件，那么编译器就会找到fun1()函数的定义，并链接到一起。-
最后生成的可执行文件能够顺利运行。</p></li>
</ul>
<p><strong>这里面，我需要解释一下链接过程，</strong>它有助于你在二进制文件层面上加深对编译过程的理解。</p>
<p>其实，高级语言和汇编语言都容易阅读。而二进制文件，则是对计算机友好的，便于运行。汇编器可以把每一个汇编文件都编译生成一个二进制的目标文件，或者叫做一个模块。而链接器则把这些模块组装成一个整体。</p>
<p>但在C语言生成的那个模块中，调用fun1()函数时，它没有办法知道fun1()函数的准确地址，因为这个地址必须是整个文件都组装完毕以后才能计算出来。所以，汇编器把这个任务推迟，交给链接器去解决。</p>
<p><img alt="" src="assets/4344a0e6896a45c69d2701ee851acb6f.jpg"/></p>
<p><strong>这就好比你去饭店排队吃饭，首先要拿个号（函数的标签），但不知道具体坐哪桌。等叫到你的号的时候（链接过程），服务员才会给你安排一个确定的桌子（函数的地址）。</strong></p>
<p>既然我们已经从文本世界进入了二进制的世界，那么我们可以再加深一下对可执行文件结构的理解。</p>
<h2 id="理解可执行文件">理解可执行文件</h2>
<p>我们编译一个程序，最后的结果是生成可运行的二进制文件。其实，生成汇编代码以后，我们就可以认为编译器的任务完成了。后面的工作，其实是由汇编器和链接器完成的。但我们也可以把整个过程都看做编译过程，了解二进制文件的结构，也为我们完整地了解整个编译过程划上了句号。</p>
<p>当然了，对二进制文件格式的理解，也是做<strong>大型项目编译管理、二进制代码分析等工作的基础，</strong>很有意义。</p>
<p>对于每个操作系统，我们对于可执行程序的格式要求是不一样的。比如，在Linux下，目标文件、共享对象文件、二进制文件，都是采用ELF格式。</p>
<p>实际上，这些二进制文件的格式跟加载到内存中的程序的格式是很相似的。这样有什么好处呢？它可以迅速被操作系统读取，并加载到内存中去，加载速度越快，也就相当于程序的启动速度越快。</p>
<p>同内存中的布局一样，在ELF格式中，代码和数据也是分开的。这样做的好处是，程序的代码部分，可以在多个进程中共享，不需要在内存里放多份。放一份，然后映射到每个进程的代码区就行了。而数据部分，则是每个进程都不一样的，所以要为每个进程加载一份。</p>
<p>这样讲的话，<strong>你就理解了可执行文件、目标文件等二进制文件的原理了，</strong>具体的细节，可以查阅相关的文档和手册。</p>
<h2 id="课程小结">课程小结</h2>
<p>这节课，我们实现了从AST到汇编代码，汇编代码到可执行文件的完整过程。现在，你应该对后端工作的实质建立起了直接的认识。我建议你抓住几个关键点：</p>
<p>首先，从AST生成汇编代码，可以通过比较机械的翻译来完成，我们举了加法运算的例子。阅读示例程序，你也可以看看函数调用、参数传递等等的实现过程。总体来说，这个过程并不难。</p>
<p>第二，这种机械地翻译生成的代码，一定是不够优化的。我们已经看到了加法运算不够优化的情况，所以一定要增加一个优化的过程。</p>
<p>第三，在生成汇编的过程中，最需要注意的就是要遵守调用约定。这就需要了解调用约定的很多细节。只要遵守调用约定，不同语言生成的二进制目标文件也可以链接在一起，形成最后的可执行文件。</p>
<p>现在我已经带你完成了编译器后端的第一轮认知迭代，并且直接操刀汇编代码，破除你对汇编的恐惧心。在之后的课程中，我们会进入第二轮迭代：中间代码和代码优化。</p>
<h2 id="一课一思">一课一思</h2>
<p>我们针对加法计算、函数调用等语法生成了汇编代码。你能否思考一下，如果要支持其他运算和语法，比如乘法运算、条件判断、循环语句等，大概会怎样实现？如果要支持面向对象编程，又该怎样实现呢？欢迎你打开思路，在留言区分享自己的想法。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>
<p>示例代码我放在文末，供你参考。</p>
<ul>
<li>AsmGen.java（将AST翻译成汇编代码） <a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java" target="_blank">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/main/play/AsmGen.java" target="_blank">GitHub</a></li>
<li>asm.play（用于生成汇编码的playscript脚本） <a href="https://gitee.com/richard-gong/PlayWithCompiler/blob/master/playscript-java/src/examples/asm.play" target="_blank">码云</a> <a href="https://github.com/RichardGong/PlayWithCompiler/blob/master/playscript-java/src/examples/asm.play" target="_blank">GitHub</a></li>
</ul>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#3b575757020f0a0a0b0c7b5c565a525715585456" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93583785589e57c6',t:'MTc0NTUyNTE0MS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
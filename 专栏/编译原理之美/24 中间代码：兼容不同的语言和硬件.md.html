<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="24 中间代码：兼容不同的语言和硬件" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>24 中间代码：兼容不同的语言和硬件 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%a0%e8%a6%81%e5%ad%a6%e4%b9%a0%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%ef%bc%9f.md.html" id="00 开篇词 为什么你要学习编译原理？.md.html">00 开篇词 为什么你要学习编译原理？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/01%20%e7%90%86%e8%a7%a3%e4%bb%a3%e7%a0%81%ef%bc%9a%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af.md.html" id="01 理解代码：编译器的前端技术.md.html">01 理解代码：编译器的前端技术.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/02%20%e6%ad%a3%e5%88%99%e6%96%87%e6%b3%95%e5%92%8c%e6%9c%89%e9%99%90%e8%87%aa%e5%8a%a8%e6%9c%ba%ef%bc%9a%e7%ba%af%e6%89%8b%e5%b7%a5%e6%89%93%e9%80%a0%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8.md.html" id="02 正则文法和有限自动机：纯手工打造词法分析器.md.html">02 正则文法和有限自动机：纯手工打造词法分析器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/03%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%ba%af%e6%89%8b%e5%b7%a5%e6%89%93%e9%80%a0%e5%85%ac%e5%bc%8f%e8%ae%a1%e7%ae%97%e5%99%a8.md.html" id="03 语法分析（一）：纯手工打造公式计算器.md.html">03 语法分析（一）：纯手工打造公式计算器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/04%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e8%a7%a3%e5%86%b3%e4%ba%8c%e5%85%83%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%ad%e7%9a%84%e9%9a%be%e7%82%b9.md.html" id="04 语法分析（二）：解决二元表达式中的难点.md.html">04 语法分析（二）：解决二元表达式中的难点.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/05%20%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9a%e5%ae%9e%e7%8e%b0%e4%b8%80%e9%97%a8%e7%ae%80%e5%8d%95%e7%9a%84%e8%84%9a%e6%9c%ac%e8%af%ad%e8%a8%80.md.html" id="05 语法分析（三）：实现一门简单的脚本语言.md.html">05 语法分析（三）：实现一门简单的脚本语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/06%20%e7%bc%96%e8%af%91%e5%99%a8%e5%89%8d%e7%ab%af%e5%b7%a5%e5%85%b7%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%94%a8Antlr%e7%94%9f%e6%88%90%e8%af%8d%e6%b3%95%e3%80%81%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8.md.html" id="06 编译器前端工具（一）：用Antlr生成词法、语法分析器.md.html">06 编译器前端工具（一）：用Antlr生成词法、语法分析器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/07%20%e7%bc%96%e8%af%91%e5%99%a8%e5%89%8d%e7%ab%af%e5%b7%a5%e5%85%b7%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e7%94%a8Antlr%e9%87%8d%e6%9e%84%e8%84%9a%e6%9c%ac%e8%af%ad%e8%a8%80.md.html" id="07 编译器前端工具（二）：用Antlr重构脚本语言.md.html">07 编译器前端工具（二）：用Antlr重构脚本语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/08%20%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e7%94%9f%e5%ad%98%e6%9c%9f%ef%bc%9a%e5%ae%9e%e7%8e%b0%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e5%87%bd%e6%95%b0.md.html" id="08 作用域和生存期：实现块作用域和函数.md.html">08 作用域和生存期：实现块作用域和函数.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/09%20%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%ef%bc%9a%e5%ae%9e%e7%8e%b0%e6%95%b0%e6%8d%ae%e5%92%8c%e6%96%b9%e6%b3%95%e7%9a%84%e5%b0%81%e8%a3%85.md.html" id="09 面向对象：实现数据和方法的封装.md.html">09 面向对象：实现数据和方法的封装.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/10%20%e9%97%ad%e5%8c%85%ef%bc%9a%20%e7%90%86%e8%a7%a3%e4%ba%86%e5%8e%9f%e7%90%86%ef%bc%8c%e5%ae%83%e5%b0%b1%e4%b8%8d%e5%8f%8d%e7%9b%b4%e8%a7%89%e4%ba%86.md.html" id="10 闭包： 理解了原理，它就不反直觉了.md.html">10 闭包： 理解了原理，它就不反直觉了.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/11%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%8a%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e4%b8%80%e4%b8%aa%e5%ae%8c%e5%96%84%e7%9a%84%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f%ef%bc%9f.md.html" id="11 语义分析（上）：如何建立一个完善的类型系统？.md.html">11 语义分析（上）：如何建立一个完善的类型系统？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/12%20%e8%af%ad%e4%b9%89%e5%88%86%e6%9e%90%ef%bc%88%e4%b8%8b%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e5%81%9a%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9b%b8%e5%85%b3%e6%83%85%e5%86%b5%e7%9a%84%e5%a4%84%e7%90%86%ef%bc%9f.md.html" id="12 语义分析（下）：如何做上下文相关情况的处理？.md.html">12 语义分析（下）：如何做上下文相关情况的处理？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/13%20%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81%ef%bc%9a%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%bf%90%e8%a1%8c%e6%9c%9f%e7%9a%84%e5%8a%a8%e6%80%81%e7%89%b9%e6%80%a7.md.html" id="13 继承和多态：面向对象运行期的动态特性.md.html">13 继承和多态：面向对象运行期的动态特性.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/14%20%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af%e5%ba%94%e7%94%a8%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%8f%e6%98%8e%e5%9c%b0%e6%94%af%e6%8c%81%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%ef%bc%9f.md.html" id="14 前端技术应用（一）：如何透明地支持数据库分库分表？.md.html">14 前端技术应用（一）：如何透明地支持数据库分库分表？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/15%20%e5%89%8d%e7%ab%af%e6%8a%80%e6%9c%af%e5%ba%94%e7%94%a8%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e6%8a%a5%e8%a1%a8%e5%b7%a5%e5%85%b7%ef%bc%9f.md.html" id="15 前端技术应用（二）：如何设计一个报表工具？.md.html">15 前端技术应用（二）：如何设计一个报表工具？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/16%20NFA%e5%92%8cDFA%ef%bc%9a%e5%a6%82%e4%bd%95%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%b7%a5%e5%85%b7%ef%bc%9f.md.html" id="16 NFA和DFA：如何自己实现一个正则表达式工具？.md.html">16 NFA和DFA：如何自己实现一个正则表达式工具？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/17%20First%e5%92%8cFollow%e9%9b%86%e5%90%88%ef%bc%9a%e7%94%a8LL%e7%ae%97%e6%b3%95%e6%8e%a8%e6%bc%94%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b.md.html" id="17 First和Follow集合：用LL算法推演一个实例.md.html">17 First和Follow集合：用LL算法推演一个实例.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/18%20%e7%a7%bb%e8%bf%9b%e5%92%8c%e8%a7%84%e7%ba%a6%ef%bc%9a%e7%94%a8LR%e7%ae%97%e6%b3%95%e6%8e%a8%e6%bc%94%e4%b8%80%e4%b8%aa%e5%ae%9e%e4%be%8b.md.html" id="18 移进和规约：用LR算法推演一个实例.md.html">18 移进和规约：用LR算法推演一个实例.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/19%20%e6%a1%88%e4%be%8b%e6%80%bb%e7%bb%93%e4%b8%8e%e7%83%ad%e7%82%b9%e9%97%ae%e9%a2%98%e7%ad%94%e7%96%91%ef%bc%9a%e5%af%b9%e4%ba%8e%e5%b7%a6%e9%80%92%e5%bd%92%e7%9a%84%e8%af%ad%e6%b3%95%ef%bc%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e7%9a%84%e6%8e%a8%e5%af%bc%e4%b8%8d%e6%98%af%e5%b7%a6%e9%80%92%e5%bd%92%e7%9a%84%ef%bc%9f.md.html" id="19 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？.md.html">19 案例总结与热点问题答疑：对于左递归的语法，为什么我的推导不是左递归的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/20%20%e9%ab%98%e6%95%88%e8%bf%90%e8%a1%8c%ef%bc%9a%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e5%90%8e%e7%ab%af%e6%8a%80%e6%9c%af.md.html" id="20 高效运行：编译器的后端技术.md.html">20 高效运行：编译器的后端技术.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/21%20%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9c%ba%e5%88%b6%ef%bc%9a%e7%aa%81%e7%a0%b4%e7%8e%b0%e8%b1%a1%e7%9c%8b%e6%9c%ac%e8%b4%a8%ef%bc%8c%e9%80%8f%e8%bf%87%e8%af%ad%e6%b3%95%e7%9c%8b%e8%bf%90%e8%a1%8c%e6%97%b6.md.html" id="21 运行时机制：突破现象看本质，透过语法看运行时.md.html">21 运行时机制：突破现象看本质，透过语法看运行时.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/22%20%e7%94%9f%e6%88%90%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e6%b1%87%e7%bc%96%e8%af%ad%e8%a8%80%e5%85%b6%e5%ae%9e%e4%b8%8d%e9%9a%be%e5%ad%a6.md.html" id="22 生成汇编代码（一）：汇编语言其实不难学.md.html">22 生成汇编代码（一）：汇编语言其实不难学.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/23%20%e7%94%9f%e6%88%90%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e6%8a%8a%e8%84%9a%e6%9c%ac%e7%bc%96%e8%af%91%e6%88%90%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e4%bb%b6.md.html" id="23 生成汇编代码（二）：把脚本编译成可执行文件.md.html">23 生成汇编代码（二）：把脚本编译成可执行文件.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/24%20%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%ef%bc%9a%e5%85%bc%e5%ae%b9%e4%b8%8d%e5%90%8c%e7%9a%84%e8%af%ad%e8%a8%80%e5%92%8c%e7%a1%ac%e4%bb%b6.md.html" id="24 中间代码：兼容不同的语言和硬件.md.html">24 中间代码：兼容不同的语言和硬件.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/25%20%e5%90%8e%e7%ab%af%e6%8a%80%e6%9c%af%e7%9a%84%e9%87%8d%e7%94%a8%ef%bc%9aLLVM%e4%b8%8d%e4%bb%85%e4%bb%85%e8%ae%a9%e4%bd%a0%e9%ab%98%e6%95%88.md.html" id="25 后端技术的重用：LLVM不仅仅让你高效.md.html">25 后端技术的重用：LLVM不仅仅让你高效.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/26%20%e7%94%9f%e6%88%90IR%ef%bc%9a%e5%ae%9e%e7%8e%b0%e9%9d%99%e6%80%81%e7%bc%96%e8%af%91%e7%9a%84%e8%af%ad%e8%a8%80.md.html" id="26 生成IR：实现静态编译的语言.md.html">26 生成IR：实现静态编译的语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/27%20%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e6%af%94%e4%bb%96%e7%9a%84%e6%9b%b4%e9%ab%98%e6%95%88%ef%bc%9f.md.html" id="27 代码优化：为什么你的代码比他的更高效？.md.html">27 代码优化：为什么你的代码比他的更高效？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/28%20%e6%95%b0%e6%8d%ae%e6%b5%81%e5%88%86%e6%9e%90%ef%bc%9a%e4%bd%a0%e5%86%99%e7%9a%84%e7%a8%8b%e5%ba%8f%ef%bc%8c%e5%ae%83%e6%9b%b4%e6%87%82.md.html" id="28 数据流分析：你写的程序，它更懂.md.html">28 数据流分析：你写的程序，它更懂.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/29%20%e7%9b%ae%e6%a0%87%e4%bb%a3%e7%a0%81%e7%9a%84%e7%94%9f%e6%88%90%e5%92%8c%e4%bc%98%e5%8c%96%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%82%e5%ba%94%e5%90%84%e7%a7%8d%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%ef%bc%9f.md.html" id="29 目标代码的生成和优化（一）：如何适应各种硬件架构？.md.html">29 目标代码的生成和优化（一）：如何适应各种硬件架构？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/30%20%e7%9b%ae%e6%a0%87%e4%bb%a3%e7%a0%81%e7%9a%84%e7%94%9f%e6%88%90%e5%92%8c%e4%bc%98%e5%8c%96%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%82%e5%ba%94%e5%90%84%e7%a7%8d%e7%a1%ac%e4%bb%b6%e6%9e%b6%e6%9e%84%ef%bc%9f.md.html" id="30 目标代码的生成和优化（二）：如何适应各种硬件架构？.md.html">30 目标代码的生成和优化（二）：如何适应各种硬件架构？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/31%20%e5%86%85%e5%ad%98%e8%ae%a1%e7%ae%97%ef%bc%9a%e5%af%b9%e6%b5%b7%e9%87%8f%e6%95%b0%e6%8d%ae%e5%81%9a%e8%ae%a1%e7%ae%97%ef%bc%8c%e5%88%b0%e5%ba%95%e5%8f%af%e4%bb%a5%e6%9c%89%e5%a4%9a%e5%bf%ab%ef%bc%9f.md.html" id="31 内存计算：对海量数据做计算，到底可以有多快？.md.html">31 内存计算：对海量数据做计算，到底可以有多快？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/32%20%e5%ad%97%e8%8a%82%e7%a0%81%e7%94%9f%e6%88%90%ef%bc%9a%e4%b8%ba%e4%bb%80%e4%b9%88Spring%e6%8a%80%e6%9c%af%e5%be%88%e5%bc%ba%e5%a4%a7%ef%bc%9f.md.html" id="32 字节码生成：为什么Spring技术很强大？.md.html">32 字节码生成：为什么Spring技术很强大？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/33%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%ef%bc%9a%e8%83%bd%e5%90%a6%e4%b8%8d%e5%81%9c%e4%b8%8b%e6%95%b4%e4%b8%aa%e4%b8%96%e7%95%8c%ef%bc%9f.md.html" id="33 垃圾收集：能否不停下整个世界？.md.html">33 垃圾收集：能否不停下整个世界？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/34%20%e8%bf%90%e8%a1%8c%e6%97%b6%e4%bc%98%e5%8c%96%ef%bc%9a%e5%8d%b3%e6%97%b6%e7%bc%96%e8%af%91%e7%9a%84%e5%8e%9f%e7%90%86%e5%92%8c%e4%bd%9c%e7%94%a8.md.html" id="34 运行时优化：即时编译的原理和作用.md.html">34 运行时优化：即时编译的原理和作用.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/35%20%e6%a1%88%e4%be%8b%e6%80%bb%e7%bb%93%e4%b8%8e%e7%83%ad%e7%82%b9%e9%97%ae%e9%a2%98%e7%ad%94%e7%96%91%ef%bc%9a%e5%90%8e%e7%ab%af%e9%83%a8%e5%88%86%e7%9c%9f%e7%9a%84%e6%af%94%e5%89%8d%e7%ab%af%e9%83%a8%e5%88%86%e9%9a%be%e5%90%97%ef%bc%9f.md.html" id="35 案例总结与热点问题答疑：后端部分真的比前端部分难吗？.md.html">35 案例总结与热点问题答疑：后端部分真的比前端部分难吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/36%20%e5%bd%93%e5%89%8d%e6%8a%80%e6%9c%af%e7%9a%84%e5%8f%91%e5%b1%95%e8%b6%8b%e5%8a%bf%e4%bb%a5%e5%8f%8a%e5%85%b6%e5%af%b9%e7%bc%96%e8%af%91%e6%8a%80%e6%9c%af%e7%9a%84%e5%bd%b1%e5%93%8d.md.html" id="36 当前技术的发展趋势以及其对编译技术的影响.md.html">36 当前技术的发展趋势以及其对编译技术的影响.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/37%20%20%e4%ba%91%e7%bc%96%e7%a8%8b%ef%bc%9a%e4%ba%91%e8%ae%a1%e7%ae%97%e4%bc%9a%e5%a6%82%e4%bd%95%e6%94%b9%e5%8f%98%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f%ef%bc%9f.md.html" id="37  云编程：云计算会如何改变编程模式？.md.html">37  云编程：云计算会如何改变编程模式？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/38%20%e5%85%83%e7%bc%96%e7%a8%8b%ef%bc%9a%e4%b8%80%e8%be%b9%e5%86%99%e7%a8%8b%e5%ba%8f%ef%bc%8c%e4%b8%80%e8%be%b9%e5%86%99%e8%af%ad%e8%a8%80.md.html" id="38 元编程：一边写程序，一边写语言.md.html">38 元编程：一边写程序，一边写语言.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e5%8a%a0%e9%a4%90%20%e6%b1%87%e7%bc%96%e4%bb%a3%e7%a0%81%e7%bc%96%e7%a8%8b%e4%b8%8e%e6%a0%88%e5%b8%a7%e7%ae%a1%e7%90%86.md.html" id="加餐 汇编代码编程与栈帧管理.md.html">加餐 汇编代码编程与栈帧管理.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b%20%e5%9b%a0%e4%b8%ba%e7%83%ad%e7%88%b1%ef%bc%8c%e6%89%80%e4%bb%a5%e5%9d%9a%e6%8c%81.md.html" id="用户故事 因为热爱，所以坚持.md.html">用户故事 因为热爱，所以坚持.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%ac%ac%e4%ba%8c%e5%ad%a3%e5%9b%9e%e5%bd%92%20%e8%bf%99%e6%ac%a1%ef%bc%8c%e6%88%91%e4%bb%ac%e4%b8%80%e8%b5%b7%e5%ae%9e%e6%88%98%e8%a7%a3%e6%9e%90%e7%9c%9f%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e7%bc%96%e8%af%91%e5%99%a8.md.html" id="第二季回归 这次，我们一起实战解析真实世界的编译器.md.html">第二季回归 这次，我们一起实战解析真实世界的编译器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86%e4%b9%8b%e7%be%8e/%e7%bb%93%e6%9d%9f%e8%af%ad%20%e7%94%a8%e7%a8%8b%e5%ba%8f%e8%af%ad%e8%a8%80%ef%bc%8c%e6%8e%a8%e5%8a%a8%e8%bf%99%e4%b8%aa%e4%b8%96%e7%95%8c%e7%9a%84%e6%bc%94%e5%8c%96.md.html" id="结束语 用程序语言，推动这个世界的演化.md.html">结束语 用程序语言，推动这个世界的演化.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="24 中间代码：兼容不同的语言和硬件" id="title">24 中间代码：兼容不同的语言和硬件</h1>
<div><p>前几节课，我带你尝试不通过IR，直接生成汇编代码，这是为了帮你快速破冰，建立直觉。在这个过程中，你也遇到了一些挑战，比如：</p>
<ul>
<li><p>你要对生成的代码进行优化，才有可能更好地使用寄存器和内存，同时也能减少代码量；</p></li>
<li><p>另外，针对不同的CPU和操作系统，你需要调整生成汇编代码的逻辑。</p></li>
</ul>
<p>这些实际体验，都进一步验证了<a href="https://time.geekbang.org/column/article/145472" target="_blank">20讲</a>中，IR的作用：我们能基于IR对接不同语言的前端，也能对接不同的硬件架构，还能做很多的优化。</p>
<p>既然IR有这些作用，那你可能会问，<strong>IR都是什么样子的呢？有什么特点？如何生成IR呢？</strong></p>
<p>本节课，我就带你了解IR的特点，认识常见的三地址代码，学会如何把高级语言的代码翻译成IR。然后，我还会特别介绍LLVM的IR，以便后面使用LLVM这个工具。</p>
<p>首先，来看看IR的特征。</p>
<h2 id="介于中间的语言">介于中间的语言</h2>
<p>IR的意思是中间表达方式，它在高级语言和汇编语言的中间，这意味着，它的特征也是处于二者之间的。</p>
<p>与高级语言相比，IR丢弃了大部分高级语言的语法特征和语义特征，比如循环语句、if语句、作用域、面向对象等等，它更像高层次的汇编语言；而相比真正的汇编语言，它又不会有那么多琐碎的、与具体硬件相关的细节。</p>
<p>相信你在学习汇编语言的时候，会发现汇编语言的细节特别多。比如，你要知道很多指令的名字和用法，还要记住很多不同的寄存器。<a href="https://time.geekbang.org/column/article/147854" target="_blank">在22讲</a>，我提到，如果你想完整地掌握x86-64架构，还需要接触很多指令集，以及调用约定的细节、内存使用的细节等等（<a href="https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4" target="_blank">参见Intel的手册</a>）。</p>
<p>仅仅拿指令的数量来说，据有人统计，Intel指令的助记符有981个之多！都记住怎么可能啊。<strong>所以说，汇编语言并不难，而是麻烦。</strong></p>
<p>IR不会像x86-64汇编语言那么繁琐，但它却包含了足够的细节信息，能方便我们实现优化算法，以及生成针对目标机器的汇编代码。</p>
<p>另外，我在20讲提到，IR有很多种类（AST也是一种IR），每种IR都有不同的特点和用途，有的编译器，甚至要用到几种不同的IR。</p>
<p>我们在后端部分所讲的IR，目的是方便执行各种优化算法，并有利于生成汇编。<strong>这种IR，可以看做是一种高层次的汇编语言，主要体现在：</strong></p>
<ul>
<li>它可以使用寄存器，但寄存器的数量没有限制；</li>
<li>控制结构也跟汇编语言比较像，比如有跳转语句，分成多个程序块，用标签来标识程序块等；</li>
<li>使用相当于汇编指令的操作码。这些操作码可以一对一地翻译成汇编代码，但有时一个操作码会对应多个汇编指令。</li>
</ul>
<p>下面来看看一个典型IR：三地址代码，简称TAC。</p>
<h2 id="认识典型的ir-三地址代码-tac">认识典型的IR：三地址代码（TAC）</h2>
<p>下面是一种常见的IR的格式，它叫做三地址代码（Three Address Code, TAC），它的优点是很简洁，所以适合用来讨论算法：</p>
<pre><code>x := y op z   //二元操作
x := op y     //一元操作
</code></pre>
<p>每条三地址代码最多有三个地址，其中两个是源地址（比如第一行代码的y和z），一个是目的地址（也就是x），每条代码最多有一个操作（op）。</p>
<p>我来举几个例子，带你熟悉一下三地址代码，<strong>这样，你能掌握三地址代码的特点，从高级语言的代码转换生成三地址代码。</strong></p>
<p><strong>1.基本的算术运算：</strong></p>
<pre><code>int a, b, c, d;
a = b + c * d;
</code></pre>
<p>TAC：</p>
<pre><code>t1 := c * d
a  := b + t1
</code></pre>
<p>t1是新产生的临时变量。当源代码的表达式中包含一个以上的操作符时，就需要引入临时变量，并把原来的一条代码拆成多条代码。</p>
<p><strong>2.布尔值的计算：</strong></p>
<pre><code>int a, b;
bool x, y;
x = a * 2 &lt; b;
y = a + 3 == b;
</code></pre>
<p>TAC：</p>
<pre><code>t1 := a * 2;
x  := t1 &lt; b;
t2 := a + 3;
y  := t2 == b;
</code></pre>
<p>布尔值实际上是用整数表示的，0代表false，非0值代表true。</p>
<p><strong>3.条件语句：</strong></p>
<pre><code>int a, b c;
if (a &lt; b )
    c = b;
else
    c = a;  
c = c * 2;      
</code></pre>
<p>TAC：</p>
<pre><code>  t1 := a &lt; b;
  IfZ t1 Goto L1;
  c := a;
  Goto L2;
L1:
  c := b;
L2:
  c := c * 2;  
</code></pre>
<p>IfZ是检查后面的操作数是否是0，“Z”就是“Zero”的意思。这里使用了标签和Goto语句来进行指令的跳转（Goto相当于x86-64的汇编指令jmp）。</p>
<p><strong>4.循环语句：</strong></p>
<pre><code>int a, b;
while (a &lt; b){
  a = a + 1;
}
a = a + b;
</code></pre>
<p>TAC：</p>
<pre><code>L1:
  t1 := a &lt; b;
  IfZ t1 Goto L2;
  a := a + 1;
  Goto L1;
L2:
  a := a + b;  
</code></pre>
<p>三地址代码的规则相当简单，我们可以通过比较简单的转换规则，就能从AST生成TAC。</p>
<p>在课程中，三地址代码主要用来描述优化算法，因为它比较简洁易读，操作（指令）的类型很少，书写方式也符合我们的日常习惯。<strong>不过，我并不用它来生成汇编代码，因为它含有的细节信息还是比较少，</strong>比如，整数是16位的、32位的还是64位的？目标机器的架构和操作系统是什么？生成二进制文件的布局是怎样的等等？</p>
<p><strong>我会用LLVM的IR来承担生成汇编的任务，</strong>因为它有能力描述与目标机器（CPU、操作系统）相关的更加具体的信息，准确地生成目标代码，从而真正能够用于生产环境。</p>
<p><strong>在讲这个问题之前，我想先延伸一下，讲讲另外几种IR的格式，</strong>主要想帮你开拓思维，如果你的项目需求，恰好能用这种IR实现，到时不妨拿来用一下：</p>
<ul>
<li><p>首先是四元式。它是与三地址代码等价的另一种表达方式，格式是：（OP，arg1，arg2，result）所以，“a := b + c” 就等价于（+，b，c，a）。</p></li>
<li><p>另一种常用的格式是逆波兰表达式。它把操作符放到后面，所以也叫做后缀表达式。“b + c”对应的逆波兰表达式是“b c +”；而“a = b + c”对应的逆波兰表达式是“a b c + =”。</p></li>
</ul>
<p><strong>逆波兰表达式特别适合用栈来做计算。</strong>比如计算“b c +”，先从栈里弹出加号，知道要做加法操作，然后从栈里弹出两个操作数，执行加法运算即可。这个计算过程，跟深度优先的遍历AST是等价的。所以，采用逆波兰表达式，有可能让你用一个很简单的方式就实现公式计算功能，<strong>如果你编写带有公式功能的软件时可以考虑使用它。</strong>而且，从AST生成逆波兰表达式也非常容易。</p>
<p>三地址代码主要是学习算法的工具，或者用于实现比较简单的后端，要实现工业级的后端，充分发挥硬件的性能，你还要学习LLVM的IR。</p>
<h2 id="认识llvm汇编码">认识LLVM汇编码</h2>
<p><strong>LLVM汇编码（LLVM Assembly），是LLVM的IR。</strong>有的时候，我们就简单地称呼它为LLVM语言，因此我们可以把用LLVM汇编码书写的一个程序文件叫做LLVM程序。</p>
<p>我会在下一讲，详细讲解LLVM这个开源项目。本节课作为铺垫，告诉我们在使用LLVM之前，要先了解它的核心——IR。</p>
<p><strong>首先，LLVM汇编码是采用静态单赋值代码形式的。</strong></p>
<p>在三地址代码上再加一些限制，就能得到另一种重要的代码，即静态单赋值代码（Static Single Assignment, SSA），在静态单赋值代码中，一个变量只能被赋值一次，来看个例子。</p>
<p>“y = x1 + x2 + x3 + x4”的普通三地址代码如下：</p>
<pre><code>y := x1 + x2;
y := y + x3;
y := y + x4;
</code></pre>
<p>其中，y被赋值了三次，如果写成SSA的形式，就只能写成下面的样子：</p>
<pre><code>t1 := x1 + x2;
t2 := t1 + x3;
y  := t2 + x4; 
</code></pre>
<p>为什么要费力写成这种形式呢，还要为此多添加t1和t2两个临时变量？原因是SSA的形式，体现了精确的“使用-定义”关系。</p>
<p>每个变量很确定地只会被定义一次，然后可以多次使用。这种特点使得基于SSA更容易做数据流分析，而数据流分析又是很多代码优化技术的基础，所以，几乎所有语言的编译器、解释器或虚拟机中都使用了SSA，因为有利于做代码优化。而LLVM的IR，也是采用SSA的形式，也是因为SSA方便做代码优化。</p>
<p><strong>其次，LLVM IR比起三地址代码，有更多的细节信息。</strong>比如整型变量的字长、内存对齐方式等等，所以使用LLVM IR能够更准确地翻译成汇编码。</p>
<p>看看下面这段C语言代码：</p>
<pre><code>int fun1(int a, int b){
  int c = 10;
  return a + b + c;
}
</code></pre>
<p>对应的LLLM汇编码如下（这是我在macOS上生成的）：</p>
<pre><code>; ModuleID = 'fun1.c'
source_filename = "fun1.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx10.14.0"
; Function Attrs: noinline nounwind optnone ssp uwtable
define i32 @fun1(i32, i32) #0 {
  %3 = alloca i32, align 4        //为3个变量申请空间
  %4 = alloca i32, align 4     
  %5 = alloca i32, align 4
  store i32 %0, i32* %3, align 4  //参数1赋值给变量1
  store i32 %1, i32* %4, align 4  //参数2赋值给变量2
  store i32 10, i32* %5, align 4  //常量10赋值给变量3
  %6 = load i32, i32* %3, align 4 //
  %7 = load i32, i32* %4, align 4
  %8 = add nsw i32 %6, %7
  %9 = load i32, i32* %5, align 4
  %10 = add nsw i32 %8, %9
  ret i32 %10
}
attributes #0 = { noinline nounwind optnone ssp uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="penryn" "target-features"="+cx16,+fxsr,+mmx,+sahf,+sse,+sse2,+sse3,+sse4.1,+ssse3,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0, !1, !2}
!llvm.ident = !{!3}

!0 = !{i32 2, !"SDK Version", [2 x i32] [i32 10, i32 14]}
!1 = !{i32 1, !"wchar_size", i32 4}
!2 = !{i32 7, !"PIC Level", i32 2}
!3 = !{!"Apple LLVM version 10.0.1 (clang-1001.0.46.4)"}
</code></pre>
<p>这些代码看上去确实比三地址代码复杂，但还是比汇编精简多了，比如LLVM IR的指令数量连x86-64汇编的十分之一都不到。</p>
<p><strong>我们来熟悉一下里面的元素：</strong></p>
<ul>
<li>模块</li>
</ul>
<p>LLVM程序是由模块构成的，这个文件就是一个模块。模块里可以包括函数、全局变量和符号表中的条目。链接的时候，会把各个模块拼接到一起，形成可执行文件或库文件。</p>
<p>在模块中，你可以定义目标数据布局（target datalayout）。例如，开头的小写“e”是低字节序（Little Endian）的意思，对于超过一个字节的数据来说，低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<pre><code>target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
</code></pre>
<p>“target triple”用来定义模块的目标主机，它包括架构、厂商、操作系统三个部分。</p>
<pre><code>target triple = "x86_64-apple-macosx10.14.0"
</code></pre>
<ul>
<li>函数</li>
</ul>
<p>在示例代码中有一个以define开头的函数的声明，还带着花括号。这有点儿像C语言的写法，比汇编用采取标签来表示一个函数的可读性更好。</p>
<p>函数声明时可以带很多修饰成分，比如链接类型、调用约定等。如果不写，缺省的链接类型是external的，也就是可以像<a href="https://time.geekbang.org/column/article/150798" target="_blank">23讲</a>中做链接练习的那样，暴露出来被其他模块链接。调用约定也有很多种选择，缺省是“ccc”，也就是C语言的调用约定（C Calling Convention），而“swiftcc”则是swift语言的调用约定。<strong>这些信息都是生成汇编时所需要的。</strong></p>
<p>示例中函数fun1还带有“#0”的属性值，定义了许多属性。这些也是生成汇编时所需要的。</p>
<ul>
<li>标识符</li>
</ul>
<p>分为全局的（Glocal）和本地的（Local）：全局标识符以@开头，包括函数和全局变量，前面代码中的@fun1就是；本地标识符以%开头。</p>
<p>有的标识符是有名字的，比如@fun1或%a，有的是没有名字的，用数字表示就可以了，如%1。</p>
<ul>
<li>操作码</li>
</ul>
<p>alloca、store、load、add、ret这些，都是操作码。它们的含义是：</p>
<p><img alt="" src="assets/d32757364efd45339e106d631755aff3.jpg"/></p>
<p>它们跟我们之前学到的汇编很相似。但是似乎函数体中的代码有点儿长。怎么一个简单的“a+b+c”就翻译成了10多行代码，还用到了那么多临时变量？不要担心，<strong>这只是完全没经过优化的格式，</strong>带上优化参数稍加优化以后，它就会被精简成下面的样子：</p>
<pre><code>define i32 @fun1(i32, i32) local_unnamed_addr #0 {
  %3 = add i32 %0, 10
  %4 = add i32 %3, %1
  ret i32 %4
}
</code></pre>
<ul>
<li>类型系统</li>
</ul>
<p>汇编是无类型的。如果你用add指令，它就认为你操作的是整数。而用fadd（或addss）指令，就认为你操作的是浮点数。这样会有类型不安全的风险，把整型当浮点数用了，造成的后果是计算结果完全错误。</p>
<p>LLVM汇编则带有一个类型系统。它能避免不安全的数据操作，并且有助于优化算法。这个类型系统包括<strong>基础数据类型、函数类型和void类型。</strong></p>
<p><img alt="" src="assets/2c3ae864cf7b43e4a0e2ec429edd44bd.jpg"/></p>
<p><strong>函数类型</strong>是包括对返回值和参数的定义，比如：i32 (i32)；</p>
<p><strong>void类型</strong>不代表任何值，也没有长度。</p>
<ul>
<li>全局变量和常量</li>
</ul>
<p>在LLVM汇编中可以声明全局变量。全局变量所定义的内存，是在编译时就分配好了的，而不是在运行时，例如下面这句定义了一个全局变量C：</p>
<pre><code>@c = global i32 100, align 4
</code></pre>
<p>你也可以声明常量，它的值在运行时不会被修改：</p>
<pre><code>@c = constant i32 100, align 4
</code></pre>
<ul>
<li>元数据</li>
</ul>
<p>在代码中你还看到以“!”开头的一些句子，这些是元数据。这些元数据定义了一些额外的信息，提供给优化器和代码生成器使用。</p>
<ul>
<li>基本块</li>
</ul>
<p>函数中的代码会分成一个个的基本块，可以用标签（Label）来标记一个基本块。下面这段代码有4个基本块，其中第一个块有一个缺省的名字“entry”，也就是作为入口的基本块，这个基本块你不给它标签也可以。</p>
<pre><code>define i32 @bb(i32) #0 {
  %2 = alloca i32, align 4
  %3 = alloca i32, align 4
  store i32 %0, i32* %3, align 4
  %4 = load i32, i32* %3, align 4
  %5 = icmp sgt i32 %4, 0
  br i1 %5, label %6, label %9

; &lt;label&gt;:6:                                      ; preds = %1
  %7 = load i32, i32* %3, align 4
  %8 = mul nsw i32 %7, 2
  store i32 %8, i32* %2, align 4
  br label %12

; &lt;label&gt;:9:                                      ; preds = %1
  %10 = load i32, i32* %3, align 4
  %11 = add nsw i32 %10, 3
  store i32 %11, i32* %2, align 4
  br label %12

; &lt;label&gt;:12:                                     ; preds = %9, %6
  %13 = load i32, i32* %2, align 4
  ret i32 %13
}
</code></pre>
<p>这段代码实际上相当于下面这段C语言的代码：</p>
<pre><code>int bb(int b){
    if (b &gt; 0)
        return b * 2;
    else
        return b + 3;
}
</code></pre>
<p>每个基本块是一系列的指令。我们分析一下标签为9的基本块，<strong>让你熟悉一下基本块和LLVM指令的特点：</strong></p>
<p>第一行（%10 = load i32, i32* %3, align 4）的含义是：把3号变量（32位整型）从内存加载到寄存器，叫做10号变量，其中，内存对齐是4字节。</p>
<p><strong>我在这里延伸一下，</strong>我们在内存里存放数据的时候，有时会从2、4、8个字节的整数倍地址开始存。有些汇编指令要求必须从这样对齐的地址来取数据。另一些指令没做要求，但如果是不对齐的，比如是从0x03地址取数据，就要花费更多的时钟周期。但缺点是，内存对齐会浪费内存空间。</p>
<p>第一行是整个基本块的唯一入口，从其他基本块跳转过来的时候，只能跳转到这个入口行，不能跳转到基本块中的其他行。</p>
<p>第二行（%11 = add nsw i32 %10, 3）的含义是：把10号变量（32位整型）加上3，保存到11号变量，其中nsw是加法计算时没有符号环绕（No Signed Wrap）的意思。它的细节你可以查阅“<a href="http://llvm.org/docs/LangRef.html" target="_blank">LLVM语言参考手册</a>”。</p>
<p>第三行（store i32 %11, i32* %2, align 4）的含义是：把11号变量（32位整型）存入内存中的2号变量，内存对齐4字节。</p>
<p>第四行（br label %12）的含义是：跳转到标签为12的代码块。其中，br指令是一条终结指令。终结指令要么是跳转到另一个基本块，要么是从函数中返回（ret指令），基本块的最后一行必须是一条终结指令。</p>
<p>最后我要强调，从其他基本块不可以跳转到入口基本块，也就是函数中的第一个基本块。这个规定也是有利于做数据优化。</p>
<p>以上就是对LLVM汇编码的概要介绍（更详细的信息了解可以参见“LLVM语言参考手册”）。</p>
<p>这样，你实际上就可以用LLVM汇编码来编写程序了，或者将AST翻译成LLVM汇编码。听上去有点让人犯怵，因为LLVM汇编码的细节也相当不少，好在，LLVM提供了一个IR生成的API（应用编程接口），可以让我们更高效、更准确地生成IR。</p>
<h2 id="课程小结">课程小结</h2>
<p>IR是我们后续做代码优化、汇编代码生成的基础，在本节课中，我想让你明确的要点如下：</p>
<p>1.三地址代码是很常见的一种IR，包含一个目的地址、一个操作符和至多两个源地址。它等价于四元式。我们在27讲和28讲中的优化算法，会用三地址代码来讲解，这样比较易于阅读。</p>
<p>2.LLVM IR的第一个特点是静态单赋值（SSA），也就是每个变量（地址）最多被赋值一次，它这种特性有利于运行代码优化算法；第二个特点是带有比较多的细节，方便我们做优化和生成高质量的汇编代码。</p>
<p>通过本节课，你应该对于编译器后端中常常提到的IR建立了直观的认识，相信通过接下来的练习，你一定会消除对IR的陌生感，让它成为你得心应手的好工具！</p>
<h2 id="一课一思">一课一思</h2>
<p>我们介绍了IR的特点和几种基本的IR，在你的领域，比如人工智能领域，你了解其他的IR吗？它带来了什么好处？欢迎分享你的经验和观点。</p>
<p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的人。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#dfb3b3b3e6ebeeeeefe89fb8b2beb6b3f1bcb0b2" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'935837977c3d0801',t:'MTc0NTUyNTE0NC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
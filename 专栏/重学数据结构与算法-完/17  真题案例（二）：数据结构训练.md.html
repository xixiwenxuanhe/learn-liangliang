<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="17  真题案例（二）：数据结构训练" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>17  真题案例（二）：数据结构训练 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/00%20%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%8c%e5%ba%94%e8%af%a5%e8%bf%99%e6%a0%b7%e5%ad%a6%ef%bc%81.md.html" id="00 数据结构与算法，应该这样学！.md.html">00 数据结构与算法，应该这样学！.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/01%20%20%e5%a4%8d%e6%9d%82%e5%ba%a6%ef%bc%9a%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e7%9a%84%e6%95%88%e7%8e%87%ef%bc%9f.md.html" id="01  复杂度：如何衡量程序运行的效率？.md.html">01  复杂度：如何衡量程序运行的效率？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/02%20%20%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%e5%b0%86%e2%80%9c%e6%98%82%e8%b4%b5%e2%80%9d%e7%9a%84%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e8%bd%ac%e6%8d%a2%e6%88%90%e2%80%9c%e5%bb%89%e4%bb%b7%e2%80%9d%e7%9a%84%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6.md.html" id="02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html">02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/03%20%20%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9a%e6%8e%8c%e6%8f%a1%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c,%e4%bb%a5%e4%b8%8d%e5%8f%98%e5%ba%94%e4%b8%87%e5%8f%98.md.html" id="03  增删查：掌握数据处理的基本操作,以不变应万变.md.html">03  增删查：掌握数据处理的基本操作,以不变应万变.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/04%20%20%e5%a6%82%e4%bd%95%e5%ae%8c%e6%88%90%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%bb%93%e6%9e%84%e4%b8%8b%e7%9a%84%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="04  如何完成线性表结构下的增删查？.md.html">04  如何完成线性表结构下的增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/05%20%20%e6%a0%88%ef%bc%9a%e5%90%8e%e8%bf%9b%e5%85%88%e5%87%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e8%a1%a8%ef%bc%8c%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="05  栈：后进先出的线性表，如何实现增删查？.md.html">05  栈：后进先出的线性表，如何实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/06%20%20%e9%98%9f%e5%88%97%ef%bc%9a%e5%85%88%e8%bf%9b%e5%85%88%e5%87%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e8%a1%a8%ef%bc%8c%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="06  队列：先进先出的线性表，如何实现增删查？.md.html">06  队列：先进先出的线性表，如何实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/07%20%20%e6%95%b0%e7%bb%84%ef%bc%9a%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%9f%ba%e4%ba%8e%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9f%a5%e6%89%be%ef%bc%9f.md.html" id="07  数组：如何实现基于索引的查找？.md.html">07  数组：如何实现基于索引的查找？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/08%20%20%e5%ad%97%e7%ac%a6%e4%b8%b2%ef%bc%9a%e5%a6%82%e4%bd%95%e6%ad%a3%e7%a1%ae%e5%9b%9e%e7%ad%94%e9%9d%a2%e8%af%95%e4%b8%ad%e9%ab%98%e9%a2%91%e8%80%83%e5%af%9f%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95%ef%bc%9f.md.html" id="08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html">08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/09%20%20%e6%a0%91%e5%92%8c%e4%ba%8c%e5%8f%89%e6%a0%91%ef%bc%9a%e5%88%86%e6%94%af%e5%85%b3%e7%b3%bb%e4%b8%8e%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e4%b8%8b%ef%bc%8c%e5%a6%82%e4%bd%95%e6%9c%89%e6%95%88%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html">09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/10%20%20%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e5%a5%bd%e9%ab%98%e6%95%88%e7%8e%87%e6%9f%a5%e6%89%be%e7%9a%84%e2%80%9c%e5%88%a9%e5%99%a8%e2%80%9d%ef%bc%9f.md.html" id="10  哈希表：如何利用好高效率查找的“利器”？.md.html">10  哈希表：如何利用好高效率查找的“利器”？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/11%20%20%e9%80%92%e5%bd%92%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e9%80%92%e5%bd%92%e6%b1%82%e8%a7%a3%e6%b1%89%e8%af%ba%e5%a1%94%e9%97%ae%e9%a2%98%ef%bc%9f.md.html" id="11  递归：如何利用递归求解汉诺塔问题？.md.html">11  递归：如何利用递归求解汉诺塔问题？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/12%20%20%e5%88%86%e6%b2%bb%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e5%88%86%e6%b2%bb%e6%b3%95%e5%ae%8c%e6%88%90%e6%95%b0%e6%8d%ae%e6%9f%a5%e6%89%be%ef%bc%9f.md.html" id="12  分治：如何利用分治法完成数据查找？.md.html">12  分治：如何利用分治法完成数据查找？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/13%20%20%e6%8e%92%e5%ba%8f%ef%bc%9a%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90%e4%b8%8e%e4%bc%98%e5%8a%a3%e5%af%b9%e6%af%94.md.html" id="13  排序：经典排序算法原理解析与优劣对比.md.html">13  排序：经典排序算法原理解析与优劣对比.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/14%20%20%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e6%9c%80%e4%bc%98%e5%ad%90%e7%bb%93%e6%9e%84%ef%bc%8c%e5%ae%8c%e6%88%90%e5%a4%8d%e6%9d%82%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3%ef%bc%9f.md.html" id="14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html">14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/15%20%20%e5%ae%9a%e4%bd%8d%e9%97%ae%e9%a2%98%e6%89%8d%e8%83%bd%e6%9b%b4%e5%a5%bd%e5%9c%b0%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98%ef%bc%9a%e5%bc%80%e5%8f%91%e5%89%8d%e7%9a%84%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90%e4%b8%8e%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b.md.html" id="15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html">15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/16%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%ae%97%e6%b3%95%e6%80%9d%e7%bb%b4%e8%ae%ad%e7%bb%83.md.html" id="16  真题案例（一）：算法思维训练.md.html">16  真题案例（一）：算法思维训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/17%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%ae%ad%e7%bb%83.md.html" id="17  真题案例（二）：数据结构训练.md.html">17  真题案例（二）：数据结构训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/18%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9a%e5%8a%9b%e6%89%a3%e7%9c%9f%e9%a2%98%e8%ae%ad%e7%bb%83.md.html" id="18  真题案例（三）：力扣真题训练.md.html">18  真题案例（三）：力扣真题训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/19%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9a%e5%a4%a7%e5%8e%82%e7%9c%9f%e9%a2%98%e5%ae%9e%e6%88%98%e6%bc%94%e7%bb%83.md.html" id="19  真题案例（四）：大厂真题实战演练.md.html">19  真题案例（四）：大厂真题实战演练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/20%20%20%e4%bb%a3%e7%a0%81%e4%b9%8b%e5%a4%96%ef%bc%8c%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e4%b8%ad%e4%bd%a0%e5%ba%94%e8%af%a5%e5%85%b7%e5%a4%87%e5%93%aa%e4%ba%9b%e8%bd%af%e7%b4%a0%e8%b4%a8%ef%bc%9f.md.html" id="20  代码之外，技术面试中你应该具备哪些软素质？.md.html">20  代码之外，技术面试中你应该具备哪些软素质？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/21%20%20%e9%9d%a2%e8%af%95%e4%b8%ad%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e5%85%a8%e5%b1%80%e8%a7%82%ef%bc%8c%e5%bf%ab%e9%80%9f%e5%ae%8c%e6%88%90%e4%bc%98%e8%b4%a8%e7%9a%84%e6%89%8b%e5%86%99%e4%bb%a3%e7%a0%81%ef%bc%9f.md.html" id="21  面试中如何建立全局观，快速完成优质的手写代码？.md.html">21  面试中如何建立全局观，快速完成优质的手写代码？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/%e5%8a%a0%e9%a4%90%20%20%e8%af%be%e5%90%8e%e7%bb%83%e4%b9%a0%e9%a2%98%e8%af%a6%e8%a7%a3.md.html" id="加餐  课后练习题详解.md.html">加餐  课后练习题详解.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="17  真题案例（二）：数据结构训练" id="title">17  真题案例（二）：数据结构训练</h1>
<div><p>在前面课时中，我们已经学习了解决代码问题的方法论。宏观上，它可以分为以下 4 个步骤：</p>
<ol>
<li><strong>复杂度分析</strong>。估算问题中复杂度的上限和下限。</li>
<li><strong>定位问题</strong>。根据问题类型，确定采用何种算法思维。</li>
<li><strong>数据操作分析</strong>。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。</li>
<li><strong>编码实现</strong>。</li>
</ol>
<p>这套方法论的框架，是解决绝大多数代码问题的基本步骤。其中第 3 步，数据操作分析是数据结构发挥价值的地方。本课时，我们将继续通过经典真题案例进行数据结构训练。</p>
<h3 id="数据结构训练题">数据结构训练题</h3>
<h4 id="例题-1-反转字符串中的单词">例题 1：反转字符串中的单词</h4>
<p><strong>【题目】</strong> 给定一个字符串，逐个翻转字符串中的每个单词。例如，输入：”This is a good example”，输出：”example good a is This”。如果有多余的空格需要删除。</p>
<p><strong>【解析】</strong> 在本课时开头，我们复习了解决代码问题的方法论，下面我们按照解题步骤进行详细分析。</p>
<p><strong>首先分析一下复杂度</strong>。这里的动作可以分为拆模块和做翻转两部分。在采用比较暴力的方法时，拆模块使用一个 for 循环，做翻转也使用一个 for 循环。这样双重循环的嵌套，就是 O(n²) 的复杂度。</p>
<p><strong>接下来定位问题</strong>。我们可以看到它对数据的顺序非常敏感，敏感点一是每个单词需要保证顺序；敏感点二是所有单词放在一起的顺序需要调整为逆序。我们曾学过的关于数据顺序敏感的结构有队列和栈，也许这些结构可以适用在这个问题中。此处需要逆序，栈是有非常大的可能性被使用到的。</p>
<p><strong>然后我们进行数据操作分析</strong>。如果要使用栈的话，从结果出发，就需要按照顺序，把 This、is、a、good、example 分别入栈。要想把它们正确地入栈，就需要根据空格来拆分原始字符串。</p>
<p><strong>因此，经过分析后，这个例子的解法为：用空格把句子分割成单词。如果发现了多余的连续空格，需要做一些删除的额外处理。一边得到单词，一边把单词放入栈中。直到最后，再把单词从栈中倒出来，形成结果字符串</strong>。</p>
<p><img alt="1.gif" src="assets/Ciqc1F8MP8yAS72oABGrGx_blwA588.gif"/></p>
<p><strong>最后，我们按照上面的思路进行编码开发</strong>。代码如下：</p>
<pre><code>public static void main(String[] args) {
    String ss = "This is a   good example";
    System.out.println(reverseWords(ss));
}
private static String reverseWords(String s) {
    Stack stack=new Stack();
    String temp = "";
    for (int i = 0; i &lt; s.length(); i++) {
        if (s.charAt(i) != ' ') {
            temp += s.charAt(i);
        }
        else if (temp != ""){
            stack.push(temp);
            temp = "";
        }
        else{
            continue;
        }
    }
    if (temp != ""){
        stack.push(temp);
    }
    String result = "";
    while (!stack.empty()){
        result += stack.pop() + " ";
    }
    return result.substring(0,result.length()-1);
}
</code></pre>
<p><strong>下面我们对代码进行解读。</strong> 主函数中，第 1～4 行，不用过多赘述。第 7 行定义了一个栈，第 8 行定义了一个缓存字符串的变量。</p>
<p>接着，在第 9～20 行进入 for 循环。对每个字符分别进行如下判断：</p>
<ul>
<li>如果字符不是空格，当前单词还没有结束，则放在 temp 变量后面；</li>
<li>如果字符是空格（10～12 行），说明当前单词结束了；</li>
<li>如果 temp 变量不为空（13～16 行），则入栈；</li>
<li>如果字符是空格，但 temp 变量是空的，就说明虽然单词结束了（17～19 行），但当前并没有得到新的单词。也就是连续出现了多个空格的情况。此时用 continue 语句忽略。</li>
</ul>
<p>然后，再通过 21～23 行，把最后面的一个单词（它可能没有最后的空格帮助切分）放到栈内。此时所有的单词都完成了入栈。</p>
<p>最后，在 24～28 行，让栈内的字符串先后出栈，并用空格隔离开放在 result 字符串内。最后返回 result 变量。别忘了，最后一次执行 pop 语句时，多给了 result 一个空格，需要将它删除掉。这样就完成了这个问题。</p>
<p><strong>这段代码采用了一层的 for 循环，显然它的时间复杂度是 O(n)。相比较于比较暴力的解法，它之所以降低了时间复杂度，就在于它开辟了栈的存储空间。所以空间复杂度也是 O(n)</strong>。</p>
<h4 id="例题-2-树的层序遍历">例题 2：树的层序遍历</h4>
<p><strong>【题目】</strong> 给定一棵树，按照层次顺序遍历并打印这棵树。例如，输入的树为：</p>
<p><img alt="3.png" src="assets/CgqCHl8MP_WAERuIAACStyOKMQk754.png"/></p>
<p>则打印 16、13、20、10、15、22、21、26。格外需要注意的是，这并不是前序遍历。</p>
<p><strong>【解析】</strong> 如果你一直在学习这门课的话，一定对这道题目似曾相识。它是我们在 09 课时中留下的练习题。同时它也是高频面试题。仔细分析下这个问题，不难发现它是一个关于树的遍历问题。理论上是可以在 O(n) 时间复杂度下完成访问的。</p>
<p>以往我们学过的遍历方式有前序、中序和后序遍历，它们的实现方法都是通过递归。以前序遍历为例，递归可以理解为，先解决根结点，再解决左子树一边的问题，最后解决右子树的问题。这很像是在用深度优先的原则去遍历一棵树。</p>
<p>现在我们的问题要求是按照层次遍历，这就跟上面的深度优先的原则完全不一样了，更像是广度优先。也就是说，从遍历的顺序来看，一会在左子树、一会在右子树，会来回跳转。显然，这是不能用递归来处理的。</p>
<p>那么我们该如何解决呢？</p>
<p>我们从结果来看看这个问题有什么特点。打印的结果是 16、13、20、10、15、22、21、26。</p>
<p>从后往前看，可以发现：打印 21 和 26 之前，会先打印 22。这是一棵树的上下级关系；打印 10 和 15 之前，会先打印 13，这也是一棵树的上下级关系。显然，结果对上下级关系的顺序非常敏感。</p>
<p>接着，我们发现 13 和 10、15 之间的打印关系并不连续，夹杂着右边的结点 20。也就是说，左边的优先级大于右边大于下边。</p>
<p>分析到这里，你应该能找到一些感觉了吧。一个结果序列对顺序敏感，而且没有逆序的操作，满足这些特点的数据结构只有队列。所以我们猜测这个问题的解决方案，极有可能要用到队列。</p>
<p>队列只有入队列和出队列的操作。如果输出结果就是出队列的顺序，那这个顺序必然也是入队列的顺序，原因就在于队列的出入原则是先进先出。而入队列的原则是，上层父节点先进，左孩子再进，右孩子最后进。</p>
<p><strong>因此，这道题目的解决方案就是，根结点入队列，随后循环执行结点出队列并打印结果，左孩子入队列，右孩子入队列。直到队列为空</strong>。如下图所示：</p>
<p><img alt="2.gif" src="assets/CgqCHl8MQA2AWELaAA_8m3_f-_Q592.gif"/></p>
<p>这个例子的代码如下：</p>
<pre><code>public static void levelTraverse(Node root) {
	LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
	Node current = null;
	queue.offer(root); // 根结点入队	
	while (!queue.isEmpty()) {
		current = queue.poll(); // 出队队头元素
		System.out.print(current.data);
		// 左子树不为空，入队
		if (current.leftChild != null)
			queue.offer(current.leftChild);
		// 右子树不为空，入队
		if (current.rightChild != null)
			queue.offer(current.rightChild);
	}
}
</code></pre>
<p><strong>下面我们对代码进行解读</strong>。在这段代码中，第 2 行首先定义了一个队列 queue，并在第 4 行让根结点入队列，此时队列不为空。</p>
<p>接着进入一个 while 循环进行遍历。当队列不为空的时候，第 6 行首先执行出队列操作，并把结果存在 current 变量中。随后第 7 行打印 current 的数值。如果 current 还有左孩子或右孩子，则分别按顺序执行入队列的操作，这是在第 9～13 行。</p>
<p>经过这段代码，可以完成的是，所有顺序都按照层次顺序入队列，且左孩子优先。这样就得到了按行打印的结果。时间复杂度是 O(n)。空间复杂度由于定义了 queue 变量，因此也是 O(n)。</p>
<h4 id="例题-3-查找数据流中的中位数">例题 3：查找数据流中的中位数</h4>
<p><strong>【题目】</strong> 在一个流式数据中，查找中位数。如果是偶数个，则返回偏左边的那个元素。</p>
<p>例如：</p>
<p>输入 1，服务端收到 1，返回 1。</p>
<p>输入 2，服务端收到 1、2，返回 1。</p>
<p>输入 0，服务端收到 0、1、2，返回 1。</p>
<p>输入 20，服务端收到 0、1、2、20，返回 1。</p>
<p>输入 10，服务端收到 0、1、2、10、20，返回 2。</p>
<p>输入 22，服务端收到 0、1、2、10、20、22，返回 2。</p>
<p><strong>【解析】</strong> 这道题目依旧是按照解决代码问题的方法论的步骤进行分析。</p>
<p><strong>先看一下复杂度</strong>。显然，这里的问题定位就是个查找问题。对于累积的客户端输入，查找其中位数。中位数的定义是，一组数字按照从小到大排列后，位于中间位置的那个数字。</p>
<p>根据这个定义，最简单粗暴的做法，就是对服务端收到的数据进行排序得到有序数组，再通过 index 直接取出数组的中位数。排序选择快排的时间复杂度是 O(nlogn)。</p>
<p><strong>接下来分析一下这个查找问题</strong>。该问题有一个非常重要的特点，我们注意到，上一轮已经得到了有序的数组，那么这一轮该如何巧妙利用呢？</p>
<p>举个例子，如果采用全排序的方法，那么在第 n 次收到用户输入时，则需要对 n 个数字进行排序并输出中位数，此时服务端已经保存了这 n 个数字的有序数组了。而在第 n+1 次收到用户输入时，是不需要对 n+1 个数字整体排序的，仅仅通过插入这个数字到一个有序数组中就可以完成排序。显然，利用这个性质后，时间复杂度可以降低到 O(n)。</p>
<p><strong>接着，我们从数据的操作层面来看，是否仍然有优化的空间</strong>。对于这个问题，其目标是输出中位数。只要你能在 n 个数字中，找到比 x 小的 n/2 个数字和比 x 大的 n/2 个数字，那么 x 就是最终需要返回的结果。</p>
<p>基于这个思想，可以动态的维护一个最小的 n/2 个数字的集合，和一个最大的 n/2 个数字的集合。如果数字是奇数个，就我们就在左边最小的 n/2 个数字集合中多存一个元素。</p>
<p>例如，当前服务端收到的数字有 0、1、2、10、20。如果用两个数据结构分别维护 0、1、2 和 10、20，那么当服务端收到 22 时，就可以根据 1、2、10 和 22 的大小关系，判断出中位数到底是多少了。</p>
<p>具体而言，当前的中位数是 2，额外增加一个数字之后，新的中位数只可能发生在 1、2、10 和新增的一个数字之间。不管中位数发生在哪里，都可以通过一些 if-else 语句进行查找，那么时间复杂度就是 O(1)。</p>
<p>虽然这种方法对于查找中位数的时间复杂度降低到了 O(1)，但是它还需要有一些后续的处理，这主要是辅助下一次的请求。</p>
<p><strong>例如，当前用两个数据结构分别维护着 0、1、2 和 10、20，那么新增了 22 之后，这两个数据结构如何更新。这就是原问题最核心的瓶颈了</strong>。</p>
<p>从结果来看，如果新增的数字比较小，那么就添加到左边的数据结构，并且把其中最大的 2 新增到右边，以保证二者数量相同。如果新增的数字比较大，那么就放到右边的数据结构，以保证二者数量相同。在这里，可能需要的数据操作包括，查找、中间位置的新增、最后位置的删除。</p>
<p>顺着这个思路继续分析，有序环境中的查找可以采用二分查找，时间复杂度是 O(logn)。最后位置的删除，并不牵涉到数据的挪移，时间复杂度是 O(1)。中间位置的新增就麻烦了，它需要对数据进行挪移，时间复杂度是 O(n)。如果要降低它的复杂度就需要用一些其他手段了。</p>
<p><strong>在这个问题中，有一个非常重要的信息，那就是题目只要中位数，而中位数左边和右边是否有序不重要。于是，我们需要用到这样的数据结构，大顶堆和小顶堆</strong>。</p>
<ul>
<li>大顶堆是一棵完全二叉树，它的性质是，父结点的数值比子结点的数值大；</li>
<li>小顶堆的性质与此相反，父结点的数值比子结点的数值小。</li>
</ul>
<p>有了这两个堆之后，我们的操作步骤就是，将中位数左边的数据都保存在大顶堆中，中位数右边的数据都保存在小顶堆中。同时，还要保证两个堆保存的数据个数相等或只差一个。这样，当有了一个新的数据插入时，插入数据的时间复杂度是 O(logn)。而插入后的中位数，肯定在大顶堆的堆顶元素上，因此，找到中位数的时间复杂度就是 O(1)。</p>
<p>我们把这个思路，用代码来实现，则有：</p>
<pre><code>import java.util.PriorityQueue;
import java.util.Comparator;
public class testj {
    int count = 0;
    static PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();
    static PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2.compareTo(o1);
        }
    });
    public void Insert(Integer num) {
        if (count % 2 == 0) {
            minHeap.offer(num);
            maxHeap.offer(minHeap.poll());
        } else {
            maxHeap.offer(num);
            minHeap.offer(maxHeap.poll());
        }
        count++;
        System.out.println(testj.GetMedian());
    }
    public static int GetMedian() {
        return maxHeap.peek();
    }
    public static void main(String[] args) {
        testj t = new testj();
        t.Insert(1);
        t.Insert(2);
        t.Insert(0);
        t.Insert(20);
        t.Insert(10);
        t.Insert(22);
    }
}
</code></pre>
<p><strong>我们对代码进行解读：</strong> 在第 6～12 行，分别定义了最小堆和最大堆。第 5 行的变量，保存的是累积收到的输入个数，可以用来判断奇偶。接着我们看主函数的第 30～38 行。在这里，模拟了流式数据，先后输入了 1、2、0、20、10、22，并调用了 Inset() 函数。</p>
<p>从第 14 行开始，Inset() 函数中，需要判断 count 的奇偶性：如果 count 是偶数，则新的数据需要先加入最小堆，再弹出最小堆的堆顶，最后把弹出的数据加入最大堆。如果 count 是奇数，则新的数据需要先加入最大堆，再弹出最大堆的堆顶，最后把弹出的数据加入最小堆。</p>
<p>执行完后，count 加 1。然后调用 GetMedian() 函数来寻找中位数，GetMedian() 函数通过 27 行直接返回最大堆的对顶，这是因为我们约定中位数在偶数个的时候，选择偏左的元素。</p>
<p>最后，我们给出插入 22 的执行过程，如下图所示：</p>
<p><img alt="4.gif" src="assets/Ciqc1F8MQD2AGebMAAm_13LKPTk687.gif"/></p>
<h3 id="总结">总结</h3>
<p>这一课时主要围绕数据结构展开问题的分析和讨论。对于树的层次遍历，我们再拓展一下。</p>
<p>如果要打印的不是层次，而是蛇形遍历，又该如何实现呢？蛇形遍历就是 s 形遍历，即奇数层从左到右，偶数层从右到左。如果是例题 2 的树，则蛇形遍历的结果就是 16、20、13、10、15、22、26、21。我们就把这个问题当作本课时的练习题。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#3c50505005080d0d0c0b7c5b515d5550125f5351" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9359d4854e5481db',t:'MTc0NTU0MjA1Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
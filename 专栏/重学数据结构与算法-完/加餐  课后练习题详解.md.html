<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="加餐  课后练习题详解" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>加餐  课后练习题详解 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/00%20%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%ef%bc%8c%e5%ba%94%e8%af%a5%e8%bf%99%e6%a0%b7%e5%ad%a6%ef%bc%81.md.html" id="00 数据结构与算法，应该这样学！.md.html">00 数据结构与算法，应该这样学！.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/01%20%20%e5%a4%8d%e6%9d%82%e5%ba%a6%ef%bc%9a%e5%a6%82%e4%bd%95%e8%a1%a1%e9%87%8f%e7%a8%8b%e5%ba%8f%e8%bf%90%e8%a1%8c%e7%9a%84%e6%95%88%e7%8e%87%ef%bc%9f.md.html" id="01  复杂度：如何衡量程序运行的效率？.md.html">01  复杂度：如何衡量程序运行的效率？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/02%20%20%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%9a%e5%b0%86%e2%80%9c%e6%98%82%e8%b4%b5%e2%80%9d%e7%9a%84%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e8%bd%ac%e6%8d%a2%e6%88%90%e2%80%9c%e5%bb%89%e4%bb%b7%e2%80%9d%e7%9a%84%e7%a9%ba%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6.md.html" id="02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html">02  数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/03%20%20%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9a%e6%8e%8c%e6%8f%a1%e6%95%b0%e6%8d%ae%e5%a4%84%e7%90%86%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c,%e4%bb%a5%e4%b8%8d%e5%8f%98%e5%ba%94%e4%b8%87%e5%8f%98.md.html" id="03  增删查：掌握数据处理的基本操作,以不变应万变.md.html">03  增删查：掌握数据处理的基本操作,以不变应万变.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/04%20%20%e5%a6%82%e4%bd%95%e5%ae%8c%e6%88%90%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%bb%93%e6%9e%84%e4%b8%8b%e7%9a%84%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="04  如何完成线性表结构下的增删查？.md.html">04  如何完成线性表结构下的增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/05%20%20%e6%a0%88%ef%bc%9a%e5%90%8e%e8%bf%9b%e5%85%88%e5%87%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e8%a1%a8%ef%bc%8c%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="05  栈：后进先出的线性表，如何实现增删查？.md.html">05  栈：后进先出的线性表，如何实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/06%20%20%e9%98%9f%e5%88%97%ef%bc%9a%e5%85%88%e8%bf%9b%e5%85%88%e5%87%ba%e7%9a%84%e7%ba%bf%e6%80%a7%e8%a1%a8%ef%bc%8c%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="06  队列：先进先出的线性表，如何实现增删查？.md.html">06  队列：先进先出的线性表，如何实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/07%20%20%e6%95%b0%e7%bb%84%ef%bc%9a%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%9f%ba%e4%ba%8e%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9f%a5%e6%89%be%ef%bc%9f.md.html" id="07  数组：如何实现基于索引的查找？.md.html">07  数组：如何实现基于索引的查找？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/08%20%20%e5%ad%97%e7%ac%a6%e4%b8%b2%ef%bc%9a%e5%a6%82%e4%bd%95%e6%ad%a3%e7%a1%ae%e5%9b%9e%e7%ad%94%e9%9d%a2%e8%af%95%e4%b8%ad%e9%ab%98%e9%a2%91%e8%80%83%e5%af%9f%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d%e7%ae%97%e6%b3%95%ef%bc%9f.md.html" id="08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html">08  字符串：如何正确回答面试中高频考察的字符串匹配算法？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/09%20%20%e6%a0%91%e5%92%8c%e4%ba%8c%e5%8f%89%e6%a0%91%ef%bc%9a%e5%88%86%e6%94%af%e5%85%b3%e7%b3%bb%e4%b8%8e%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84%e4%b8%8b%ef%bc%8c%e5%a6%82%e4%bd%95%e6%9c%89%e6%95%88%e5%ae%9e%e7%8e%b0%e5%a2%9e%e5%88%a0%e6%9f%a5%ef%bc%9f.md.html" id="09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html">09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/10%20%20%e5%93%88%e5%b8%8c%e8%a1%a8%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e5%a5%bd%e9%ab%98%e6%95%88%e7%8e%87%e6%9f%a5%e6%89%be%e7%9a%84%e2%80%9c%e5%88%a9%e5%99%a8%e2%80%9d%ef%bc%9f.md.html" id="10  哈希表：如何利用好高效率查找的“利器”？.md.html">10  哈希表：如何利用好高效率查找的“利器”？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/11%20%20%e9%80%92%e5%bd%92%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e9%80%92%e5%bd%92%e6%b1%82%e8%a7%a3%e6%b1%89%e8%af%ba%e5%a1%94%e9%97%ae%e9%a2%98%ef%bc%9f.md.html" id="11  递归：如何利用递归求解汉诺塔问题？.md.html">11  递归：如何利用递归求解汉诺塔问题？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/12%20%20%e5%88%86%e6%b2%bb%ef%bc%9a%e5%a6%82%e4%bd%95%e5%88%a9%e7%94%a8%e5%88%86%e6%b2%bb%e6%b3%95%e5%ae%8c%e6%88%90%e6%95%b0%e6%8d%ae%e6%9f%a5%e6%89%be%ef%bc%9f.md.html" id="12  分治：如何利用分治法完成数据查找？.md.html">12  分治：如何利用分治法完成数据查找？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/13%20%20%e6%8e%92%e5%ba%8f%ef%bc%9a%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90%e4%b8%8e%e4%bc%98%e5%8a%a3%e5%af%b9%e6%af%94.md.html" id="13  排序：经典排序算法原理解析与优劣对比.md.html">13  排序：经典排序算法原理解析与优劣对比.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/14%20%20%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%9a%e8%bf%87%e6%9c%80%e4%bc%98%e5%ad%90%e7%bb%93%e6%9e%84%ef%bc%8c%e5%ae%8c%e6%88%90%e5%a4%8d%e6%9d%82%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3%ef%bc%9f.md.html" id="14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html">14  动态规划：如何通过最优子结构，完成复杂问题求解？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/15%20%20%e5%ae%9a%e4%bd%8d%e9%97%ae%e9%a2%98%e6%89%8d%e8%83%bd%e6%9b%b4%e5%a5%bd%e5%9c%b0%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98%ef%bc%9a%e5%bc%80%e5%8f%91%e5%89%8d%e7%9a%84%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90%e4%b8%8e%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b.md.html" id="15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html">15  定位问题才能更好地解决问题：开发前的复杂度分析与技术选型.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/16%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e7%ae%97%e6%b3%95%e6%80%9d%e7%bb%b4%e8%ae%ad%e7%bb%83.md.html" id="16  真题案例（一）：算法思维训练.md.html">16  真题案例（一）：算法思维训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/17%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%ae%ad%e7%bb%83.md.html" id="17  真题案例（二）：数据结构训练.md.html">17  真题案例（二）：数据结构训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/18%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9a%e5%8a%9b%e6%89%a3%e7%9c%9f%e9%a2%98%e8%ae%ad%e7%bb%83.md.html" id="18  真题案例（三）：力扣真题训练.md.html">18  真题案例（三）：力扣真题训练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/19%20%20%e7%9c%9f%e9%a2%98%e6%a1%88%e4%be%8b%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9a%e5%a4%a7%e5%8e%82%e7%9c%9f%e9%a2%98%e5%ae%9e%e6%88%98%e6%bc%94%e7%bb%83.md.html" id="19  真题案例（四）：大厂真题实战演练.md.html">19  真题案例（四）：大厂真题实战演练.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/20%20%20%e4%bb%a3%e7%a0%81%e4%b9%8b%e5%a4%96%ef%bc%8c%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e4%b8%ad%e4%bd%a0%e5%ba%94%e8%af%a5%e5%85%b7%e5%a4%87%e5%93%aa%e4%ba%9b%e8%bd%af%e7%b4%a0%e8%b4%a8%ef%bc%9f.md.html" id="20  代码之外，技术面试中你应该具备哪些软素质？.md.html">20  代码之外，技术面试中你应该具备哪些软素质？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/21%20%20%e9%9d%a2%e8%af%95%e4%b8%ad%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b%e5%85%a8%e5%b1%80%e8%a7%82%ef%bc%8c%e5%bf%ab%e9%80%9f%e5%ae%8c%e6%88%90%e4%bc%98%e8%b4%a8%e7%9a%84%e6%89%8b%e5%86%99%e4%bb%a3%e7%a0%81%ef%bc%9f.md.html" id="21  面试中如何建立全局观，快速完成优质的手写代码？.md.html">21  面试中如何建立全局观，快速完成优质的手写代码？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e9%87%8d%e5%ad%a6%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95-%e5%ae%8c/%e5%8a%a0%e9%a4%90%20%20%e8%af%be%e5%90%8e%e7%bb%83%e4%b9%a0%e9%a2%98%e8%af%a6%e8%a7%a3.md.html" id="加餐  课后练习题详解.md.html">加餐  课后练习题详解.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="加餐  课后练习题详解" id="title">加餐  课后练习题详解</h1>
<div><p>专栏虽已结束，但学习不应停止。我看到很多同学依然还在这里学习，一部分同学积极地在留言区和大家分享学习总结和练习题答案。</p>
<p>我几乎在每个课时的结尾都留下了一道练习题，目的是帮助你检测和巩固本课时的重点内容，抑或是引出后续课时中的内容。在我处理留言的过程中，发现很多同学想要练习题详细解答过程以及答案，所以就有了今天的这一篇加餐内容，希望对你有所帮助。</p>
<p>接下来我会给出每个课时练习题的解题思路和答案，如果你没有找到对应的练习题答案，那么请你在正课中查找。</p>
<h4 id="01-复杂度-如何衡量程序运行的效率">01 | 复杂度：如何衡量程序运行的效率？</h4>
<p><strong>【问题】</strong> 评估一下，如下的代码片段，时间复杂度是多少？</p>
<pre><code>for (i = 0; i &lt; n; i++) { 
	for (j = 0; j &lt; n; j++) { 
		for (k = 0; k &lt; n; k++) { 
		} 
		for (m = 0; m &lt; n; m++) { 
		} 
	} 
}
</code></pre>
<p><strong>【解析】</strong> 在上面的代码中：</p>
<ul>
<li>第 3～5 行和 6～8 行，显然是一个 O(n) 复杂度的循环。这两个循环是顺序结构，因此合在一起的复杂度是 O(n) + O(n) = O(2n) = O(n)。</li>
<li>第 2～9 行是一个 for 循环，它的时间复杂度是 O(n)。这个 for 循环内部嵌套了 O(n) 复杂度的代码，因此合在一起就是 O(n ² ) 的时间复杂度。</li>
<li>在代码的最外部，第 1～10 行又是一个 O(n) 复杂度的循环，内部嵌套了 O(n ² ) 的时间复杂度的代码。因此合在一起就是 O(n ³ ) 的时间复杂度。</li>
</ul>
<h4 id="02-数据结构-将-昂贵-的时间复杂度转换成-廉价-的空间复杂度">02 | 数据结构：将“昂贵”的时间复杂度转换成“廉价”的空间复杂度</h4>
<p><strong>【问题】</strong> 在下面这段代码中，如果要降低代码的执行时间，第 4 行代码需要做哪些改动呢？如果做出改动后，是否降低了时间复杂度呢？</p>
<pre><code>public void s2_2() { 
	int count = 0; 
	for (int i = 0; i &lt;= (100 / 7); i++) { 
		for (int j = 0; j &lt;= (100 / 3); j++) { 
			if ((100-i*7-j*3 &gt;= 0)&amp;&amp;((100-i*7-j*3) % 2 == 0)) { 
				count += 1; 
			} 
		} 
	} 
	System.out.println(count); 
}
</code></pre>
<p><strong>【解析】</strong> 代码的第 4 行可以改为：</p>
<pre><code>for (int j = 0; j &lt;= (100-7*i) / 3; j++) {
</code></pre>
<p>代码改造完成后，时间复杂度并没有变小。但由于减少了一些不必要的计算量，程序的执行时间变少了。</p>
<h4 id="03-增删查-掌握数据处理的基本操作-以不变应万变">03 | 增删查：掌握数据处理的基本操作，以不变应万变</h4>
<p><strong>【问题】</strong> 对于一个包含 5 个元素的数组，如果要把这个数组元素的顺序翻转过来。你可以试着分析该过程需要对数据进行哪些操作？</p>
<p><strong>【解析】</strong> 假设原数组 a = {1,2,3,4,5}，现在要更改为 a = {5,4,3,2,1}。要想得到新的数组，就要找到 “1” 和 “5”，再分别把它们赋值给对方。因此，这里主要会产生大量的基于索引位置的查找动作。</p>
<h4 id="04-如何完成线性表结构下的增删查">04 | 如何完成线性表结构下的增删查？</h4>
<p><strong>【问题】</strong> 给定一个包含 n 个元素的链表，现在要求每 k 个节点一组进行翻转，打印翻转后的链表结果。例如，链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6，k = 3，则打印 321654。</p>
<p><strong>【解析】</strong> 我们给出一些提示。利用链表翻转的算法，这个问题应该很简单。利用 3 个指针，prev、curr、next，执行链表翻转，每次得到了 k 个翻转的结点就执行打印。</p>
<h4 id="05-栈-后进先出的线性表-如何实现增删查">05 | 栈：后进先出的线性表，如何实现增删查？</h4>
<p><strong>【问题】</strong> 给定一个包含 n 个元素的链表，现在要求每 k 个节点一组进行翻转，打印翻转后的链表结果。例如，链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6，k = 3，则打印 321654。要求用栈来实现。</p>
<p><strong>【解析】</strong> 我们用栈来实现它，就很简单了。你可以牢牢记住，<strong>只要涉及翻转动作的题目，都是使用栈来解决的强烈信号</strong>。</p>
<p>具体的操作如下，设置一个栈，不断将队列数据入栈，并且实时记录栈的大小。当栈的大小达到 k 的时候，全部出栈。我们给出核心代码：</p>
<pre><code>while (tmp != null &amp;&amp; count &lt; k) { 
    stack.push(tmp.value); 
    tmp = tmp.next; 
    count++; 
} 
while (!stack.isEmpty()) { 
    System.out.print(stack.pop()); 
}
</code></pre>
<h4 id="07-数组-如何实现基于索引的查找">07 | 数组：如何实现基于索引的查找？</h4>
<p><strong>详细分析和答案，请翻阅 18 课时例题 1</strong>。</p>
<h4 id="08-字符串-如何正确回答面试中高频考察的字符串匹配算法">08 | 字符串：如何正确回答面试中高频考察的字符串匹配算法？</h4>
<p><strong>详细分析和解题步骤，请参考 17 课时例题 1。</strong></p>
<h4 id="10-哈希表-如何利用好高效率查找的-利器">10 | 哈希表：如何利用好高效率查找的“利器”？</h4>
<p><strong>详细分析和答案，请翻阅 15 课时例题 1</strong>。</p>
<h4 id="11-递归-如何利用递归求解汉诺塔问题">11 | 递归：如何利用递归求解汉诺塔问题？</h4>
<p><strong>详细分析和答案，请翻阅 16 课时例题 1</strong>。</p>
<h4 id="12-分治-如何利用分治法完成数据查找">12 | 分治：如何利用分治法完成数据查找？</h4>
<p><strong>【问题】</strong> 在一个有序数组中，查找出第一个大于 9 的数字，假设一定存在。例如，arr = { -1, 3, 3, 7, 10, 14, 14 }；则返回 10。</p>
<p><strong>【解析】</strong> 在这里提醒一下，带查找的目标数字具备这样的性质：</p>
<ul>
<li>第一，它比 9 大；</li>
<li>第二，它前面的数字（除非它是第一个数字），比 9 小。</li>
</ul>
<p>因此，当我们作出向左走或向右走的决策时，必须满足这两个条件。代码如下：</p>
<pre><code>public static void main(String[] args) { 
	int targetNumb = 9; 
	// 目标有序数组 
	int[] arr = { -1, 3, 3, 7, 10, 14, 14 }; 
	int middle = 0; 
	int low = 0; 
	int high = arr.length - 1; 
	while (low &lt;= high) { 
		middle = (high + low) / 2; 
		if (arr[middle] &gt; targetNumb &amp;&amp; (middle == 0 || arr[middle - 1] &lt;= targetNumb)) { 
			System.out.println("第一个比 " + targetNumb + " 大的数字是 " + arr[middle]); 
			break; 
		} else if (arr[middle] &gt; targetNumb) { 
			// 说明该数在low~middle之间 
			high = middle - 1; 
		} else { 
			// 说明该数在middle~high之间 
			low = middle + 1; 
		} 
	}	 
}
</code></pre>
<h4 id="14-动态规划-如何通过最优子结构-完成复杂问题求解">14 | 动态规划：如何通过最优子结构，完成复杂问题求解？</h4>
<p><strong>详细分析和答案，请翻阅 16 课时例题 3</strong>。</p>
<h4 id="15-定位问题才能更好地解决问题-开发前的复杂度分析与技术选型">15 | 定位问题才能更好地解决问题：开发前的复杂度分析与技术选型</h4>
<p><strong>【问题】</strong> 下面的代码采用了两个 for 循环去实现 two sums。那么，能否只使用一个 for 循环完成呢？</p>
<pre><code>private static int[] twoSum(int[] arr, int target) { 
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 
    for (int i = 0; i &lt; arr.length; i++) { 
        map.put(arr[i], i); 
    } 
    for (int i = 0; i &lt; arr.length; i++) { 
        int complement = target - arr[i]; 
        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { 
            return new int[] { map.get(complement), i }; 
        } 
    } 
    return null; 
}
</code></pre>
<p><strong>【解析】</strong> 原代码中，第 3 和第 6 行的 for 循环合并后，就需要把 map 的新增、查找合在一起执行。则代码如下：</p>
<pre><code>private static int[] twoSum(int[] arr, int target) { 
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 
    for (int i = 0; i &lt; arr.length; i++) { 
        int complement = target - arr[i]; 
        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { 
            return new int[] { map.get(complement), i }; 
        } 
        else{ 
            map.put(arr[i], i); 
        } 
    } 
    return null; 
}
</code></pre>
<h4 id="16-真题案例-一-算法思维训练">16 | 真题案例（一）：算法思维训练</h4>
<p><strong>【问题】</strong> 如果现在是个线上实时交互的系统。客户端输入 x，服务端返回斐波那契数列中的第 x 位。那么，这个问题使用上面的解法是否可行。</p>
<p><strong>【解析】</strong> 这里给你一个小提示，既然我这么问，答案显然是不可行的。如果不可行，原因是什么呢？我们又该如何解决？</p>
<p>注意，题目中给出的是一个实时系统。当用户提交了 x，如果在几秒内没有得到系统响应，用户就会卸载 App 啦。</p>
<p>一个实时系统，必须想方设法在 O(1) 时间复杂度内返回结果。因此，一个可行的方式是，在系统上线之前，把输入 x 在 1～100 的结果预先就计算完，并且保存在数组里。当收到 1～100 范围内输入时，O(1) 时间内就可以返回。如果不在这个范围，则需要计算。计算之后的结果返回给用户，并在数组中进行保存。以方便后续同样输入时，能在 O(1) 时间内可以返回。</p>
<h4 id="17-真题案例-二-数据结构训练">17 | 真题案例（二）：数据结构训练</h4>
<p><strong>【问题】</strong> 对于树的层次遍历，我们再拓展一下。如果要打印的不是层次，而是蛇形遍历，又该如何实现呢？蛇形遍历就是 s 形遍历，即奇数层从左到右，偶数层从右到左。</p>
<p><strong>【解析】</strong> 这里要对数据的顺序进行逆序处理，直观上，你需要立马想到栈。毕竟只有栈是后进先出的结构，是能快速实现逆序的。具体而言，需要建立两个栈 s1 和 s2。进栈的顺序是，s1 先右后左，s2 先左后右。两个栈交替出栈的结果就是 s 形遍历，代码如下：</p>
<pre><code>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNodes pRoot) { 
    // 先右后左 
    Stack&lt;TreeNodes&gt; s1 = new Stack&lt;TreeNodes&gt;(); 
    // 先左后右 
    Stack&lt;TreeNodes&gt; s2 = new Stack&lt;TreeNodes&gt;(); 
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); 
    list.add(pRoot.val); 
    s1.push(pRoot); 
    while (s1.isEmpty() || s2.isEmpty()) { 
        if (s1.isEmpty() &amp;&amp; s2.isEmpty()) { 
            break; 
        } 
        if (s2.isEmpty()) { 
            while (!s1.isEmpty()) { 
                if (s1.peek().right != null) { 
                    list.add(s1.peek().right.val); 
                    s2.push(s1.peek().right); 
                } 
                if (s1.peek().left != null) { 
                    list.add(s1.peek().left.val); 
                    s2.push(s1.peek().left); 
                } 
                s1.pop(); 
            } 
        } else { 
            while (!s2.isEmpty()) { 
                if (s2.peek().left != null) { 
                    list.add(s2.peek().left.val); 
                    s1.push(s2.peek().left); 
                } 
                if (s2.peek().right != null) { 
                    list.add(s2.peek().right.val); 
                    s1.push(s2.peek().right); 
                } 
                s2.pop(); 
            } 
        } 
    } 
    return list; 
}
</code></pre>
<h4 id="18-真题案例-三-力扣真题训练">18 | 真题案例（三）： 力扣真题训练</h4>
<p><strong>【问题】</strong> 给定一个链表，删除链表的倒数第 n 个节点。例如，给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和 n = 2。当删除了倒数第二个节点后，链表变为 1 -&gt; 2 -&gt; 3 -&gt; 5。你可以假设，给定的 n 是有效的。额外要求就是，要在一趟扫描中实现，即时间复杂度是 O(n)。这里给你一个提示，可以采用快慢指针的方法。</p>
<p><strong>【解析】</strong> 定义快慢指针，slow 和 fast 并同时指向 header。然后，让 fast 指针先走 n 步。接着，让二者保持同样的速度，一起往前走。最后，fast 指针先到达终点，并指向了 null。此时，slow 指针的结果就是倒数第 n 个结点。比较简单，我们就不给代码了。</p>
<h4 id="19-真题案例-四-大厂真题实战演练">19 | 真题案例（四）：大厂真题实战演练</h4>
<p><strong>【问题】</strong> 小明从小就喜欢数学，喜欢在笔记里记录很多表达式。他觉得现在的表达式写法很麻烦，为了提高运算符优先级，不得不添加很多括号。如果不小心漏了一个右括号的话，就差之毫厘，谬之千里了。因此他改用前缀表达式，例如把 <code>(2 + 3) * 4</code>写成<code>* + 2 3 4</code>，这样就能避免使用括号了。这样的表达式虽然书写简单，但计算却不够直观。请你写一个程序帮他计算这些前缀表达式。</p>
<p><strong>【解析】</strong> 在这个题目中，输入就是前缀表达式，输出就是计算的结果。你可以假设除法为整除，即 “5/3 = 1”。例如，输入字符串为 + 2 3，输出 5；输入字符串为 * + 2 2 3，输出为 12；输入字符串为 * 2 + 2 3，输出为 10。</p>
<p>假设输入字符串为 * 2 + 2 3，即 2*(2+3)。第一个字符为运算符号 *，它将对两个数字进行乘法。如果后面紧接着的字符不全是数字字符，那就需要暂存下来，先计算后面的算式。一旦后面的计算完成，就需要接着从后往前去继续计算。因为从后往前是一种逆序动作，我们能够很自然地想到可以用栈的数据结构进行存储。代码如下：</p>
<pre><code>public static void main(String[] args) { 
    Stack&lt;Object&gt; stack = new Stack&lt;Object&gt;(); 
    String s = "* + 2 2 3"; 
    String attr[] = s.split(" "); 
    for (int i = attr.length - 1; i &gt;= 0; i--) { 
        if (!(attr[i].equals("+") || attr[i].equals("-") || attr[i].equals("*") || attr[i].equals("/"))) { 
            stack.push(Integer.parseInt(attr[i])); 
        } else { 
            int a = (int) stack.pop();// 出栈 
            int b = (int) stack.pop();// 出栈 
            int result = Cal(a, b, attr[i]); // 调用函数计算结果值 
            stack.push(result); // 结果进栈 
        } 
    } 
    int ans = (int) stack.pop(); 
    System.out.print(ans); 
} 
public static int Cal(int a, int b, String s) { 
    switch (s) { 
        case "+": 
            return a + b; 
        case "-": 
            return a - b; 
        case "*": 
            return a * b; 
        case "/": 
            return a / b; 
    } 
    return 0; 
}
</code></pre>
<p>以上这些练习题你做得怎么样呢？还能回忆起来每道题是源自哪个算法知识点或哪个课时吗？</p>
<p>你可以把课后习题和课程中的案例都当作一个小项目，自己动手实践，即使有些题目你还不能写出完整的代码，那也可以尝试写出解题思路，从看不明白到能够理解，再到能联想到用什么数据结构和算法去解决什么样的问题，这是一个循序渐进的过程，切勿着急。</p>
<p>通过留言可以看出，你们都在认真地学习这门课程，也正因如此，我才愿意付出更多的时间优化这个已经完结的专栏。所以，请你不要犹豫，尽管畅所欲言，在留言区留下你的思考，也欢迎你积极地提问，更欢迎你为专栏提出建议，这样我才能更直接地看到你们的想法和收获。也许你的一条留言，就是下一篇加餐的主题。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#dfb3b3b3e6ebeeeeefe89fb8b2beb6b3f1bcb0b2" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9359d50f79e25ae6',t:'MTc0NTU0MjA4MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
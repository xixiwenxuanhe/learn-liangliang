<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="21 期末实战：为你的简约版IM系统，加上功能" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>21 期末实战：为你的简约版IM系统，加上功能 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e6%90%9e%e6%87%82%e2%80%9c%e5%ae%9e%e6%97%b6%e4%ba%a4%e4%ba%92%e2%80%9d%e7%9a%84IM%e6%8a%80%e6%9c%af%ef%bc%8c%e5%b0%86%e4%bc%9a%e6%9c%89%e4%bb%80%e4%b9%88%e6%96%b0%e6%9c%ba%e9%81%87%ef%bc%9f.md.html" id="00 开篇词 搞懂“实时交互”的IM技术，将会有什么新机遇？.md.html">00 开篇词 搞懂“实时交互”的IM技术，将会有什么新机遇？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/01%20%e6%9e%b6%e6%9e%84%e4%b8%8e%e7%89%b9%e6%80%a7%ef%bc%9a%e4%b8%80%e4%b8%aa%e5%ae%8c%e6%95%b4%e7%9a%84IM%e7%b3%bb%e7%bb%9f%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84%ef%bc%9f.md.html" id="01 架构与特性：一个完整的IM系统是怎样的？.md.html">01 架构与特性：一个完整的IM系统是怎样的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/02%20%e6%b6%88%e6%81%af%e6%94%b6%e5%8f%91%e6%9e%b6%e6%9e%84%ef%bc%9a%e4%b8%ba%e4%bd%a0%e7%9a%84App%ef%bc%8c%e5%8a%a0%e4%b8%8a%e5%ae%9e%e6%97%b6%e9%80%9a%e4%bf%a1%e5%8a%9f%e8%83%bd.md.html" id="02 消息收发架构：为你的App，加上实时通信功能.md.html">02 消息收发架构：为你的App，加上实时通信功能.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/03%20%e8%bd%ae%e8%af%a2%e4%b8%8e%e9%95%bf%e8%bf%9e%e6%8e%a5%ef%bc%9a%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%b6%88%e6%81%af%e7%9a%84%e5%ae%9e%e6%97%b6%e5%88%b0%e8%be%be%e9%97%ae%e9%a2%98%ef%bc%9f.md.html" id="03 轮询与长连接：如何解决消息的实时到达问题？.md.html">03 轮询与长连接：如何解决消息的实时到达问题？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/04%20ACK%e6%9c%ba%e5%88%b6%ef%bc%9a%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e7%9a%84%e5%8f%af%e9%9d%a0%e6%8a%95%e9%80%92%ef%bc%9f.md.html" id="04 ACK机制：如何保证消息的可靠投递？.md.html">04 ACK机制：如何保证消息的可靠投递？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/05%20%e6%b6%88%e6%81%af%e5%ba%8f%e5%8f%b7%e7%94%9f%e6%88%90%e5%99%a8%ef%bc%9a%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%bd%a0%e7%9a%84%e6%b6%88%e6%81%af%e4%b8%8d%e4%bc%9a%e4%b9%b1%e5%ba%8f%ef%bc%9f.md.html" id="05 消息序号生成器：如何保证你的消息不会乱序？.md.html">05 消息序号生成器：如何保证你的消息不会乱序？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/06%20HttpDNS%e5%92%8cTLS%ef%bc%9a%e4%bd%a0%e7%9a%84%e6%b6%88%e6%81%af%e8%81%8a%e5%a4%a9%e7%9c%9f%e7%9a%84%e5%ae%89%e5%85%a8%e5%90%97%ef%bc%9f.md.html" id="06 HttpDNS和TLS：你的消息聊天真的安全吗？.md.html">06 HttpDNS和TLS：你的消息聊天真的安全吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/07%20%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%92%8c%e5%8e%9f%e5%ad%90%e6%80%a7%ef%bc%9a%e4%bd%a0%e7%9c%8b%e5%88%b0%e7%9a%84%e6%9c%aa%e8%af%bb%e6%b6%88%e6%81%af%e6%8f%90%e9%86%92%e6%98%af%e7%9c%9f%e7%9a%84%e5%90%97%ef%bc%9f.md.html" id="07 分布式锁和原子性：你看到的未读消息提醒是真的吗？.md.html">07 分布式锁和原子性：你看到的未读消息提醒是真的吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/08%20%e6%99%ba%e8%83%bd%e5%bf%83%e8%b7%b3%e6%9c%ba%e5%88%b6%ef%bc%9a%e8%a7%a3%e5%86%b3%e7%bd%91%e7%bb%9c%e7%9a%84%e4%b8%8d%e7%a1%ae%e5%ae%9a%e6%80%a7.md.html" id="08 智能心跳机制：解决网络的不确定性.md.html">08 智能心跳机制：解决网络的不确定性.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/09%20%e5%88%86%e5%b8%83%e5%bc%8f%e4%b8%80%e8%87%b4%e6%80%a7%ef%bc%9a%e8%ae%a9%e4%bd%a0%e7%9a%84%e6%b6%88%e6%81%af%e6%94%af%e6%8c%81%e5%a4%9a%e7%bb%88%e7%ab%af%e6%bc%ab%e6%b8%b8.md.html" id="09 分布式一致性：让你的消息支持多终端漫游.md.html">09 分布式一致性：让你的消息支持多终端漫游.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/10%20%e8%87%aa%e5%8a%a8%e6%99%ba%e8%83%bd%e6%89%a9%e7%bc%a9%e5%ae%b9%ef%bc%9a%e7%9b%b4%e6%92%ad%e4%ba%92%e5%8a%a8%e5%9c%ba%e6%99%af%e4%b8%ad%e5%b3%b0%e5%80%bc%e6%b5%81%e9%87%8f%e7%9a%84%e5%ba%94%e5%af%b9.md.html" id="10 自动智能扩缩容：直播互动场景中峰值流量的应对.md.html">10 自动智能扩缩容：直播互动场景中峰值流量的应对.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/11%20%e6%9c%9f%e4%b8%ad%e5%ae%9e%e6%88%98%ef%bc%9a%e5%8a%a8%e6%89%8b%e5%86%99%e4%b8%80%e4%b8%aa%e7%ae%80%e6%98%93%e7%89%88%e7%9a%84IM%e7%b3%bb%e7%bb%9f.md.html" id="11 期中实战：动手写一个简易版的IM系统.md.html">11 期中实战：动手写一个简易版的IM系统.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/12%20%e6%9c%8d%e5%8a%a1%e9%ab%98%e5%8f%af%e7%94%a8%ef%bc%9a%e4%bf%9d%e8%af%81%e6%a0%b8%e5%bf%83%e9%93%be%e8%b7%af%e7%a8%b3%e5%ae%9a%e6%80%a7%e7%9a%84%e6%b5%81%e6%8e%a7%e5%92%8c%e7%86%94%e6%96%ad%e6%9c%ba%e5%88%b6.md.html" id="12 服务高可用：保证核心链路稳定性的流控和熔断机制.md.html">12 服务高可用：保证核心链路稳定性的流控和熔断机制.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/13%20HTTP%20Tunnel%ef%bc%9a%e5%a4%8d%e6%9d%82%e7%bd%91%e7%bb%9c%e4%b8%8b%e6%b6%88%e6%81%af%e9%80%9a%e9%81%93%e9%ab%98%e5%8f%af%e7%94%a8%e8%ae%be%e8%ae%a1%e7%9a%84%e6%80%9d%e8%80%83.md.html" id="13 HTTP Tunnel：复杂网络下消息通道高可用设计的思考.md.html">13 HTTP Tunnel：复杂网络下消息通道高可用设计的思考.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/14%20%e5%88%86%e7%89%87%e4%b8%8a%e4%bc%a0%ef%bc%9a%e5%a6%82%e4%bd%95%e8%ae%a9%e4%bd%a0%e7%9a%84%e5%9b%be%e7%89%87%e3%80%81%e9%9f%b3%e8%a7%86%e9%a2%91%e6%b6%88%e6%81%af%e5%8f%91%e9%80%81%e5%be%97%e6%9b%b4%e5%bf%ab%ef%bc%9f.md.html" id="14 分片上传：如何让你的图片、音视频消息发送得更快？.md.html">14 分片上传：如何让你的图片、音视频消息发送得更快？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/15%20CDN%e5%8a%a0%e9%80%9f%ef%bc%9a%e5%a6%82%e4%bd%95%e8%ae%a9%e4%bd%a0%e7%9a%84%e5%9b%be%e7%89%87%e3%80%81%e8%a7%86%e9%a2%91%e3%80%81%e8%af%ad%e9%9f%b3%e6%b6%88%e6%81%af%e6%b5%8f%e8%a7%88%e6%92%ad%e6%94%be%e4%b8%8d%e5%8d%a1%ef%bc%9f.md.html" id="15 CDN加速：如何让你的图片、视频、语音消息浏览播放不卡？.md.html">15 CDN加速：如何让你的图片、视频、语音消息浏览播放不卡？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/16%20APNs%ef%bc%9a%e8%81%8a%e4%b8%80%e8%81%8a%e7%ac%ac%e4%b8%89%e6%96%b9%e7%b3%bb%e7%bb%9f%e7%ba%a7%e6%b6%88%e6%81%af%e9%80%9a%e9%81%93%e7%9a%84%e4%ba%8b.md.html" id="16 APNs：聊一聊第三方系统级消息通道的事.md.html">16 APNs：聊一聊第三方系统级消息通道的事.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/17%20Cache%ef%bc%9a%e5%a4%9a%e7%ba%a7%e7%bc%93%e5%ad%98%e6%9e%b6%e6%9e%84%e5%9c%a8%e6%b6%88%e6%81%af%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8.md.html" id="17 Cache：多级缓存架构在消息系统中的应用.md.html">17 Cache：多级缓存架构在消息系统中的应用.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/18%20Docker%e5%ae%b9%e5%99%a8%e5%8c%96%ef%bc%9a%e8%af%b4%e4%b8%80%e8%af%b4IM%e7%b3%bb%e7%bb%9f%e4%b8%ad%e6%a8%a1%e5%9d%97%e6%b0%b4%e5%b9%b3%e6%89%a9%e5%b1%95%e7%9a%84%e5%ae%9e%e7%8e%b0.md.html" id="18 Docker容器化：说一说IM系统中模块水平扩展的实现.md.html">18 Docker容器化：说一说IM系统中模块水平扩展的实现.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/19%20%e7%ab%af%e5%88%b0%e7%ab%afTrace%ef%bc%9a%e6%b6%88%e6%81%af%e6%94%b6%e5%8f%91%e9%93%be%e8%b7%af%e7%9a%84%e7%9b%91%e6%8e%a7%e4%bd%93%e7%b3%bb%e6%90%ad%e5%bb%ba.md.html" id="19 端到端Trace：消息收发链路的监控体系搭建.md.html">19 端到端Trace：消息收发链路的监控体系搭建.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e5%ad%98%e5%82%a8%e5%92%8c%e5%b9%b6%e5%8f%91%ef%bc%9a%e4%b8%87%e4%ba%ba%e7%be%a4%e8%81%8a%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e4%b8%ad%e7%9a%84%e5%87%a0%e4%b8%aa%e9%9a%be%e7%82%b9.md.html" id="20 存储和并发：万人群聊系统设计中的几个难点.md.html">20 存储和并发：万人群聊系统设计中的几个难点.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/21%20%e6%9c%9f%e6%9c%ab%e5%ae%9e%e6%88%98%ef%bc%9a%e4%b8%ba%e4%bd%a0%e7%9a%84%e7%ae%80%e7%ba%a6%e7%89%88IM%e7%b3%bb%e7%bb%9f%ef%bc%8c%e5%8a%a0%e4%b8%8a%e5%8a%9f%e8%83%bd.md.html" id="21 期末实战：为你的简约版IM系统，加上功能.md.html">21 期末实战：为你的简约版IM系统，加上功能.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e7%ad%94%e7%96%91%e8%a7%a3%e6%83%91%ef%bc%9a%e4%b8%8d%e5%90%8c%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e5%9c%ba%e6%99%af%e4%b8%8b%e6%9e%b6%e6%9e%84%e5%ae%9e%e7%8e%b0%e4%b8%8a%e7%9a%84%e5%bc%82%e5%90%8c.md.html" id="22 答疑解惑：不同即时消息场景下架构实现上的异同.md.html">22 答疑解惑：不同即时消息场景下架构实现上的异同.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/%e5%8d%b3%e6%97%b6%e6%b6%88%e6%81%af%e6%8a%80%e6%9c%af%e5%89%96%e6%9e%90%e4%b8%8e%e5%ae%9e%e6%88%98/%e7%bb%93%e6%9d%9f%e8%af%ad%20%e7%9c%9f%e6%ad%a3%e7%9a%84%e9%ab%98%e8%b4%b5%ef%bc%8c%e4%b8%8d%e6%98%af%e4%bc%98%e4%ba%8e%e5%88%ab%e4%ba%ba%ef%bc%8c%e8%80%8c%e6%98%af%e4%bc%98%e4%ba%8e%e8%bf%87%e5%8e%bb%e7%9a%84%e8%87%aa%e5%b7%b1.md.html" id="结束语 真正的高贵，不是优于别人，而是优于过去的自己.md.html">结束语 真正的高贵，不是优于别人，而是优于过去的自己.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="21 期末实战：为你的简约版IM系统，加上功能" id="title">21 期末实战：为你的简约版IM系统，加上功能</h1>
<div><p>你好，我是袁武林。</p>
<p>在期中实战中，我们一起尝试实现了一个简易版的聊天系统，并且为这个聊天系统增加了一些基本功能。比如，用户登录、简单的文本消息收发、消息存储设计、未读数提示、消息自动更新等。</p>
<p>但是期中实战的目的，主要是让你对IM系统的基本功能构成有一个直观的了解，所以在功能的实现层面上比较简单。比如针对消息的实时性，期中采用的是基于HTTP短轮询的方式来实现。</p>
<p>因此，在期末实战中，我们主要的工作就是针对期中实战里的消息收发来进行功能优化。</p>
<p>比如，我们会采用WebSocket的长连接，来替代之前的HTTP短轮询方式，并且会加上一些课程中有讲到的相对高级的功能，如应用层心跳、ACK机制等。</p>
<p>希望通过期末整体技术实现上的升级，你能更深刻地体会到IM系统升级前后，对使用方和服务端压力的差异性。相应的示例代码我放在了<a href="https://github.com/coldwalker/Sample" target="_blank">GitHub</a>里，你可以作为参考来学习和实现。</p>
<h2 id="功能介绍">功能介绍</h2>
<p>关于这次期末实战，希望你能够完成的功能主要包括以下几个部分：</p>
<ol>
<li>支持基于WebSocket的长连接。</li>
<li>消息收发均通过长连接进行通信。</li>
<li>支持消息推送的ACK机制和重推机制。</li>
<li>支持客户端的心跳机制和双端的idle超时断连。</li>
<li>支持客户端断线后的自动重连。</li>
</ol>
<h2 id="功能实现拆解">功能实现拆解</h2>
<p>接下来，我们就针对以上这些需要升级的功能和新增的主要功能，来进行实现上的拆解。</p>
<h3 id="websocket长连接">WebSocket长连接</h3>
<p>首先，期末实战一个比较大的改变就是，将之前HTTP短轮询的实现，改造成真正的长连接。为了方便Web端的演示，这里我建议你可以使用WebSocket来实现。</p>
<p>对于WebSocket，我们在客户端JS（JavaScript）里主要是使用HTML5的原生API来实现，其核心的实现代码部分如下：</p>
<pre><code>if (window.WebSocket) {
    websocket = new WebSocket("ws://127.0.0.1:8080");
    websocket.onmessage = function (event) {
        onmsg(event);
    };

    //连接建立后的事件监听
    websocket.onopen = function () {
        bind();
        heartBeat.start();
    }

    //连接关闭后的事件监听
    websocket.onclose = function () {
        reconnect();
    };

    //连接出现异常后的事件监听
    websocket.onerror = function () {
        reconnect();
    };

} else {
    alert("您的浏览器不支持WebSocket协议！"
}
</code></pre>
<p>页面打开时，JS先通过服务端的WebSocket地址建立长连接。要注意这里服务端连接的地址是ws://开头的，不是http://的了；如果是使用加密的WebSocket协议，那么相应的地址应该是以wss://开头的。</p>
<p>建立长连之后，要针对创建的WebSocket对象进行事件的监听，我们只需要在各种事件触发的时候，进行对应的逻辑处理就可以了。</p>
<p>比如，API主要支持的几种事件有：长连接通道建立完成后，通过onopen事件来进行用户信息的上报绑定；通过onmessage事件，对接收到的所有该连接上的数据进行处理，这个也是我们最核心的消息推送的处理逻辑；另外，在长连接通道发生异常错误，或者连接被关闭时，可以分别通过onerror和onclose两个事件来进行监听处理。</p>
<p>除了通过事件监听，来对长连接的状态变化进行逻辑处理外，我们还可以通过这个WebSocket长连接，向服务器发送数据（消息）。这个功能在实现上也非常简单，你只需要调用WebSocket对象的send方法就OK了。</p>
<p>通过长连接发送消息的代码设计如下：</p>
<pre><code>var sendMsgJson = '{ "type": 3, "data": {"senderUid":' + sender_id + ',"recipientUid":' + recipient_id + ', "content":"' + msg_content + '","msgType":1  }}';

websocket.send(sendMsgJson);
</code></pre>
<p>此外，针对WebSocket在服务端的实现，如果你是使用JVM（Java Virtual Machine，Java虚拟机）系列语言的话，我推荐你使用比较成熟的Java NIO框架Netty来做实现。</p>
<p>因为Netty本身对WebSocket的支持就很完善了，各种编解码器和WebSocket的处理器都有，这样我们在代码实现上就比较简单。</p>
<p>采用Netty实现WebSocket Server的核心代码，你可以参考下面的示例代码：</p>
<pre><code>EventLoopGroup bossGroup =
                    new EpollEventLoopGroup(serverConfig.bossThreads, new DefaultThreadFactory("WebSocketBossGroup", true));

EventLoopGroup workerGroup =
                    new EpollEventLoopGroup(serverConfig.workerThreads, new DefaultThreadFactory("WebSocketWorkerGroup", true));

ServerBootstrap serverBootstrap = new ServerBootstrap().group(bossGroup, workerGroup).channel(EpollServerSocketChannel.class);

ChannelInitializer&lt;SocketChannel&gt; initializer = new ChannelInitializer&lt;SocketChannel&gt;() {
    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();
        //先添加WebSocket相关的编解码器和协议处理器
        pipeline.addLast(new HttpServerCodec());
        pipeline.addLast(new HttpObjectAggregator(65536));
        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));
        pipeline.addLast(new WebSocketServerProtocolHandler("/", null, true));
        //再添加服务端业务消息的总处理器
        pipeline.addLast(websocketRouterHandler);
        //服务端添加一个idle处理器，如果一段时间Socket中没有消息传输，服务端会强制断开
        pipeline.addLast(new IdleStateHandler(0, 0, serverConfig.getAllIdleSecond()));
        pipeline.addLast(closeIdleChannelHandler);
    }
}

serverBootstrap.childHandler(initializer);
serverBootstrap.bind(serverConfig.port).sync(
</code></pre>
<p>首先<strong>创建服务器的ServerBootstrap对象</strong>。Netty作为服务端，从ServerBootstrap启动，ServerBootstrap对象主要用于在服务端的某一个端口进行监听，并接受客户端的连接。</p>
<p>接着，<strong>通过ChannelInitializer对象，初始化连接管道中用于处理数据的各种编解码器和业务逻辑处理器</strong>。比如这里，我们就需要添加为了处理WebSocket协议相关的编解码器，还要添加服务端接收到客户端发送的消息的业务逻辑处理器，并且还加上了用于通道idle超时管理的处理器。</p>
<p>最后，<strong>把这个管道处理器链挂到ServerBootstrap，再通过bind和sync方法，启动ServerBootstrap的端口进行监听</strong>就可以了。</p>
<h3 id="核心消息收发逻辑处理">核心消息收发逻辑处理</h3>
<p>建立好WebSocket长连接后，我们再来看一下最核心的消息收发是怎么处理的。</p>
<p>刚才讲到，客户端发送消息的功能，在实现上其实比较简单。我们只需要通过WebSocket对象的send方法，就可以把消息通过长连接发送到服务端。</p>
<p>那么，下面我们就来看一下服务端接收到消息后的逻辑处理。</p>
<p>核心的代码逻辑在WebSocketRouterHandler这个处理器中，消息接收处理的相关代码如下：</p>
<pre><code> @Override
protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
    //如果是文本类型的WebSocket数据
    if (frame instanceof TextWebSocketFrame) {
        //先解析出具体的文本数据内容
        String msg = ((TextWebSocketFrame) frame).text();
        //再用JSON来对这些数据内容进行解析
        JSONObject msgJson = JSONObject.parseObject(msg);
        int type = msgJson.getIntValue("type");
        JSONObject data = msgJson.getJSONObject("data");

        long senderUid = data.getLong("senderUid");
        long recipientUid = data.getLong("recipientUid");
        String content = data.getString("content");
        int msgType = data.getIntValue("msgType");
        //调用业务层的Service来进行真正的发消息逻辑处理
        MessageVO messageContent = messageService.sendNewMsg(senderUid, recipientUid, content, msgType);

        if (messageContent != null) {
            JSONObject jsonObject = new JSONObject();
            jsonObject.put("type", 3);
            jsonObject.put("data", JSONObject.toJSON(messageContent));
                        ctx.writeAndFlush(new TextWebSocketFrame(JSONObject.toJSONString(jsonObject)));
        }
    }
}
</code></pre>
<p>这里的WebSocketRouterHandler，我们也是采用事件监听机制来实现。由于这里需要处理“接收到”的消息，所以我们只需要实现channelRead0方法就可以。</p>
<p>在前面的管道处理器链中，因为添加了WebSocket相关的编解码器，所以这里的WebSocketRouterHandler接收到的都是WebSocketFrame格式的数据。</p>
<p>接下来，我们从WebSocketFrame格式的数据中，解析出文本类型的收发双方UID和发送内容，就可以调用后端业务模块的发消息功能，来进行最终的发消息逻辑处理了。</p>
<p>最后，把需要返回给消息发送方的客户端的信息，再通过writeAndFlush方法写回去，就完成消息的发送。</p>
<p>不过，以上的代码只是处理消息的发送，那么针对消息下推的逻辑处理又是如何实现的呢？</p>
<p>刚刚讲到，客户端发送的消息，会通过后端业务模块来进行最终的发消息逻辑处理，这个处理过程也包括消息的推送触发。</p>
<p>因此，我们可以在messageService.sendNewMsg方法中，等待消息存储、未读变更都完成后，再处理待推送给接收方的消息。</p>
<p>你可以参考下面的核心代码：</p>
<pre><code>private static final ConcurrentHashMap&lt;Long, Channel&gt; userChannel = new ConcurrentHashMap&lt;&gt;(15000);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
        //处理上线请求
        long loginUid = data.getLong("uid");
        userChannel.put(loginUid, ctx.channel());
    }
public void pushMsg(long recipientUid, JSONObject message) {
    Channel channel = userChannel.get(recipientUid);
    if (channel != null &amp;&amp; channel.isActive() &amp;&amp; channel.isWritable()) {
        channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));
    }
}
</code></pre>
<p>首先，我们在处理用户建连上线的请求时，会先在网关机内存记录一个“当前连接用户和对应的连接”的映射。</p>
<p>当系统有消息需要推送时，我们通过查询这个映射关系，就能找到对应的连接，然后就可以通过这个连接，将消息下推下去。</p>
<pre><code>public class NewMessageListener implements MessageListener {
    @Override
    public void onMessage(Message message, byte[] pattern) {
        String topic = stringRedisSerializer.deserialize(message.getChannel());
        //从订阅到的Redis的消息里解析出真正需要的业务数据
        String jsonMsg = valueSerializer.deserialize(message.getBody());
        logger.info("Message Received --&gt; pattern: {}，topic:{}，message: {}", new String(pattern), topic, jsonMsg);
        JSONObject msgJson = JSONObject.parseObject(jsonMsg);
        //解析出消息接收人的UID
        long otherUid = msgJson.getLong("otherUid");
        JSONObject pushJson = new JSONObject();
        pushJson.put("type", 4);
        pushJson.put("data", msgJson);

        //最终调用网关层处理器将消息真正下推下去
        websocketRouterHandler.pushMsg(otherUid, pushJson);

    }
}

@Override
public MessageVO sendNewMsg(long senderUid, long recipientUid, String content, int msgType) {

    //先对发送消息进行存储、加未读等操作
    //...
    // 然后将待推送消息发布到Redis
    redisTemplate.convertAndSend(Constants.WEBSOCKET_MSG_TOPIC, JSONObject.toJSONString(messageVO));
}
</code></pre>
<p>然后，我们可以基于Redis的发布/订阅，实现一个消息推送的发布订阅器。</p>
<p>在业务层进行发送消息逻辑处理的最后，会将这条消息发布到Redis的一个Topic中，这个Topic被NewMessageListener一直监听着，如果有消息发布，那么监听器会马上感知到，然后再将消息提交给WebSocketRouterHandler，来进行最终消息的下推。</p>
<h3 id="消息推送的ack">消息推送的ACK</h3>
<p>我在<a href="https://time.geekbang.org/column/article/129751" target="_blank">“04 | ACK机制：如何保证消息的可靠投递？”</a>中有讲到，当系统有消息下推后，我们会依赖客户端响应的ACK包，来保证消息推送的可靠性。如果消息下推后一段时间，服务端没有收到客户端的ACK包，那么服务端会认为这条消息没有正常投递下去，就会触发重新下推。</p>
<p>关于ACK机制相应的服务端代码，你可以参考下面的示例：</p>
<pre><code>public void pushMsg(long recipientUid, JSONObject message) {
    channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));
    //消息推送下去后，将这条消息加入到待ACK列表中
    addMsgToAckBuffer(channel, message);
}
public void addMsgToAckBuffer(Channel channel, JSONObject msgJson) {
    nonAcked.put(msgJson.getLong("tid"), msgJson);
    //定时器针对下推的这条消息在5s后进行"是否ACK"的检查
    executorService.schedule(() -&gt; {
        if (channel.isActive()) {
            //检查是否被ACK，如果没有收到ACK回包，会触发重推
            checkAndResend(channel, msgJson);
        }
    }, 5000, TimeUnit.MILLISECONDS);
}
long tid = data.getLong("tid");
nonAcked.remove(tid);
private void checkAndResend(Channel channel, JSONObject msgJson) {
    long tid = msgJson.getLong("tid");
    //重推2次
    int tryTimes = 2;                    
    while (tryTimes &gt; 0) {
        if (nonAcked.containsKey(tid) &amp;&amp; tryTimes &gt; 0) {
            channel.writeAndFlush(new TextWebSocketFrame(msgJson.toJSONString()));
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        tryTimes--;
    }
}
</code></pre>
<p>用户在上线完成后，服务端会在这个连接维度的存储里，初始化一个起始值为0的序号（tid），每当有消息推送给客户端时，服务端会针对这个序号进行加1操作，下推消息时就会携带这个序号连同消息一起推下去。</p>
<p>消息推送后，服务端会将当前消息加入到一个“待ACK Buffer”中，这个ACK Buffer的实现，我们可以简单地用一个ConcurrentHashMap来实现，Key就是这条消息携带的序号，Value是消息本身。</p>
<p>当消息加入到这个“待ACK Buffer”时，服务端会同时创建一个定时器，在一定的时间后，会触发“检查当前消息是否被ACK”的逻辑；如果客户端有回ACK，那么服务端就会从这个“待ACK Buffer”中移除这条消息，否则如果这条消息没有被ACK，那么就会触发消息的重新下推。</p>
<h3 id="应用层心跳">应用层心跳</h3>
<p>在了解了如何通过WebSocket长连接，来完成最核心的消息收发功能之后，我们再来看下，针对这个长连接，我们如何实现新增加的应用层心跳功能。</p>
<p>应用层心跳的作用，我在<a href="https://time.geekbang.org/column/article/134231" target="_blank">第8课“智能心跳机制：解决网络的不确定性”</a>中也有讲到过，主要是为了解决由于网络的不确定性，而导致的连接不可用的问题。</p>
<p>客户端发送心跳包的主要代码设计如下，不过我这里的示例代码只是一个简单的实现，你可以自行参考，然后自己去尝试动手实现：</p>
<pre><code>//每2分钟发送一次心跳包，接收到消息或者服务端的响应又会重置来重新计时。
var heartBeat = {
    timeout: 120000,
    timeoutObj: null,
    serverTimeoutObj: null,
    reset: function () {
        clearTimeout(this.timeoutObj);
        clearTimeout(this.serverTimeoutObj);
        this.start();
    },
    start: function () {
        var self = this;
        this.timeoutObj = setTimeout(function () {
            var sender_id = $("#sender_id").val();
            var sendMsgJson = '{ "type": 0, "data": {"uid":' + sender_id + ',"timeout": 120000}}';
            websocket.send(sendMsgJson);
            self.serverTimeoutObj = setTimeout(function () {
                websocket.close();
                $("#ws_status").text("失去连接！");
            }, self.timeout)
        }, this.timeout)
    },
}
</code></pre>
<p>客户端通过一个定时器，每2分钟通过长连接给服务端发送一次心跳包，如果在2分钟内接收到服务端的消息或者响应，那么客户端的下次2分钟定时器的计时，会进行清零重置，重新计算；如果发送的心跳包在2分钟后没有收到服务端的响应，客户端会断开当前连接，然后尝试重连。</p>
<p>我在下面的代码示例中，提供的“服务端接收到心跳包的处理逻辑”的实现过程，其实非常简单，只是封装了一个普通回包消息进行响应，代码设计如下：</p>
<pre><code>@Override
protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {
    long uid = data.getLong("uid");
    long timeout = data.getLong("timeout");
    logger.info("[heartbeat]: uid = {} , current timeout is {} ms, channel = {}", uid, timeout, ctx.channel());
    ctx.writeAndFlush(new TextWebSocketFrame("{\"type\":0,\"timeout\":" + timeout + "}"));
}
</code></pre>
<p>我们实际在线上实现的时候，可以采用前面介绍的“智能心跳”机制，通过服务端对心跳包的响应，来计算新的心跳间隔，然后返回给客户端来进行调整。</p>
<p>好，到这里，期末实战的主要核心功能基本上也讲解得差不多了，细节方面你可以再翻一翻我在<a href="https://github.com/coldwalker/Sample" target="_blank">GitHub</a>上提供的示例代码。</p>
<p>对于即时消息场景的代码实现来说，如果要真正达到线上使用的程度，相应的代码量是非常庞大的；而且对于同一个功能的实现，根据不同的使用场景和业务特征，很多业务在设计上也会有较大的差异性。</p>
<p>所以，实战课程的设计和示例代码只能做到挂一漏万，我尽量通过最简化的代码，来让你真正了解某一个功能在实现上最核心的思想。并且，通过期中和期末两个阶段的功能升级与差异对比，使你能感受到这些差异对于使用方体验和服务端压力的改善，从而可以更深刻地理解和掌握前面课程中相应的理论点。</p>
<h2 id="小结">小结</h2>
<p>今天的期末实战，我们主要是针对期中实战中IM系统设计的功能，来进行优化改造。</p>
<p>比如，<strong>使用基于WebSocket的长连接</strong>，代替基于HTTP的短轮询，来提升消息的实时性，并增加了<strong>应用层心跳、ACK机制</strong>等新功能。</p>
<p>通过这次核心代码的讲解，是想让你能理论结合实际地去理解前面课程讲到的，IM系统设计中最重要的部分功能，也希望你能自己尝试去动手写一写。当然，你也可以基于已有代码，去增加一些之前课程中有讲到，但是示例代码中没有实现的功能，比如离线消息、群聊等。</p>
<p>最后再给你留一个思考题：<strong>ACK机制的实现中，如果尝试多次下推之后仍然没有成功，服务端后续应该进行哪些处理呢？</strong></p>
<p>以上就是今天课程的内容，欢迎你给我留言，我们可以在留言区一起讨论，感谢你的收听，我们下期再见。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#2f434343161b1e1e1f186f48424e4643014c4042" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9358f489dc2007f9',t:'MTc0NTUzMjg4My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="03  认证体系：如何深入理解 Spring Security 用户认证机制？" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>03  认证体系：如何深入理解 Spring Security 用户认证机制？ </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%20Spring%20Security%ef%bc%8c%e4%b8%ba%e4%bd%a0%e7%9a%84%e5%ba%94%e7%94%a8%e5%ae%89%e5%85%a8%e4%b8%8e%e8%81%8c%e4%b8%9a%e4%b9%8b%e8%b7%af%e4%bf%9d%e9%a9%be%e6%8a%a4%e8%88%aa.md.html" id="00 开篇词  Spring Security，为你的应用安全与职业之路保驾护航.md.html">00 开篇词  Spring Security，为你的应用安全与职业之路保驾护航.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/01%20%20%e9%a1%b6%e7%ba%a7%e6%a1%86%e6%9e%b6%ef%bc%9aSpring%20Security%20%e6%98%af%e4%b8%80%e6%ac%be%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7%e6%a1%86%e6%9e%b6%ef%bc%9f.md.html" id="01  顶级框架：Spring Security 是一款什么样的安全性框架？.md.html">01  顶级框架：Spring Security 是一款什么样的安全性框架？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/02%20%20%e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%ef%bc%9a%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%20Spring%20Security%20%e6%9e%84%e5%bb%ba%e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%e4%bd%93%e7%b3%bb%ef%bc%9f.md.html" id="02  用户认证：如何使用 Spring Security 构建用户认证体系？.md.html">02  用户认证：如何使用 Spring Security 构建用户认证体系？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/03%20%20%e8%ae%a4%e8%af%81%e4%bd%93%e7%b3%bb%ef%bc%9a%e5%a6%82%e4%bd%95%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Spring%20Security%20%e7%94%a8%e6%88%b7%e8%ae%a4%e8%af%81%e6%9c%ba%e5%88%b6%ef%bc%9f.md.html" id="03  认证体系：如何深入理解 Spring Security 用户认证机制？.md.html">03  认证体系：如何深入理解 Spring Security 用户认证机制？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/04%20%20%e5%af%86%e7%a0%81%e5%ae%89%e5%85%a8%ef%bc%9aSpring%20Security%20%e4%b8%ad%e5%8c%85%e5%90%ab%e5%93%aa%e4%ba%9b%e5%8a%a0%e8%a7%a3%e5%af%86%e6%8a%80%e6%9c%af%ef%bc%9f.md.html" id="04  密码安全：Spring Security 中包含哪些加解密技术？.md.html">04  密码安全：Spring Security 中包含哪些加解密技术？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/05%20%20%e8%ae%bf%e9%97%ae%e6%8e%88%e6%9d%83%ef%bc%9a%e5%a6%82%e4%bd%95%e5%af%b9%e8%af%b7%e6%b1%82%e7%9a%84%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae%e8%bf%87%e7%a8%8b%e8%bf%9b%e8%a1%8c%e6%9c%89%e6%95%88%e9%85%8d%e7%bd%ae%ef%bc%9f.md.html" id="05  访问授权：如何对请求的安全访问过程进行有效配置？.md.html">05  访问授权：如何对请求的安全访问过程进行有效配置？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/06%20%20%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86%ef%bc%9a%e5%a6%82%e4%bd%95%e5%89%96%e6%9e%90%20Spring%20Security%20%e7%9a%84%e6%8e%88%e6%9d%83%e5%8e%9f%e7%90%86%ef%bc%9f.md.html" id="06  权限管理：如何剖析 Spring Security 的授权原理？.md.html">06  权限管理：如何剖析 Spring Security 的授权原理？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/07%20%20%e6%a1%88%e4%be%8b%e5%ae%9e%e6%88%98%ef%bc%9a%e4%bd%bf%e7%94%a8%20Spring%20Security%20%e5%9f%ba%e7%a1%80%e5%8a%9f%e8%83%bd%e4%bf%9d%e6%8a%a4%20Web%20%e5%ba%94%e7%94%a8.md.html" id="07  案例实战：使用 Spring Security 基础功能保护 Web 应用.md.html">07  案例实战：使用 Spring Security 基础功能保护 Web 应用.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/08%20%20%e7%ae%a1%e9%81%93%e8%bf%87%e6%bb%a4%ef%bc%9a%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e%20Spring%20Security%20%e8%bf%87%e6%bb%a4%e5%99%a8%e6%89%a9%e5%b1%95%e5%ae%89%e5%85%a8%e6%80%a7%ef%bc%9f.md.html" id="08  管道过滤：如何基于 Spring Security 过滤器扩展安全性？.md.html">08  管道过滤：如何基于 Spring Security 过滤器扩展安全性？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/09%20%20%e6%94%bb%e5%87%bb%e5%ba%94%e5%af%b9%ef%bc%9a%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%20CSRF%20%e4%bf%9d%e6%8a%a4%e5%92%8c%e8%b7%a8%e5%9f%9f%20CORS%ef%bc%9f.md.html" id="09  攻击应对：如何实现 CSRF 保护和跨域 CORS？.md.html">09  攻击应对：如何实现 CSRF 保护和跨域 CORS？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/10%20%20%e5%85%a8%e5%b1%80%e6%96%b9%e6%b3%95%ef%bc%9a%e5%a6%82%e4%bd%95%e7%a1%ae%e4%bf%9d%e6%96%b9%e6%b3%95%e7%ba%a7%e5%88%ab%e7%9a%84%e5%ae%89%e5%85%a8%e8%ae%bf%e9%97%ae%ef%bc%9f.md.html" id="10  全局方法：如何确保方法级别的安全访问？.md.html">10  全局方法：如何确保方法级别的安全访问？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/11%20%20%e6%a1%88%e4%be%8b%e5%ae%9e%e6%88%98%ef%bc%9a%e4%bd%bf%e7%94%a8%20Spring%20Security%20%e9%ab%98%e7%ba%a7%e4%b8%bb%e9%a2%98%e4%bf%9d%e6%8a%a4%20Web%20%e5%ba%94%e7%94%a8.md.html" id="11  案例实战：使用 Spring Security 高级主题保护 Web 应用.md.html">11  案例实战：使用 Spring Security 高级主题保护 Web 应用.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/12%20%20%e5%bc%80%e6%94%be%e5%8d%8f%e8%ae%ae%ef%bc%9aOAuth2%20%e5%8d%8f%e8%ae%ae%e8%a7%a3%e5%86%b3%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%ef%bc%9f.md.html" id="12  开放协议：OAuth2 协议解决的是什么问题？.md.html">12  开放协议：OAuth2 协议解决的是什么问题？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/13%20%20%e6%8e%88%e6%9d%83%e4%bd%93%e7%b3%bb%ef%bc%9a%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%ba%20OAuth2%20%e6%8e%88%e6%9d%83%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%9f.md.html" id="13  授权体系：如何构建 OAuth2 授权服务器？.md.html">13  授权体系：如何构建 OAuth2 授权服务器？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/14%20%20%e8%b5%84%e6%ba%90%e4%bf%9d%e6%8a%a4%ef%bc%9a%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e%20OAuth2%20%e5%8d%8f%e8%ae%ae%e9%85%8d%e7%bd%ae%e6%8e%88%e6%9d%83%e8%bf%87%e7%a8%8b%ef%bc%9f.md.html" id="14  资源保护：如何基于 OAuth2 协议配置授权过程？.md.html">14  资源保护：如何基于 OAuth2 协议配置授权过程？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/15%20%20%e4%bb%a4%e7%89%8c%e6%89%a9%e5%b1%95%ef%bc%9a%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%20JWT%20%e5%ae%9e%e7%8e%b0%e5%ae%9a%e5%88%b6%e5%8c%96%20Token%ef%bc%9f.md.html" id="15  令牌扩展：如何使用 JWT 实现定制化 Token？.md.html">15  令牌扩展：如何使用 JWT 实现定制化 Token？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/16%20%20%e6%a1%88%e4%be%8b%e5%ae%9e%e6%88%98%ef%bc%9a%e5%9f%ba%e4%ba%8e%20Spring%20Security%20%e5%92%8c%20Spring%20Cloud%20%e6%9e%84%e5%bb%ba%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%ae%89%e5%85%a8%e6%9e%b6%e6%9e%84.md.html" id="16  案例实战：基于 Spring Security 和 Spring Cloud 构建微服务安全架构.md.html">16  案例实战：基于 Spring Security 和 Spring Cloud 构建微服务安全架构.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/17%20%20%e6%a1%88%e4%be%8b%e5%ae%9e%e6%88%98%ef%bc%9a%e5%9f%ba%e4%ba%8e%20Spring%20Security%20%e5%92%8c%20OAuth2%20%e5%ae%9e%e7%8e%b0%e5%8d%95%e7%82%b9%e7%99%bb%e5%bd%95.md.html" id="17  案例实战：基于 Spring Security 和 OAuth2 实现单点登录.md.html">17  案例实战：基于 Spring Security 和 OAuth2 实现单点登录.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/18%20%20%e6%8a%80%e6%9c%af%e8%b6%8b%e5%8a%bf%ef%bc%9a%e5%a6%82%e4%bd%95%e4%b8%ba%20Spring%20Security%20%e6%b7%bb%e5%8a%a0%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%89%b9%e6%80%a7%ef%bc%9f.md.html" id="18  技术趋势：如何为 Spring Security 添加响应式编程特性？.md.html">18  技术趋势：如何为 Spring Security 添加响应式编程特性？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/19%20%20%e6%b5%8b%e8%af%95%e9%a9%b1%e5%8a%a8%ef%bc%9a%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e%20Spring%20Security%20%e6%b5%8b%e8%af%95%e7%b3%bb%e7%bb%9f%e5%ae%89%e5%85%a8%e6%80%a7%ef%bc%9f.md.html" id="19  测试驱动：如何基于 Spring Security 测试系统安全性？.md.html">19  测试驱动：如何基于 Spring Security 测试系统安全性？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Spring%20Security%20%e8%af%a6%e8%a7%a3%e4%b8%8e%e5%ae%9e%e6%93%8d/20%20%e7%bb%93%e6%9d%9f%e8%af%ad%20%20%e4%bb%a5%e7%bb%88%e4%b8%ba%e5%a7%8b%ef%bc%8cSpring%20Security%20%e7%9a%84%e5%ad%a6%e4%b9%a0%e6%80%bb%e7%bb%93.md.html" id="20 结束语  以终为始，Spring Security 的学习总结.md.html">20 结束语  以终为始，Spring Security 的学习总结.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="03  认证体系：如何深入理解 Spring Security 用户认证机制？" id="title">03  认证体系：如何深入理解 Spring Security 用户认证机制？</h1>
<div><p>上一讲，我们给出了 Spring Security 中实现用户认证的系统方法，可以发现整个实现过程还是比较简单的，开发人员只需要通过一些配置方法就能完成复杂的处理逻辑。这种简单性得益于 Spring Security 对用户认证过程的提炼和抽象。今天我们就围绕这个话题展开讨论，继续探究 Spring Security 中的用户和认证对象，以及如何基于这些对象完成定制化的用户认证方案。</p>
<h3 id="spring-security-中的用户和认证">Spring Security 中的用户和认证</h3>
<p>Spring Security 中的认证过程由一组核心对象组成，大致可以分成两大类，一类是<strong>用户对象</strong>，一类是<strong>认证对象</strong>，下面我们来具体了解一下。</p>
<h4 id="spring-security-中的用户对象">Spring Security 中的用户对象</h4>
<p>Spring Security 中的用户对象用来描述用户并完成对用户信息的管理，涉及<strong>UserDetails、GrantedAuthority、UserDetailsService 和 UserDetailsManager</strong>这四个核心对象。</p>
<ul>
<li>UserDetails：描述 Spring Security 中的用户。</li>
<li>GrantedAuthority：定义用户的操作权限。</li>
<li>UserDetailsService：定义了对 UserDetails 的查询操作。</li>
<li>UserDetailsManager：扩展 UserDetailsService，添加了创建用户、修改用户密码等功能。</li>
</ul>
<p>这四个对象之间的关联关系如下图所示，显然，对于由 UserDetails 对象所描述的一个用户而言，它应该具有 1 个或多个能够执行的 GrantedAuthority：</p>
<p><img alt="Drawing 0.png" src="assets/CioPOWC5_ryAZ3qSAABXNOe10bU172.png"/></p>
<p>Spring Security 中的四大核心用户对象</p>
<p>结合上图，我们先来看承载用户详细信息的 UserDetails 接口，如下所示：</p>
<pre><code>public interface UserDetails extends Serializable {

 

    //获取该用户的权限信息

    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();

 

    //获取密码

	String getPassword();

	 

	//获取用户名

    String getUsername();

 

	//判断该账户是否已失效

    boolean isAccountNonExpired();

 

    //判断该账户是否已被锁定

    boolean isAccountNonLocked();

 

    //判断该账户的凭证信息是否已失效

    boolean isCredentialsNonExpired();

 

    //判断该用户是否可用

    boolean isEnabled();

}
</code></pre>
<p>通过 UserDetails，我们可以获取用户相关的基础信息，并判断其当前状态。同时，我们也可以看到 UserDetails 中保存着一组 GrantedAuthority 对象。而 GrantedAuthority 指定了一个方法用来获取权限信息，如下所示：</p>
<pre><code>public interface GrantedAuthority extends Serializable {

    //获取权限信息

    String getAuthority();

}
</code></pre>
<p>UserDetails 存在一个子接口 MutableUserDetails，从命名上不难看出后者是一个可变的 UserDetails，而<strong>可变的内容就是密码</strong>。MutableUserDetails 接口的定义如下所示：</p>
<pre><code>interface MutableUserDetails extends UserDetails {

    //设置密码

    void setPassword(String password);

}
</code></pre>
<p>如果我们想要在应用程序中创建一个 UserDetails 对象，可以使用如下所示的链式语法：</p>
<pre><code>UserDetails user = User.withUsername("jianxiang") 

  .password("123456") 

  .authorities("read", "write") 

  .accountExpired(false) 

  .disabled(true) 

  .build();
</code></pre>
<p>Spring Security 还专门提供了一个 UserBuilder 对象来辅助构建 UserDetails，使用方式也类似：</p>
<pre><code>User.UserBuilder builder = 

	User.withUsername("jianxiang");

 

UserDetails user = builder

  .password("12345") 

  .authorities("read", "write")

  .accountExpired(false) 

  .disabled(true) 

  .build();
</code></pre>
<p>在 Spring Security 中，针对 UserDetails 专门提供了一个 UserDetailsService，该接口用来管理 UserDetails，定义如下：</p>
<pre><code>public interface UserDetailsService {

 

    //根据用户名获取用户信息

    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;

}
</code></pre>
<p>而 UserDetailsManager 继承了 UserDetailsService，并提供了一批针对 UserDetails 的操作接口，如下所示：</p>
<pre><code>public interface UserDetailsManager extends UserDetailsService {

    //创建用户

    void createUser(UserDetails user);

 

    //更新用户

    void updateUser(UserDetails user);

 

    //删除用户

    void deleteUser(String username);

 

    //修改密码

    void changePassword(String oldPassword, String newPassword);

 

    //判断指定用户名的用户是否存在

    boolean userExists(String username);

}
</code></pre>
<p>这样，几个核心用户对象之间的关联关系就很清楚了，接下来我们需要进一步明确具体的实现过程。</p>
<p>我们来看 UserDetailsManager 的两个实现类，一个是<strong>基于内存存储</strong>的 InMemoryUserDetailsManager，一个是<strong>基于关系型数据库存储</strong>的 JdbcUserDetailsManager。</p>
<p>这里，我们以 JdbcMemoryUserDetailsManager 为例展开分析，它的 createUser 方法如下所示：</p>
<pre><code>public void createUser(final UserDetails user) {

        validateUserDetails(user);

 

        getJdbcTemplate().update(createUserSql, ps -&gt; {

             ps.setString(1, user.getUsername());

             ps.setString(2, user.getPassword());

             ps.setBoolean(3, user.isEnabled());

 

             int paramCount = ps.getParameterMetaData().getParameterCount();

             if (paramCount &gt; 3) {

                 ps.setBoolean(4, !user.isAccountNonLocked());

                 ps.setBoolean(5, !user.isAccountNonExpired());

                 ps.setBoolean(6, !user.isCredentialsNonExpired());

             }

        });

 

        if (getEnableAuthorities()) {

             insertUserAuthorities(user);

        }

}
</code></pre>
<p>可以看到，这里直接使用了 Spring 框架中的 JdbcTemplate 模板工具类实现了数据的插入，同时完成了 GrantedAuthority 的存储。</p>
<p>UserDetailsManager 是一条相对独立的代码线，为了完成用户信息的配置，还存在另一条代码支线，即 UserDetailsManagerConfigurer。该类维护了一个 UserDetails 列表，并提供了一组 withUser 方法完成用户信息的初始化，如下所示：</p>
<pre><code>private final List&lt;UserDetails&gt; users = new ArrayList&lt;&gt;();

 

public final C withUser(UserDetails userDetails) {

        this.users.add(userDetails);

        return (C) this;

}
</code></pre>
<p>而 withUser 方法返回的是一个 UserDetailsBuilder 对象，该对象内部使用了前面介绍的 UserBuilder 对象，因此可以实现类似 .withUser(“spring_user”).password(“password1”).roles(“USER”) 这样的链式语法，完成用户信息的设置。这也是上一讲中，我们在介绍基于内存的用户信息存储方案时使用的方法。</p>
<p>作为总结，我们也梳理了 Spring Security 中与用户对象相关的一大批实现类，它们之间的关系如下图所示：</p>
<p><img alt="Drawing 1.png" src="assets/Cgp9HWC5_sqAC7SUAACLftd0SYc321.png"/></p>
<p>Spring Security 中用户对象相关类结构图</p>
<h4 id="spring-security-中的认证对象">Spring Security 中的认证对象</h4>
<p>有了用户对象，我们就可以讨论具体的认证过程了，首先来看认证对象 Authentication，如下所示：</p>
<pre><code>public interface Authentication extends Principal, Serializable {

    //安全主体具有的权限

    Collection&lt;? extends GrantedAuthority&gt; getAuthorities();

 

	//证明主体有效性的凭证

    Object getCredentials();

 

    //认证请求的明细信息

    Object getDetails();

 

    //主体的标识信息

    Object getPrincipal();

 

    //认证是否通过

    boolean isAuthenticated();

 

    //设置认证结果

    void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;

}
</code></pre>
<p>认证对象代表认证请求本身，并保存该请求访问应用程序过程中涉及的各个实体的详细信息。在安全领域，请求访问该应用程序的用户通常被称为<strong>主体</strong>（Principal），在 JDK 中存在一个同名的接口，而 Authentication 扩展了这个接口。</p>
<p>显然，Authentication 只代表了认证请求本身，而具体执行认证的过程和逻辑需要由专门的组件来负责，这个组件就是 AuthenticationProvider，定义如下：</p>
<pre><code>public interface AuthenticationProvider {

 

    //执行认证，返回认证结果

    Authentication authenticate(Authentication authentication)

             throws AuthenticationException;

 

    //判断是否支持当前的认证对象

    boolean supports(Class&lt;?&gt; authentication);

}
</code></pre>
<p>讲到这里，你可能会认为 Spring Security 是直接使用 AuthenticationProvider 接口完成用户认证的，其实不然。如果你翻阅 Spring Security 的源码，会发现它<strong>使用了 AuthenticationManager 接口来代理 AuthenticationProvider 提供的认证功能</strong>。这里，我们以 InMemoryUserDetailsManager 中的 changePassword 为例，分析用户认证的执行过程（为了展示简洁，部分代码做了裁剪）：</p>
<pre><code>public void changePassword(String oldPassword, String newPassword) {

        Authentication currentUser = SecurityContextHolder.getContext()

                 .getAuthentication();

 

        if (currentUser == null) {

             throw new AccessDeniedException(

                     "Can't change password as no Authentication object found in context "

                             + "for current user.");

        }

 

        String username = currentUser.getName();

 

        if (authenticationManager != null) {

 

             authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(

                     username, oldPassword));

        }

        else {

             …

        }

 

        MutableUserDetails user = users.get(username);

 

        if (user == null) {

             throw new IllegalStateException("Current user doesn't exist in database.");

        }

 

        user.setPassword(newPassword);

}
</code></pre>
<p>可以看到，这里使用了 AuthenticationManager 而不是 AuthenticationProvider 中的 authenticate() 方法来执行认证。同时，我们也注意到这里出现了 UsernamePasswordAuthenticationToken 类，这就是 Authentication 接口的一个具体实现类，用来<strong>存储用户认证所需的用户名和密码信息</strong>。</p>
<p>同样作为总结，我们也梳理了 Spring Security 中与认证对象相关的一大批核心类，它们之间的关系如下所示：</p>
<p><img alt="Drawing 2.png" src="assets/CioPOWC5_tmAEUuLAABqhhFbRIw821.png"/></p>
<p>Spring Security 中认证的对象相关类结构图</p>
<h3 id="实现定制化用户认证方案">实现定制化用户认证方案</h3>
<p>通过前面的分析，我们明确了用户信息存储的实现过程实际上是可以定制化的。Spring Security 所做的工作只是把常见的、符合一般业务场景的实现方式嵌入到了框架中。如果有特殊的场景，开发人员完全可以实现自定义的用户信息存储方案。</p>
<p>现在，我们已经知道 UserDetails 接口代表着用户详细信息，而负责对 UserDetails 进行各种操作的则是 UserDetailsService 接口。因此，<strong>实现定制化用户认证方案主要就是实现 UserDetails 和 UserDetailsService 这两个接口</strong>。</p>
<h4 id="扩展-userdetails">扩展 UserDetails</h4>
<p>扩展 UserDetails 的方法就是直接实现该接口，例如我们可以构建如下所示的 SpringUser 类：</p>
<pre><code>public class SpringUser implements UserDetails {

 

    private static final long serialVersionUID = 1L;

    private Long id;  

    private final String username;

    private final String password;

    private final String phoneNumber;

    //省略 getter/setter

  

    @Override

    public String getUsername() {

        return username;

    }

    

    @Override

    public String getPassword() {

        return password;

    }

 

    @Override

    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {

         return Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"));

    }

    

  @Override

  public boolean isAccountNonExpired() {

      return true;

  }

 

  @Override

  public boolean isAccountNonLocked() {

      return true;

  }

 

  @Override

  public boolean isCredentialsNonExpired() {

      return true;

  }

 

  @Override

  public boolean isEnabled() {

      return true;

  }

}
</code></pre>
<p>显然，这里使用了一种最简单的方法来满足 UserDetails 中各个接口的实现需求。一旦我们构建了这样一个 SpringUser 类，就可以创建对应的表结构存储类中定义的字段。同时，我们也可以基于 Spring Data JPA 来创建一个自定义的 Repository，如下所示：</p>
<pre><code>public interface SpringUserRepository extends CrudRepository&lt;SpringUser, Long&gt; {

    SpringUser findByUsername(String username);  

}
</code></pre>
<p>SpringUserRepository 扩展了 Spring Data 中的 CrudRepository 接口，并提供了一个方法名衍生查询 findByUsername。</p>
<h4 id="扩展-userdetailsservice">扩展 UserDetailsService</h4>
<p>接着，我们来实现 UserDetailsService 接口，如下所示：</p>
<pre><code>@Service

public class SpringUserDetailsService 

        implements UserDetailsService {

	 

  @Autowired

  private SpringUserRepository repository;

 

  @Override

  public UserDetails loadUserByUsername(String username)

      throws UsernameNotFoundException {

 

    SpringUser user = repository.findByUsername(username);

    if (user != null) {

      return user;

    }

    throw new UsernameNotFoundException(

                    "SpringUser '" + username + "' not found");

  }

}
</code></pre>
<p>我们知道 UserDetailsService 接口只有一个 loadUserByUsername 方法需要实现。因此，我们基于 SpringUserRepository 的 findByUsername 方法，根据用户名从数据库中查询数据。</p>
<h4 id="扩展-authenticationprovider">扩展 AuthenticationProvider</h4>
<p>扩展 AuthenticationProvider 的过程就是提供一个自定义的 AuthenticationProvider 实现类。这里我们以最常见的用户名密码认证为例，梳理自定义认证过程所需要实现的步骤，如下所示：</p>
<p><img alt="Drawing 3.png" src="assets/CioPOWC5_uiAEATKAACWyEa75HA969.png"/></p>
<p>自定义 AuthenticationProvider 的实现流程图</p>
<p>上图中的流程并不复杂，首先我们需要通过 UserDetailsService 获取一个 UserDetails 对象，然后根据该对象中的密码与认证请求中的密码进行匹配，如果一致则认证成功，反之抛出一个 BadCredentialsException 异常。示例代码如下所示：</p>
<pre><code>@Component

public class SpringAuthenticationProvider implements AuthenticationProvider {

 

    @Autowired

    private UserDetailsService userDetailsService;

 

    @Autowired

    private PasswordEncoder passwordEncoder;

 

    @Override

    public Authentication authenticate(Authentication authentication) {

        String username = authentication.getName();

        String password = authentication.getCredentials().toString();

 

        UserDetails user = userDetailsService.loadUserByUsername(username);

        if (passwordEncoder.matches(password, user.getPassword())) {

            return new UsernamePasswordAuthenticationToken(username, password, u.getAuthorities());

        } else {

            throw new BadCredentialsException("The username or password is wrong!");

        }

    }

 

    @Override

    public boolean supports(Class&lt;?&gt; authenticationType) {

        return authenticationType.equals(UsernamePasswordAuthenticationToken.class);

    }

}
</code></pre>
<p>这里我们同样使用了 UsernamePasswordAuthenticationToken 来传递用户名和密码，并使用一个 PasswordEncoder 对象校验密码。</p>
<h4 id="整合定制化配置">整合定制化配置</h4>
<p>最后，我们创建一个 SpringSecurityConfig 类，该类继承了 WebSecurityConfigurerAdapter 配置类。这次，我们将使用自定义的 SpringUserDetailsService 来完成用户信息的存储和查询，需要对原有配置策略做一些调整。调整之后的完整 SpringSecurityConfig 类如下所示：</p>
<pre><code>@Configuration

public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {

 

    @Autowired

    private UserDetailsService springUserDetailsService;

 

    @Autowired

    private AuthenticationProvider springAuthenticationProvider;

 

 

    @Override

    protected void configure(AuthenticationManagerBuilder auth) throws Exception {

 

     auth.userDetailsService(springUserDetailsService)

	.authenticationProvider(springAuthenticationProvider);

	}

}
</code></pre>
<p>这里我们注入了 SpringUserDetailsService 和 SpringAuthenticationProvider，并将其添加到 AuthenticationManagerBuilder 中，这样 AuthenticationManagerBuilder 将基于这个自定义的 SpringUserDetailsService 完成 UserDetails 的创建和管理，并基于自定义的 SpringAuthenticationProvider 完成用户认证。</p>
<h3 id="小结与预告">小结与预告</h3>
<p>这一讲我们基于 Spring Security 提供的用户认证功能分析了其背后的实现过程。我们的切入点在于分析与用户和认证相关的各个核心类，并梳理它们之间的交互过程。另一方面，我们还通过扩展 UserDetailsService 和 AuthenticationProvider 接口的方式来实现定制化的用户认证方案。</p>
<p>本讲内容总结如下：</p>
<p><img alt="Drawing 4.png" src="assets/CioPOWC5_wKAct0XAACvS5HbogQ525.png"/></p>
<p>最后给你留一道思考题：基于 Spring Security，如何根据用户名和密码实现一套定制化的用户认证解决方案？欢迎在留言区和我分享你的想法。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#c3afafaffaf7f2f2f3f483a4aea2aaafeda0acae" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93586d633e2d8238',t:'MTc0NTUyNzM0Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
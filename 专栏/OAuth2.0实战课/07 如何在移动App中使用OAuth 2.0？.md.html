<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="07 如何在移动App中使用OAuth 2.0？" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>07 如何在移动App中使用OAuth 2.0？ </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6OAuth%202.0%ef%bc%9f.md.html" id="00 开篇词 为什么要学OAuth 2.0？.md.html">00 开篇词 为什么要学OAuth 2.0？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/01%20OAuth%202.0%e6%98%af%e8%a6%81%e9%80%9a%e8%bf%87%e4%bb%80%e4%b9%88%e6%96%b9%e5%bc%8f%e8%a7%a3%e5%86%b3%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%ef%bc%9f.md.html" id="01 OAuth 2.0是要通过什么方式解决什么问题？.md.html">01 OAuth 2.0是要通过什么方式解决什么问题？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/02%20%e6%8e%88%e6%9d%83%e7%a0%81%e8%ae%b8%e5%8f%af%e7%b1%bb%e5%9e%8b%e4%b8%ad%ef%bc%8c%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%80%e5%ae%9a%e8%a6%81%e6%9c%89%e6%8e%88%e6%9d%83%e7%a0%81%ef%bc%9f.md.html" id="02 授权码许可类型中，为什么一定要有授权码？.md.html">02 授权码许可类型中，为什么一定要有授权码？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/03%20%e6%8e%88%e6%9d%83%e6%9c%8d%e5%8a%a1%ef%bc%9a%e6%8e%88%e6%9d%83%e7%a0%81%e5%92%8c%e8%ae%bf%e9%97%ae%e4%bb%a4%e7%89%8c%e7%9a%84%e9%a2%81%e5%8f%91%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84%ef%bc%9f.md.html" id="03 授权服务：授权码和访问令牌的颁发流程是怎样的？.md.html">03 授权服务：授权码和访问令牌的颁发流程是怎样的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/04%20%e5%9c%a8OAuth%202.0%e4%b8%ad%ef%bc%8c%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8JWT%e7%bb%93%e6%9e%84%e5%8c%96%e4%bb%a4%e7%89%8c%ef%bc%9f.md.html" id="04 在OAuth 2.0中，如何使用JWT结构化令牌？.md.html">04 在OAuth 2.0中，如何使用JWT结构化令牌？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/05%20%e5%a6%82%e4%bd%95%e5%ae%89%e5%85%a8%e3%80%81%e5%bf%ab%e9%80%9f%e5%9c%b0%e6%8e%a5%e5%85%a5OAuth%202.0%ef%bc%9f.md.html" id="05 如何安全、快速地接入OAuth 2.0？.md.html">05 如何安全、快速地接入OAuth 2.0？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/06%20%e9%99%a4%e4%ba%86%e6%8e%88%e6%9d%83%e7%a0%81%e8%ae%b8%e5%8f%af%e7%b1%bb%e5%9e%8b%ef%bc%8cOAuth%202.0%e8%bf%98%e6%94%af%e6%8c%81%e4%bb%80%e4%b9%88%e6%8e%88%e6%9d%83%e6%b5%81%e7%a8%8b%ef%bc%9f.md.html" id="06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？.md.html">06 除了授权码许可类型，OAuth 2.0还支持什么授权流程？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/07%20%e5%a6%82%e4%bd%95%e5%9c%a8%e7%a7%bb%e5%8a%a8App%e4%b8%ad%e4%bd%bf%e7%94%a8OAuth%202.0%ef%bc%9f.md.html" id="07 如何在移动App中使用OAuth 2.0？.md.html">07 如何在移动App中使用OAuth 2.0？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/08%20%e5%ae%9e%e8%b7%b5OAuth%202.0%e6%97%b6%ef%bc%8c%e4%bd%bf%e7%94%a8%e4%b8%8d%e5%bd%93%e5%8f%af%e8%83%bd%e4%bc%9a%e5%af%bc%e8%87%b4%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%bc%8f%e6%b4%9e%ef%bc%9f.md.html" id="08 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞？.md.html">08 实践OAuth 2.0时，使用不当可能会导致哪些安全漏洞？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/09%20%e5%ae%9e%e6%88%98%ef%bc%9a%e5%88%a9%e7%94%a8OAuth%202.0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aaOpenID%20Connect%e7%94%a8%e6%88%b7%e8%ba%ab%e4%bb%bd%e8%ae%a4%e8%af%81%e5%8d%8f%e8%ae%ae..md" id="09 实战：利用OAuth 2.0实现一个OpenID Connect用户身份认证协议..md">09 实战：利用OAuth 2.0实现一个OpenID Connect用户身份认证协议..md</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/10%20%e4%b8%b2%e8%ae%b2%ef%bc%9aOAuth%202.0%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e4%b8%8e%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98.md.html" id="10 串讲：OAuth 2.0的工作流程与安全问题.md.html">10 串讲：OAuth 2.0的工作流程与安全问题.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/11%20%e5%ae%9e%e6%88%98%e6%a1%88%e4%be%8b%ef%bc%9a%e4%bd%bf%e7%94%a8Spring%20Security%e6%90%ad%e5%bb%ba%e4%b8%80%e5%a5%97%e5%9f%ba%e4%ba%8eJWT%e7%9a%84OAuth%202.0%e6%9e%b6%e6%9e%84.md.html" id="11 实战案例：使用Spring Security搭建一套基于JWT的OAuth 2.0架构.md.html">11 实战案例：使用Spring Security搭建一套基于JWT的OAuth 2.0架构.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/12%20%e6%9e%b6%e6%9e%84%e6%a1%88%e4%be%8b%ef%bc%9a%e5%9f%ba%e4%ba%8eOAuth%202.0_JWT%e7%9a%84%e5%be%ae%e6%9c%8d%e5%8a%a1%e5%8f%82%e8%80%83%e6%9e%b6%e6%9e%84.md.html" id="12 架构案例：基于OAuth 2.0_JWT的微服务参考架构.md.html">12 架构案例：基于OAuth 2.0_JWT的微服务参考架构.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/13%20%e5%90%84%e5%a4%a7%e5%bc%80%e6%94%be%e5%b9%b3%e5%8f%b0%e6%98%af%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8OAuth%202.0%e7%9a%84%ef%bc%9f.md.html" id="13 各大开放平台是如何使用OAuth 2.0的？.md.html">13 各大开放平台是如何使用OAuth 2.0的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/14%20%e6%9f%a5%e6%bc%8f%e8%a1%a5%e7%bc%ba%ef%bc%9aOAuth%202.0%20%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e7%ad%94%e7%96%91.md.html" id="14 查漏补缺：OAuth 2.0 常见问题答疑.md.html">14 查漏补缺：OAuth 2.0 常见问题答疑.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/OAuth2.0%e5%ae%9e%e6%88%98%e8%af%be/%e7%bb%93%e6%9d%9f%e8%af%ad%20%e6%8a%8a%e5%ad%a6%e4%b9%a0%e5%bd%93%e6%88%90%e4%b8%80%e7%a7%8d%e4%b9%a0%e6%83%af.md.html" id="结束语 把学习当成一种习惯.md.html">结束语 把学习当成一种习惯.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="07 如何在移动App中使用OAuth 2.0？" id="title">07 如何在移动App中使用OAuth 2.0？</h1>
<div><p>　　你好，我是王新栋。</p>
<p>　　在前面几讲中，我都是基于 Web 应用的场景来讲解的 OAuth 2.0。除了 Web 应用外，现实环境中还有非常多的移动 App。那么，在移动 App 中，能不能使用 OAuth 2.0 ，又该如何使用 OAuth 2.0 呢？</p>
<p>　　没错，OAuth 2.0 最初的应用场景确实是 Web 应用，但是它的伟大之处就在于，它把自己的核心协议定位成了一个框架而不是单个的协议。这样做的好处是，我们可以基于这个基本的框架协议，在一些特定的领域进行扩展。</p>
<p>　　因此，到了桌面或者移动的场景下，OAuth 2.0 的协议一样适用。考虑到授权码许可是最完备、最安全的许可类型，所以我在讲移动 App 如何使用 OAuth 2.0 的时候，依然会用授权码许可来讲解，毕竟“要用就用最好的”。</p>
<p>　　当我们开发一款移动 App 的时候，可以选择没有 Server 端的 “纯 App” 架构，比如这款 App 不需要跟自己的 Server 端通信，或者可以调用其它开放的 HTTP 接口；当然也可以选择有服务端的架构，比如这款 App 还想把用户的操作日志记录下来并保存到 Server 端的数据库中。</p>
<p>　　那总结下来呢，移动 App 可以分为两类，一类是没有 Server 端的 App 应用，一类是有 Server 端的 App 应用。</p>
<p>　　<img alt="" src="assets/4c034e019467aafae511f16055b57b99-20220724223141-dtfvaa2.png"/></p>
<p>　　图1 两类移动App</p>
<p>　　这两类 App 在使用 OAuth 2.0 时的最大区别，在于获取访问令牌的方式：</p>
<p>　　如果有 Server 端，就建议通过 Server 端和授权服务做交互来换取访问令牌；</p>
<p>　　如果没有 Server 端，那么只能通过前端通信来跟授权服务做交互，比如在上一讲中提到的隐式许可授权类型。当然，这种方式的安全性就降低了很多。</p>
<p>　　有些时候，我们可能觉得自己开发一个 App 不需要一个 Server 端。那好，就让我们先来看看没有 Server 端的 App 应用如何使用授权码许可类型。</p>
<h2 id="没有-server-端的-app">没有 Server 端的 App</h2>
<p>　　在一个没有 Server 端支持的纯 App 应用中，我们首先想到的是，如何可以像 Web 服务那样，让请求和响应“来去自如”呢。</p>
<p>　　你可能会想，我是不是可以将一个“迷你”的 Web 服务器嵌入到 App 里面去，这样不就可以像 Web 应用那样来使用 OAuth 2.0 了么？确实，这是行得通的，而且已经有 App 这样做了。</p>
<p>　　这样的 App 通过监听运行在 localhost 上的 Web 服务器 URI，就可以做到跟普通的 Web 应用一样的通信机制。但这种方式不是我们这次要讲的重点，如果你想深入了解可以去查些资料。因为当使用这种方式的时候，请求访问令牌时需要的 app_secret 就只能保存在用户本地设备上，而这并不是我们所建议的。</p>
<p>　　到这里，你应该猜到了，问题的关键在于如何保存 app_secret，因为 App 会被安装在成千上万个终端设备上，app_secret 一旦被破解，就将会造成灾难性的后果。这时，有的同学突发奇想，如果不用 app_secret，也能在授权码流程里换回访问令牌 access_token，不就可以了吗？</p>
<p>　　确实可以，但新的问题也来了。在授权码许可类型的流程中，如果没有了 app_secret 这一层的保护，那么通过授权码 code 换取访问令牌的时候，就只有授权码 code 在“冲锋陷阵”了。这时，授权码 code 一旦失窃，就会带来严重的安全问题。那么，我既不使用 app_secret，还要防止授权码 code 失窃，有什么好的方法吗？</p>
<p>　　有，OAuth 2.0 里面就有这样的指导方法。这个方法就是我们将要介绍的 PKCE 协议，全称是 Proof Key for Code Exchange by OAuth Public Clients。</p>
<p>　　在下面的流程图中，为了突出第三方软件使用 PKCE 协议时与授权服务之间的通信过程，我省略了受保护资源服务和资源拥有者的角色：</p>
<p>　　<img alt="" src="assets/66648bff2d955b3d714ce597299fbf52-20220724223141-ucv15u5.png"/></p>
<p>　　图2 使用PKCE协议的流程图</p>
<p>　　我来和你分析下这个流程中的重点。</p>
<p>　　首先，App 自己要生成一个随机的、长度在 43~128 字符之间的、参数为 <strong>code_verifier</strong> 的字符串验证码；接着，我们再利用这个 <strong>code_verifier，</strong><strong>来生成一个被称为“挑战码”的参数</strong><strong>code_challenge</strong>。</p>
<p>　　那怎么生成这个 code_challenge 的值呢？OAuth 2.0 规范里面给出了两种方法，就是看 code_challenge_method 这个参数的值：</p>
<p>　　一种 code_challenge_method=plain，此时 code_verifier 的值就是 code_challenge 的值；</p>
<p>　　另外一种 code_challenge_method=S256，就是将 code_verifier 值进行 ASCII 编码之后再进行哈希，然后再将哈希之后的值进行 BASE64-URL 编码，如下代码所示。</p>
<pre><code class="language-java">　　code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))
</code></pre>
<p>　　好了，我知道有这样两个值，也知道它们的生成方法了，但这两个值跟我们的授权码流程有什么关系呢，又怎么利用它们呢？不用着急，我们接着讲。</p>
<p>　　授权码流程简单概括起来不是有两步吗，第一步是获取授权码 code，第二步是用 app_id+app_secret+code 获取访问令牌 access_token。刚才我们的“梦想”不是设想不使用 app_secret，但同时又能保证授权码流程的安全性么？</p>
<p>　　没错。code_verifier 和 code_challenge 这两个参数，就是来帮我们实现这个“梦想”的。</p>
<p>　　在<strong>第一步获取授权码 code 的时候，我们使用 code_challenge</strong> 参数。需要注意的是，我们要同时将 code_challenge_method 参数也传过去，目的是让授权服务知道生成 code_challenge 值的方法是 plain 还是 S256。</p>
<pre><code class="language-java">　　https:
　　response_type=code&amp;
　　app_id=APP_ID&amp;
　　redirect_uri=REDIRECT_URI&amp;
　　code_challenge=CODE_CHALLENGE&amp;
　　code_challenge_method=S256
</code></pre>
<p>　　在<strong>第二步获取访问令牌的时候，我们使用 code_verifier 参数</strong>，授权服务此时会将 code_verifier 的值进行一次运算。那怎么运算呢？就是上面 code_challenge_method=S256 的这种方式。</p>
<p>　　没错，第一步请求授权码的时候，已经告诉授权服务生成 code_challenge 的方法了。所以，在第二步的过程中，授权服务将运算的值跟第一步接收到的值做比较，如果相同就颁发访问令牌。</p>
<pre><code class="language-java">　　  POST https:
　　  grant_type=authorization_code&amp;
　　  code=AUTH_CODE_HERE&amp;
　　  redirect_uri=REDIRECT_URI&amp;
　　  app_id=APP_ID&amp;
　　  code_verifier=CODE_VERIFIER
</code></pre>
<p>　　现在，你就知道了我们是如何使用 code_verifier 和 code_challenge 这两个参数的了吧。总结一下就是，换取授权码 code 的时候，我们使用 code_challenge 参数值；换取访问令牌的时候，我们使用 code_verifier 参数值。那么，有的同学会继续问了，我们为什么要这样做呢。</p>
<p>　　现在，就让我来和你分析一下。</p>
<p>　　我们的愿望是，没有 Server 端的手机 App，也可以使用授权码许可流程，对吧？app_secret 不能用，因为它只能被存在用户的设备上，我们担心被泄露。</p>
<p>　　那么，在没有了 app_secret 这层保护的前提下，即使我们的授权码 code 被截获，再加上 code_challenge 也同时被截获了，那也没有办法由 code_challenge 逆推出 code_verifier 的值。而恰恰在第二步换取访问令牌的时候，授权服务需要的就是 code_verifier 的值。因此，这也就避免了访问令牌被恶意换取的安全问题。</p>
<p>　　现在，我们可以通过 PKCE 协议的帮助，让没有 Server 端的 App 也能够安全地使用授权码许可类型进行授权了。但是，按照 OAuth 2.0 的规范建议，通过后端通信来换取访问令牌是较为安全的方式。所以呢，在这里，我想跟你探讨的是，我们真的不需要一个 Server 端吗？在做移动应用开发的时候，我们真的从设计上就决定废弃 Server 端了吗？</p>
<h2 id="有-server-端的-app">有 Server 端的 App</h2>
<p>　　如果你开发接入过微信登录，就会在微信的官方文档上看到下面这句话：</p>
<p>　　微信 OAuth 2.0 授权登录目前支持 authorization_code 模式，适用于拥有 Server 端的应用授权。</p>
<p>　　没错，微信的 OAuth 2.0 授权登录，就是建议我们需要一个 Server 端来支持这样的授权接入。</p>
<p>　　那么，有 Server 端支持的 App 又是如何使用 OAuth 2.0 的授权码许可流程的呢？其实，在前面几讲的基础上，我们现在理解这样的场景并不是什么难事儿。</p>
<p>　　<img alt="" src="assets/86d3yy8fa419c94b7e3766fe0a4e3db1-20220724223142-ki4vf5f.png"/></p>
<p>　　图3 微信登录流程图</p>
<p>　　看到这个图，你是不是觉得特别熟悉，跟普通的授权码流程没有区别，仍是两步走的策略：第一步换取授权码 code，第二步通过授权码 code 换取访问令牌 access_token。</p>
<p>　　这里的第三方应用，就是我们作为开发者来开发的应用，包含了移动 App 和 Server 端。我们将其“放大”得到下面这张图：</p>
<p>　　<img alt="" src="assets/564f5b7af360180d270e205df5f9c05e-20220724223141-70tfqai.png"/></p>
<p>　　图4 有Server端的App的授权流程</p>
<p>　　我们从这张“放大”的图中，就会发现有 Server 端的 App 在使用授权码流程的时候，跟普通的 Web 应用几乎没有任何差别。</p>
<p>　　大概流程是：当我们访问第三方 App 的时候，需要用到微信来登录；第三方 App 可以拉起微信的 App，我们会在微信的 App 里面进行登录及授权；微信 Server 端验证成功之后会返回一个授权码 code，通过微信 App 传递给了第三方 App；后面的流程就是我们熟悉的使用授权码 code 和 app_secret，换取访问令牌 access_token 的值了。</p>
<p>　　这次使用 app_secret 的时候，我们是在第三方 App 的 Server 端来使用的，因此安全性上没有任何问题。</p>
<h2 id="总结">总结</h2>
<p>　　今天这一讲，我重点和你讲了两块内容，没有 Server 端的 App 和有 Server 端的 App 分别是如何使用授权码许可类型的。我希望你能够记住以下两点内容。</p>
<p>　　我们使用 OAuth 2.0 协议的目的，就是要起到安全性的作用，但有些时候，因为使用不当反而会造成更大的安全问题，比如将 app_secret 放入 App 中的最基本错误。如果放弃了 app_secret，又是如何让没有 Server 端的 App 安全地使用授权码许可协议呢？针对这种情况，我和你介绍了 PKCE 协议。它是一种在失去 app_secret 保护的时候，防止授权码失窃的解决方案。</p>
<p>　　我们需要思考一下，我们的 App 真的不需要一个 Server 端吗？我建议你在开发移动 App 的时候，尽可能地都要搭建一个 Server 端，因为通过后端通信来传输访问令牌比通过前端通信传输要安全得多。我也举了微信的例子，很多官方的开放平台在提供 OAuth 2.0 服务的时候，都会建议开发者要有一个相应的 Server 端。</p>
<p>　　那么，关于 OAuth 2.0 的使用还有哪些安全方面的防范措施是我们要注意的呢，接下来的一讲中我们会重点跟大家介绍。</p>
<h2 id="思考题">思考题</h2>
<p>　　在移动 App 中，你还能想到有哪些相对安全的方式来使用 OAuth 2.0 吗？</p>
<p>　　欢迎你在留言区分享你的观点，也欢迎你把今天的内容分享给其他朋友，我们一起交流。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#a0cccccc999491919097e0c7cdc1c9cc8ec3cfcd" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9359a65c2c74d6a1',t:'MTc0NTU0MDE2Ny4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>
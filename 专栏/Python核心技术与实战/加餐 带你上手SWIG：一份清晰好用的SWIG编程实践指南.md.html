<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="zh-cn" http-equiv="content-language"/>
<meta content="加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南" name="description"/>
<link href="/static/favicon.png" rel="icon"/>
<title>加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南 </title>
<link href="/static/index.css" rel="stylesheet"/>
<link href="/static/highlight.min.css" rel="stylesheet"/>
<script src="/static/highlight.min.js"></script>
<meta content="Hexo 4.2.0" name="generator"/>
<script data-website-id="83e5d5db-9d06-40e3-b780-cbae722fdf8c" defer="" src="https://umami.lianglianglee.com/script.js"></script>
</head>
<body>
<div class="book-container">
<div class="book-sidebar">
<div class="book-brand">
<a href="/">
<img src="/static/favicon.png"/>
<span>技术文章摘抄</span>
</a>
</div>
<div class="book-menu uncollapsible">
<ul class="uncollapsible">
<li><a class="current-tab" href="/">首页</a></li>
<li><a href="../">上一级</a></li>
</ul>
<ul class="uncollapsible">
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/00%20%e5%bc%80%e7%af%87%e8%af%8d%20%e4%bb%8e%e5%b7%a5%e7%a8%8b%e7%9a%84%e8%a7%92%e5%ba%a6%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3Python.md.html" id="00 开篇词 从工程的角度深入理解Python.md.html">00 开篇词 从工程的角度深入理解Python.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/01%20%e5%a6%82%e4%bd%95%e9%80%90%e6%ad%a5%e7%aa%81%e7%a0%b4%ef%bc%8c%e6%88%90%e4%b8%baPython%e9%ab%98%e6%89%8b%ef%bc%9f.md.html" id="01 如何逐步突破，成为Python高手？.md.html">01 如何逐步突破，成为Python高手？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/02%20Jupyter%20Notebook%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e7%8e%b0%e4%bb%a3Python%e7%9a%84%e5%bf%85%e5%ad%a6%e6%8a%80%e6%9c%af%ef%bc%9f.md.html" id="02 Jupyter Notebook为什么是现代Python的必学技术？.md.html">02 Jupyter Notebook为什么是现代Python的必学技术？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/03%20%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84%ef%bc%8c%e5%88%b0%e5%ba%95%e7%94%a8%e5%93%aa%e4%b8%80%e4%b8%aa%ef%bc%9f.md.html" id="03 列表和元组，到底用哪一个？.md.html">03 列表和元组，到底用哪一个？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/04%20%e5%ad%97%e5%85%b8%e3%80%81%e9%9b%86%e5%90%88%ef%bc%8c%e4%bd%a0%e7%9c%9f%e7%9a%84%e4%ba%86%e8%a7%a3%e5%90%97%ef%bc%9f.md.html" id="04 字典、集合，你真的了解吗？.md.html">04 字典、集合，你真的了解吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/05%20%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e5%ad%97%e7%ac%a6%e4%b8%b2.md.html" id="05 深入浅出字符串.md.html">05 深入浅出字符串.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/06%20Python%20%e2%80%9c%e9%bb%91%e7%ae%b1%e2%80%9d%ef%bc%9a%e8%be%93%e5%85%a5%e4%b8%8e%e8%be%93%e5%87%ba.md.html" id="06 Python “黑箱”：输入与输出.md.html">06 Python “黑箱”：输入与输出.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/07%20%e4%bf%ae%e7%82%bc%e5%9f%ba%e6%9c%ac%e5%8a%9f%ef%bc%9a%e6%9d%a1%e4%bb%b6%e4%b8%8e%e5%be%aa%e7%8e%af.md.html" id="07 修炼基本功：条件与循环.md.html">07 修炼基本功：条件与循环.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/08%20%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%ef%bc%9a%e5%a6%82%e4%bd%95%e6%8f%90%e9%ab%98%e7%a8%8b%e5%ba%8f%e7%9a%84%e7%a8%b3%e5%ae%9a%e6%80%a7%ef%bc%9f.md.html" id="08 异常处理：如何提高程序的稳定性？.md.html">08 异常处理：如何提高程序的稳定性？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/09%20%e4%b8%8d%e5%8f%af%e6%88%96%e7%bc%ba%e7%9a%84%e8%87%aa%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0.md.html" id="09 不可或缺的自定义函数.md.html">09 不可或缺的自定义函数.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/10%20%e7%ae%80%e7%ba%a6%e4%b8%8d%e7%ae%80%e5%8d%95%e7%9a%84%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0.md.html" id="10 简约不简单的匿名函数.md.html">10 简约不简单的匿名函数.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/11%20%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%ef%bc%88%e4%b8%8a%ef%bc%89%ef%bc%9a%e4%bb%8e%e7%94%9f%e6%b4%bb%e4%b8%ad%e7%9a%84%e7%b1%bb%e6%af%94%e8%af%b4%e8%b5%b7.md.html" id="11 面向对象（上）：从生活中的类比说起.md.html">11 面向对象（上）：从生活中的类比说起.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/12%20%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%ef%bc%88%e4%b8%8b%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%90%9c%e7%b4%a2%e5%bc%95%e6%93%8e%ef%bc%9f.md.html" id="12 面向对象（下）：如何实现一个搜索引擎？.md.html">12 面向对象（下）：如何实现一个搜索引擎？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/13%20%e6%90%ad%e5%bb%ba%e7%a7%af%e6%9c%a8%ef%bc%9aPython%20%e6%a8%a1%e5%9d%97%e5%8c%96.md.html" id="13 搭建积木：Python 模块化.md.html">13 搭建积木：Python 模块化.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/14%20%e7%ad%94%e7%96%91%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%88%97%e8%a1%a8%e5%92%8c%e5%85%83%e7%bb%84%e7%9a%84%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84%ef%bc%9f.md.html" id="14 答疑（一）：列表和元组的内部实现是怎样的？.md.html">14 答疑（一）：列表和元组的内部实现是怎样的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/15%20Python%e5%af%b9%e8%b1%a1%e7%9a%84%e6%af%94%e8%be%83%e3%80%81%e6%8b%b7%e8%b4%9d.md.html" id="15 Python对象的比较、拷贝.md.html">15 Python对象的比较、拷贝.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/16%20%e5%80%bc%e4%bc%a0%e9%80%92%ef%bc%8c%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92or%e5%85%b6%e4%bb%96%ef%bc%8cPython%e9%87%8c%e5%8f%82%e6%95%b0%e6%98%af%e5%a6%82%e4%bd%95%e4%bc%a0%e9%80%92%e7%9a%84%ef%bc%9f.md.html" id="16 值传递，引用传递or其他，Python里参数是如何传递的？.md.html">16 值传递，引用传递or其他，Python里参数是如何传递的？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/17%20%e5%bc%ba%e5%a4%a7%e7%9a%84%e8%a3%85%e9%a5%b0%e5%99%a8.md.html" id="17 强大的装饰器.md.html">17 强大的装饰器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/18%20metaclass%ef%bc%8c%e6%98%af%e6%bd%98%e5%a4%9a%e6%8b%89%e9%ad%94%e7%9b%92%e8%bf%98%e6%98%af%e9%98%bf%e6%8b%89%e4%b8%81%e7%a5%9e%e7%81%af%ef%bc%9f.md.html" id="18 metaclass，是潘多拉魔盒还是阿拉丁神灯？.md.html">18 metaclass，是潘多拉魔盒还是阿拉丁神灯？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/19%20%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%92%8c%e7%94%9f%e6%88%90%e5%99%a8.md.html" id="19 深入理解迭代器和生成器.md.html">19 深入理解迭代器和生成器.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/20%20%e6%8f%ad%e7%a7%98%20Python%20%e5%8d%8f%e7%a8%8b.md.html" id="20 揭秘 Python 协程.md.html">20 揭秘 Python 协程.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/21%20Python%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8bFutures.md.html" id="21 Python并发编程之Futures.md.html">21 Python并发编程之Futures.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/22%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8bAsyncio.md.html" id="22 并发编程之Asyncio.md.html">22 并发编程之Asyncio.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/23%20%e4%bd%a0%e7%9c%9f%e7%9a%84%e6%87%82Python%20GIL%ef%bc%88%e5%85%a8%e5%b1%80%e8%a7%a3%e9%87%8a%e5%99%a8%e9%94%81%ef%bc%89%e5%90%97%ef%bc%9f.md.html" id="23 你真的懂Python GIL（全局解释器锁）吗？.md.html">23 你真的懂Python GIL（全局解释器锁）吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/24%20%e5%b8%a6%e4%bd%a0%e8%a7%a3%e6%9e%90%20Python%20%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6.md.html" id="24 带你解析 Python 垃圾回收机制.md.html">24 带你解析 Python 垃圾回收机制.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/25%20%e7%ad%94%e7%96%91%ef%bc%88%e4%ba%8c%ef%bc%89%ef%bc%9aGIL%e4%b8%8e%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb%e5%91%a2%ef%bc%9f.md.html" id="25 答疑（二）：GIL与多线程是什么关系呢？.md.html">25 答疑（二）：GIL与多线程是什么关系呢？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/26%20%e6%b4%bb%e9%83%bd%e6%9d%a5%e4%b8%8d%e5%8f%8a%e5%b9%b2%e4%ba%86%ef%bc%8c%e8%bf%98%e6%9c%89%e7%a9%ba%e6%b3%a8%e6%84%8f%e4%bb%a3%e7%a0%81%e9%a3%8e%e6%a0%bc%ef%bc%9f%ef%bc%81.md.html" id="26 活都来不及干了，还有空注意代码风格？！.md.html">26 活都来不及干了，还有空注意代码风格？！.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/27%20%e5%ad%a6%e4%bc%9a%e5%90%88%e7%90%86%e5%88%86%e8%a7%a3%e4%bb%a3%e7%a0%81%ef%bc%8c%e6%8f%90%e9%ab%98%e4%bb%a3%e7%a0%81%e5%8f%af%e8%af%bb%e6%80%a7.md.html" id="27 学会合理分解代码，提高代码可读性.md.html">27 学会合理分解代码，提高代码可读性.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/28%20%e5%a6%82%e4%bd%95%e5%90%88%e7%90%86%e5%88%a9%e7%94%a8assert%ef%bc%9f.md.html" id="28 如何合理利用assert？.md.html">28 如何合理利用assert？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/29%20%e5%b7%a7%e7%94%a8%e4%b8%8a%e4%b8%8b%e6%96%87%e7%ae%a1%e7%90%86%e5%99%a8%e5%92%8cWith%e8%af%ad%e5%8f%a5%e7%b2%be%e7%ae%80%e4%bb%a3%e7%a0%81.md.html" id="29 巧用上下文管理器和With语句精简代码.md.html">29 巧用上下文管理器和With语句精简代码.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/30%20%e7%9c%9f%e7%9a%84%e6%9c%89%e5%bf%85%e8%a6%81%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e5%90%97%ef%bc%9f.md.html" id="30 真的有必要写单元测试吗？.md.html">30 真的有必要写单元测试吗？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/31%20pdb%20&amp;%20cProfile%ef%bc%9a%e8%b0%83%e8%af%95%e5%92%8c%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e7%9a%84%e6%b3%95%e5%ae%9d.md.html" id="31 pdb &amp; cProfile：调试和性能分析的法宝.md.html">31 pdb &amp; cProfile：调试和性能分析的法宝.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/32%20%e7%ad%94%e7%96%91%ef%bc%88%e4%b8%89%ef%bc%89%ef%bc%9a%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%96%b9%e5%bc%8f%ef%bc%9f.md.html" id="32 答疑（三）：如何选择合适的异常处理方式？.md.html">32 答疑（三）：如何选择合适的异常处理方式？.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/33%20%e5%b8%a6%e4%bd%a0%e5%88%9d%e6%8e%a2%e9%87%8f%e5%8c%96%e4%b8%96%e7%95%8c.md.html" id="33 带你初探量化世界.md.html">33 带你初探量化世界.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/34%20RESTful%20&amp;%20Socket%ef%bc%9a%e6%90%ad%e5%bb%ba%e4%ba%a4%e6%98%93%e6%89%a7%e8%a1%8c%e5%b1%82%e6%a0%b8%e5%bf%83.md.html" id="34 RESTful &amp; Socket：搭建交易执行层核心.md.html">34 RESTful &amp; Socket：搭建交易执行层核心.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/35%20RESTful%20&amp;%20Socket%ef%bc%9a%e8%a1%8c%e6%83%85%e6%95%b0%e6%8d%ae%e5%af%b9%e6%8e%a5%e5%92%8c%e6%8a%93%e5%8f%96.md.html" id="35 RESTful &amp; Socket：行情数据对接和抓取.md.html">35 RESTful &amp; Socket：行情数据对接和抓取.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/36%20Pandas%20&amp;%20Numpy%ef%bc%9a%e7%ad%96%e7%95%a5%e4%b8%8e%e5%9b%9e%e6%b5%8b%e7%b3%bb%e7%bb%9f.md.html" id="36 Pandas &amp; Numpy：策略与回测系统.md.html">36 Pandas &amp; Numpy：策略与回测系统.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/37%20Kafka%20&amp;%20ZMQ%ef%bc%9a%e8%87%aa%e5%8a%a8%e5%8c%96%e4%ba%a4%e6%98%93%e6%b5%81%e6%b0%b4%e7%ba%bf.md.html" id="37 Kafka &amp; ZMQ：自动化交易流水线.md.html">37 Kafka &amp; ZMQ：自动化交易流水线.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/38%20MySQL%ef%bc%9a%e6%97%a5%e5%bf%97%e5%92%8c%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f.md.html" id="38 MySQL：日志和数据存储系统.md.html">38 MySQL：日志和数据存储系统.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/39%20Django%ef%bc%9a%e6%90%ad%e5%bb%ba%e7%9b%91%e6%8e%a7%e5%b9%b3%e5%8f%b0.md.html" id="39 Django：搭建监控平台.md.html">39 Django：搭建监控平台.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/40%20%e6%80%bb%e7%bb%93%ef%bc%9aPython%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e5%85%a8%e6%99%af.md.html" id="40 总结：Python中的数据结构与算法全景.md.html">40 总结：Python中的数据结构与算法全景.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/41%20%e7%a1%85%e8%b0%b7%e4%b8%80%e7%ba%bf%e4%ba%92%e8%81%94%e7%bd%91%e5%85%ac%e5%8f%b8%e7%9a%84%e5%b7%a5%e4%bd%9c%e4%bd%93%e9%aa%8c.md.html" id="41 硅谷一线互联网公司的工作体验.md.html">41 硅谷一线互联网公司的工作体验.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/42%20%e7%bb%86%e6%95%b0%e6%8a%80%e6%9c%af%e7%a0%94%e5%8f%91%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9.md.html" id="42 细数技术研发的注意事项.md.html">42 细数技术研发的注意事项.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/43%20Q&amp;A%ef%bc%9a%e8%81%8a%e4%b8%80%e8%81%8a%e8%81%8c%e4%b8%9a%e5%8f%91%e5%b1%95%e5%92%8c%e9%80%89%e6%8b%a9.md.html" id="43 Q&amp;A：聊一聊职业发展和选择.md.html">43 Q&amp;A：聊一聊职业发展和选择.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/%e5%8a%a0%e9%a4%90%20%e5%b8%a6%e4%bd%a0%e4%b8%8a%e6%89%8bSWIG%ef%bc%9a%e4%b8%80%e4%bb%bd%e6%b8%85%e6%99%b0%e5%a5%bd%e7%94%a8%e7%9a%84SWIG%e7%bc%96%e7%a8%8b%e5%ae%9e%e8%b7%b5%e6%8c%87%e5%8d%97.md.html" id="加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南.md.html">加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南.md.html</a>
</li>
<li>
<a class="menu-item" href="/%e4%b8%93%e6%a0%8f/Python%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e4%b8%8e%e5%ae%9e%e6%88%98/%e7%bb%93%e6%9d%9f%e8%af%ad%20%e6%8a%80%e6%9c%af%e4%b9%8b%e5%a4%96%e7%9a%84%e5%87%a0%e7%82%b9%e6%88%90%e9%95%bf%e5%bb%ba%e8%ae%ae.md.html" id="结束语 技术之外的几点成长建议.md.html">结束语 技术之外的几点成长建议.md.html</a>
</li>
<li><a href="/assets/捐赠.md.html">捐赠</a></li>
</ul>
</div>
</div>
<div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseleave="remove_inner()" onmouseover="add_inner()">
<div class="sidebar-toggle-inner"></div>
</div>
<div class="off-canvas-content">
<div class="columns">
<div class="column col-12 col-lg-12">
<div class="book-navbar">
<header class="navbar">
<section class="navbar-section">
<a onclick="open_sidebar()">
<i class="icon icon-menu"></i>
</a>
</section>
</header>
</div>
<div class="book-content" style="max-width: 960px; margin: 0 auto;
    overflow-x: auto;
    overflow-y: hidden;">
<div class="book-post">
<div align="center">因收到Google相关通知，网站将会择期关闭。<a href="https://lumendatabase.org/notices/44265620" target="_blank">相关通知内容</a><hr/></div>
<p align="center" id="tip"></p>
<h1 class="title" data-id="加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南" id="title">加餐 带你上手SWIG：一份清晰好用的SWIG编程实践指南</h1>
<div><p>你好，我是卢誉声，Autodesk 数据平台和计算平台资深软件工程师，也是《移动平台深度神经网络实战》和《分布式实时处理系统：原理架构与实现》的作者，主要从事C/C++、JavaScript开发工作和平台架构方面的研发工作，对SWIG也有比较深的研究。很高兴受极客时间邀请来做本次分享，今天，我们就来聊一聊SWIG这个话题。</p>
<p>我们都知道，Python 是一门易于上手并实验友好的胶水语言。现在有很多机器学习开发或研究人员，都选择Python作为主力编程语言；流行的机器学习框架也都会提供Python语言的支持作为调用接口和工具。因此，相较于学习成本更高的C++来说，把Python作为进入机器学习世界的首选编程语言，就再合适不过了。</p>
<p>不过，像TensorFlow或PyTorch这样的机器学习框架的核心，是使用Python编写的吗？</p>
<p>显然不是。这里面的原因比较多，但最为显著的一个原因就是“性能”。通过C++编写的机器学习框架内核，加上编译器的优化能力，为系统提供了接近于机器码执行的效率。这种得天独厚的优势，让C++在机器学习的核心领域站稳了脚跟。我们前面所说的TensorFlow和PyTorch的核心，便都是使用C/C++开发的。其中，TensorFlow的内核，就是由高度优化的C++代码和CUDA编写而成。</p>
<p>因此，我们可以理解为，TensorFlow通过Python来描述模型，而实际的运算则是由高性能C++代码执行的。而且，在绝大多数情况下，不同操作之间传递的数据，并不会拷贝回Python代码的执行空间。机器学习框架，正是通过这样的方式确保了计算性能，同时兼顾了对框架易用性方面的考虑。</p>
<p>因此，当Python和C++结合使用的时候，Python本身的性能瓶颈就不那么重要了。它足够胜任我们给它的任务就可以了，至于对计算有更高要求的任务，就交给C++来做吧！</p>
<p>今天，我们就来讨论下，如何通过SWIG对C++程序进行Python封装。我会先带你编写一段Python脚本，来执行一个简单的机器学习任务；接着，尝试将计算密集的部分改写成C++程序，再通过SWIG对其进行封装。最后的结果就是，Python把计算密集的任务委托给C++执行。</p>
<p>我们会对性能做一个简单比较，并在这个过程中，讲解使用SWIG的方法。同时，在今天这节课的最后，我会为你提供一个学习路径，作为日后提高的参考。</p>
<p>明确了今天的学习目的，也就是使用SWIG来实现Python对C++代码的调用，那么，我们今天的内容，其实可以看成一份<strong>关于SWIG的编程实践指南</strong>。学习这份指南之前，我们先来简单了解一下SWIG。</p>
<h2 id="swig-是什么">SWIG 是什么？</h2>
<p>SWIG，是一款能够连接C/C++与多种高级编程语言（我们在这里特别强调Python）的软件开发工具。SWIG支持多种不同类型的目标语言，这其中，支持的常见脚本语言包括JavaScript、Perl、PHP、Tcl、Ruby和Python等，支持的高级编程语言则包括C#、D、Go语言、Java（包括对Android的支持）、Lua、OCaml、Octave、Scilab和R。</p>
<p>我们通常使用SWIG来创建高级解释或编译型的编程环境和接口，它也常被用来当作C/C++编写原型的测试工具。一个典型的应用场景，便是解析和创建C/C++接口，生成胶水代码供像Python这样的高级编程语言调用。近期发布的4.0.0版本，更是带来了对C++的显著改进和支持，这其中包括（不局限于）下面几点。</p>
<ul>
<li>针对C#、Java和Ruby而改进的STL包装器。</li>
<li>针对Java、Python和Ruby，增加C++11标准下的STL容器的支持。</li>
<li>改进了对C++11和C++14代码的支持。</li>
<li>修正了C++中对智能指针shared_ptr的一系列bug修复。</li>
<li>一系列针对C预处理器的极端case修复。</li>
<li>一系列针对成员函数指针问题的修复。</li>
<li>低支持的Python版本为2.7、3.2-3.7。</li>
</ul>
<h2 id="使用python实现pca算法">使用Python实现PCA算法</h2>
<p>借助于SWIG，我们可以简单地实现用Python调用C/C++库，甚至可以用Python继承和使用C++类。接下来，我们先来看一个你十分熟悉的使用Python编写的PCA（Principal Component Analysis，主成分分析）算法。</p>
<p>因为我们今天的目标不是讲解PCA算法，所以如果你对这个算法还不是很熟悉，也没有关系，我会直接给出具体的代码，我们把焦点放在如何使用SWIG上就可以了。下面，我先给出代码清单1。</p>
<p>代码清单1，基于Python编写的PCA算法 <code>testPCAPurePython.py</code> ：</p>
<pre><code>import numpy as np

def compute_pca(data):
    m = np.mean(data, axis=0)
    datac = np.array([obs - m for obs in data])
    T = np.dot(datac, datac.T)
    [u,s,v] = np.linalg.svd(T)

    pcs = [np.dot(datac.T, item) for item in u.T ]

     pcs = np.array([d / np.linalg.norm(d) for d in pcs])

     return pcs, m, s, T, u

 def compute_projections(I,pcs,m):
     projections = []
     for i in I:
         w = []
         for p in pcs:
             w.append(np.dot(i - m, p))
         projections.append(w)
     return projections

 def reconstruct(w, X, m,dim = 5):
     return np.dot(w[:dim],X[:dim,:]) + m

 def normalize(samples, maxs = None):
     if not maxs:
         maxs = np.max(samples)
     return np.array([np.ravel(s) / maxs for s in samples])
</code></pre>
<p>现在，我们保存这段编写好的代码，并通过下面的命令来执行：</p>
<pre><code>python3 testPCAPurePython.py 
</code></pre>
<h2 id="准备swig">准备SWIG</h2>
<p>这样，我们已经获得了一些进展——使用Python编写了一个PCA算法，并得到了一些结果。接下来，我们看一下如何开始SWIG的开发工作。我会先从编译相关组件开始，再介绍一个简单使用的例子，为后续内容做准备。</p>
<p>首先，我们从SWIG的网站（<a href="http://swig.org/download.html" target="_blank">http://swig.org/download.html</a>）下载源代码包，并开始构建：</p>
<pre><code>$ wget https://newcontinuum.dl.sourceforge.net/project/swig/swig/swig-4.0.0/swig-4.0.0.tar.gz # 下载路径可能会有所变化
$ tar -xvf swig-4.0.0.tar.gz
$ cd swig-4.0.0
$ wget https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz # SWIG需要依赖pcre工作
$ sh ./Tools/pcre-build.sh # 该脚本会将pcre自动构建成SWIG使用的静态库
$ ./configure # 注意需要安装bison，如果没有安装需要读者手动安装
$ make
$ sudo make install
</code></pre>
<p>一切就绪后，我们就来编写一个简单的例子吧。这个例子同样来源于SWIG网站（<a href="http://swig.org/tutorial.html" target="_blank">http://swig.org/tutorial.html</a>）。我们先来创建一个简单的c文件，你可以通过你习惯使用的文本编辑器（比如vi），创建一个名为<code>example.c</code>的文件，并编写代码。代码内容我放在了代码清单2中。</p>
<p>代码清单2，<code>example.c</code>：</p>
<pre><code>#include &lt;time.h&gt;
double My_variable = 3.0;

int fact(int n) {
    if (n &lt;= 1) return 1;
    else return n*fact(n-1);
}

int my_mod(int x, int y) {
    return (x%y);
}
       
char *get_time()
{
    time_t ltime;
    time(&amp;ltime);
    return ctime(&amp;ltime);
}
</code></pre>
<p>接下来，我们编写一个名为<code>example.i</code>的接口定义文件，和稍后用作测试的Python脚本，内容如代码清单3和代码清单4所示。</p>
<p>代码清单3，<code>example.i</code>：</p>
<pre><code>%module example
%{
/* Put header files here or function declarations like below */
extern double My_variable;
extern int fact(int n);
extern int my_mod(int x, int y);
extern char *get_time();
%}

extern double My_variable;
extern int fact(int n);
extern int my_mod(int x, int y);
extern char *get_time();
</code></pre>
<p>我来解释下清单3这段代码。第1行，我们定义了模块的名称为example。第2-8行，我们直接指定了<code>example.c</code>中的函数定义，也可以定义一个<code>example.h</code>头文件，并将这些定义加入其中；然后，在 <code>%{ … %}</code>结构体中包含<code>example.h</code>，来实现相同的功能。第<code>10-13</code>行，则是定义了导出的接口，以便你在Python中直接调用这些接口。</p>
<p>代码清单4，<code>testExample.py</code>：</p>
<pre><code>import example
print(example.fact(5))
print(example.my_mod(7,3))
print(example.get_time())
</code></pre>
<p>好了， 到现在为止，我们已经准备就绪了。现在，我们来执行下面的代码，创建目标文件和最后链接的文件吧：</p>
<pre><code>swig -python example.i
gcc -c -fPIC example.c example_wrap.c -I/usr/include/python3.6
gcc -shared example.o example_wrap.o -o _example.so
python3 testExample.py # 测试调用
</code></pre>
<p>其实，从代码清单4中你也能够看到，通过导入example，我们可以直接在Python脚本中，调用使用C实现的函数接口，并获得返回值。</p>
<h2 id="通过swig封装基于c-编写的python模块">通过SWIG封装基于C++编写的Python模块</h2>
<p>到这一步，我们已经准备好了一份使用C++编写的PCA算法，接下来，我们就要对其进行一个简单的封装。由于C++缺少线性代数的官方支持，因此，为了简化线性代数运算，我这里用了一个第三方库Armadillo。在Ubuntu下，它可以使用<code>apt-get install libarmadillo-dev</code>安装支持。</p>
<p>另外，还是要再三说明一下，我们今天这节课的重点并不是讲解PCA算法本身，所以希望你不要困于此处，而错过了真正的使用方法。当然，为了完整性考虑，我还是会对代码做出最基本的解释。</p>
<p>封装正式开始。我们先来编写一个名为<code>pca.h</code>的头文件定义，内容我放在了代码清单5中。</p>
<p>代码清单5，<code>pca.h</code>：</p>
<pre><code>#pragma once

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;armadillo&gt;

class pca {
public:
    pca();
    explicit pca(long num_vars);
    virtual ~pca();

    bool operator==(const pca&amp; other);

    void set_num_variables(long num_vars);
    long get_num_variables() const;
    void add_record(const std::vector&lt;double&gt;&amp; record);
    std::vector&lt;double&gt; get_record(long record_index) const;
    long get_num_records() const;
    void set_do_normalize(bool do_normalize);
    bool get_do_normalize() const;
    void set_solver(const std::string&amp; solver);
    std::string get_solver() const;

    void solve();

    double check_eigenvectors_orthogonal() const;
    double check_projection_accurate() const;

    void save(const std::string&amp; basename) const;
    void load(const std::string&amp; basename);

    void set_num_retained(long num_retained);
    long get_num_retained() const;
    std::vector&lt;double&gt; to_principal_space(const std::vector&lt;double&gt;&amp; record) const;
    std::vector&lt;double&gt; to_variable_space(const std::vector&lt;double&gt;&amp; data) const;
    double get_energy() const;
    double get_eigenvalue(long eigen_index) const;
    std::vector&lt;double&gt; get_eigenvalues() const;
    std::vector&lt;double&gt; get_eigenvector(long eigen_index) const;
    std::vector&lt;double&gt; get_principal(long eigen_index) const;
    std::vector&lt;double&gt; get_mean_values() const;
    std::vector&lt;double&gt; get_sigma_values() const;

protected:
    long num_vars_;
    long num_records_;
    long record_buffer_;
    std::string solver_;
    bool do_normalize_;
    long num_retained_;
    arma::Mat&lt;double&gt; data_;
    arma::Col&lt;double&gt; energy_;
    arma::Col&lt;double&gt; eigval_;
    arma::Mat&lt;double&gt; eigvec_;
    arma::Mat&lt;double&gt; proj_eigvec_;
    arma::Mat&lt;double&gt; princomp_;
    arma::Col&lt;double&gt; mean_;
    arma::Col&lt;double&gt; sigma_;
    void initialize_();
    void assert_num_vars_();
    void resize_data_if_needed_();
};
</code></pre>
<p>接着，我们再来编写具体实现<code>pca.cpp</code>，也就是代码清单6的内容。</p>
<p>代码清单6，<code>pca.cpp</code>：</p>
<pre><code>#include "pca.h"
#include "utils.h"
#include &lt;stdexcept&gt;
#include &lt;random&gt;

pca::pca()
    : num_vars_(0),
      num_records_(0),
      record_buffer_(1000),
      solver_("dc"),
      do_normalize_(false),
      num_retained_(1),
      energy_(1)
{}

pca::pca(long num_vars)
    : num_vars_(num_vars),
      num_records_(0),
      record_buffer_(1000),
      solver_("dc"),
      do_normalize_(false),
      num_retained_(num_vars_),
      data_(record_buffer_, num_vars_),
      energy_(1),
      eigval_(num_vars_),
      eigvec_(num_vars_, num_vars_),
      proj_eigvec_(num_vars_, num_vars_),
      princomp_(record_buffer_, num_vars_),
      mean_(num_vars_),
      sigma_(num_vars_)
{
    assert_num_vars_();
    initialize_();
}

pca::~pca()
{}

bool pca::operator==(const pca&amp; other) {
    const double eps = 1e-5;
    if (num_vars_ == other.num_vars_ &amp;&amp;
        num_records_ == other.num_records_ &amp;&amp;
        record_buffer_ == other.record_buffer_ &amp;&amp;
        solver_ == other.solver_ &amp;&amp;
        do_normalize_ == other.do_normalize_ &amp;&amp;
        num_retained_ == other.num_retained_ &amp;&amp;
        utils::is_approx_equal_container(eigval_, other.eigval_, eps) &amp;&amp;
        utils::is_approx_equal_container(eigvec_, other.eigvec_, eps) &amp;&amp;
        utils::is_approx_equal_container(princomp_, other.princomp_, eps) &amp;&amp;
        utils::is_approx_equal_container(energy_, other.energy_, eps) &amp;&amp;
        utils::is_approx_equal_container(mean_, other.mean_, eps) &amp;&amp;
        utils::is_approx_equal_container(sigma_, other.sigma_, eps) &amp;&amp;
        utils::is_approx_equal_container(proj_eigvec_, other.proj_eigvec_, eps))
        return true;
    else
        return false;
}

void pca::resize_data_if_needed_() {
    if (num_records_ == record_buffer_) {
        record_buffer_ += record_buffer_;
        data_.resize(record_buffer_, num_vars_);
    }
}

void pca::assert_num_vars_() {
    if (num_vars_ &lt; 2)
        throw std::invalid_argument("Number of variables smaller than two.");
}

void pca::initialize_() {
    data_.zeros();
    eigval_.zeros();
    eigvec_.zeros();
    princomp_.zeros();
    mean_.zeros();
    sigma_.zeros();
    energy_.zeros();
}

void pca::set_num_variables(long num_vars) {
    num_vars_ = num_vars;
    assert_num_vars_();
    num_retained_ = num_vars_;
    data_.resize(record_buffer_, num_vars_);
    eigval_.resize(num_vars_);
    eigvec_.resize(num_vars_, num_vars_);
    mean_.resize(num_vars_);
    sigma_.resize(num_vars_);
    initialize_();
}

void pca::add_record(const std::vector&lt;double&gt;&amp; record) {
    assert_num_vars_();

    if (num_vars_ != long(record.size()))
        throw std::domain_error(utils::join("Record has the wrong size: ", record.size()));

    resize_data_if_needed_();
    arma::Row&lt;double&gt; row(&amp;record.front(), record.size());
    data_.row(num_records_) = std::move(row);
    ++num_records_;
}

std::vector&lt;double&gt; pca::get_record(long record_index) const {
    return std::move(utils::extract_row_vector(data_, record_index));
}

void pca::set_do_normalize(bool do_normalize) {
    do_normalize_ = do_normalize;
}

void pca::set_solver(const std::string&amp; solver) {
    if (solver!="standard" &amp;&amp; solver!="dc")
        throw std::invalid_argument(utils::join("No such solver available: ", solver));
    solver_ = solver;
}

void pca::solve() {
    assert_num_vars_();

    if (num_records_ &lt; 2)
        throw std::logic_error("Number of records smaller than two.");

    data_.resize(num_records_, num_vars_);

    mean_ = utils::compute_column_means(data_);
    utils::remove_column_means(data_, mean_);

    sigma_ = utils::compute_column_rms(data_);
    if (do_normalize_) utils::normalize_by_column(data_, sigma_);

    arma::Col&lt;double&gt; eigval(num_vars_);
    arma::Mat&lt;double&gt; eigvec(num_vars_, num_vars_);

    arma::Mat&lt;double&gt; cov_mat = utils::make_covariance_matrix(data_);
    arma::eig_sym(eigval, eigvec, cov_mat, solver_.c_str());
    arma::uvec indices = arma::sort_index(eigval, 1);

    for (long i=0; i&lt;num_vars_; ++i) {
        eigval_(i) = eigval(indices(i));
        eigvec_.col(i) = eigvec.col(indices(i));
    }

    utils::enforce_positive_sign_by_column(eigvec_);
    proj_eigvec_ = eigvec_;

    princomp_ = data_ * eigvec_;

    energy_(0) = arma::sum(eigval_);
    eigval_ *= 1./energy_(0);
}

void pca::set_num_retained(long num_retained) {
    if (num_retained&lt;=0 || num_retained&gt;num_vars_)
        throw std::range_error(utils::join("Value out of range: ", num_retained));

    num_retained_ = num_retained;
    proj_eigvec_ = eigvec_.submat(0, 0, eigvec_.n_rows-1, num_retained_-1);
}

std::vector&lt;double&gt; pca::to_principal_space(const std::vector&lt;double&gt;&amp; data) const {
    arma::Col&lt;double&gt; column(&amp;data.front(), data.size());
    column -= mean_;
    if (do_normalize_) column /= sigma_;
    const arma::Row&lt;double&gt; row(column.t() * proj_eigvec_);
    return std::move(utils::extract_row_vector(row, 0));
}

std::vector&lt;double&gt; pca::to_variable_space(const std::vector&lt;double&gt;&amp; data) const {
    const arma::Row&lt;double&gt; row(&amp;data.front(), data.size());
    arma::Col&lt;double&gt; column(arma::trans(row * proj_eigvec_.t()));
    if (do_normalize_) column %= sigma_;
    column += mean_;
    return std::move(utils::extract_column_vector(column, 0));
}

double pca::get_energy() const {
    return energy_(0);
}

double pca::get_eigenvalue(long eigen_index) const {
    if (eigen_index &gt;= num_vars_)
        throw std::range_error(utils::join("Index out of range: ", eigen_index));
    return eigval_(eigen_index);
}

std::vector&lt;double&gt; pca::get_eigenvalues() const {
    return std::move(utils::extract_column_vector(eigval_, 0));
}

std::vector&lt;double&gt; pca::get_eigenvector(long eigen_index) const {
    return std::move(utils::extract_column_vector(eigvec_, eigen_index));
}

std::vector&lt;double&gt; pca::get_principal(long eigen_index) const {
    return std::move(utils::extract_column_vector(princomp_, eigen_index));
}

double pca::check_eigenvectors_orthogonal() const {
    return std::abs(arma::det(eigvec_));
}

double pca::check_projection_accurate() const {
    if (data_.n_cols!=eigvec_.n_cols || data_.n_rows!=princomp_.n_rows)
        throw std::runtime_error("No proper data matrix present that the projection could be compared with.");
    const arma::Mat&lt;double&gt; diff = (princomp_ * arma::trans(eigvec_)) - data_;
    return 1 - arma::sum(arma::sum( arma::abs(diff) )) / diff.n_elem;
}

bool pca::get_do_normalize() const {
    return do_normalize_;
}

std::string pca::get_solver() const {
    return solver_;
}

std::vector&lt;double&gt; pca::get_mean_values() const {
    return std::move(utils::extract_column_vector(mean_, 0));
}

std::vector&lt;double&gt; pca::get_sigma_values() const {
    return std::move(utils::extract_column_vector(sigma_, 0));
}

long pca::get_num_variables() const {
    return num_vars_;
}

long pca::get_num_records() const {
    return num_records_;
}

long pca::get_num_retained() const {
    return num_retained_;
}

void pca::save(const std::string&amp; basename) const {
    const std::string filename = basename + ".pca";
    std::ofstream file(filename.c_str());
    utils::assert_file_good(file.good(), filename);
    utils::write_property(file, "num_variables", num_vars_);
    utils::write_property(file, "num_records", num_records_);
    utils::write_property(file, "solver", solver_);
    utils::write_property(file, "num_retained", num_retained_);
    utils::write_property(file, "do_normalize", do_normalize_);
    file.close();

    utils::write_matrix_object(basename + ".eigval", eigval_);
    utils::write_matrix_object(basename + ".eigvec", eigvec_);
    utils::write_matrix_object(basename + ".princomp", princomp_);
    utils::write_matrix_object(basename + ".energy", energy_);
    utils::write_matrix_object(basename + ".mean", mean_);
    utils::write_matrix_object(basename + ".sigma", sigma_);
}

void pca::load(const std::string&amp; basename) {
    const std::string filename = basename + ".pca";
    std::ifstream file(filename.c_str());
    utils::assert_file_good(file.good(), filename);
    utils::read_property(file, "num_variables", num_vars_);
    utils::read_property(file, "num_records", num_records_);
    utils::read_property(file, "solver", solver_);
    utils::read_property(file, "num_retained", num_retained_);
    utils::read_property(file, "do_normalize", do_normalize_);
    file.close();

    utils::read_matrix_object(basename + ".eigval", eigval_);
    utils::read_matrix_object(basename + ".eigvec", eigvec_);
    utils::read_matrix_object(basename + ".princomp", princomp_);
    utils::read_matrix_object(basename + ".energy", energy_);
    utils::read_matrix_object(basename + ".mean", mean_);
    utils::read_matrix_object(basename + ".sigma", sigma_);

    set_num_retained(num_retained_);
}
</code></pre>
<p>这里要注意了，代码清单6中用到了<code>utils.h</code>这个文件，它是对部分矩阵和数学计算的封装，内容我放在了代码清单7中。</p>
<p>代码清单7，<code>utils.h</code>：</p>
<pre><code>#pragma once
 
#include &lt;armadillo&gt;
#include &lt;sstream&gt;

namespace utils {
arma::Mat&lt;double&gt; make_covariance_matrix(const arma::Mat&lt;double&gt;&amp; data);
arma::Mat&lt;double&gt; make_shuffled_matrix(const arma::Mat&lt;double&gt;&amp; data);
arma::Col&lt;double&gt; compute_column_means(const arma::Mat&lt;double&gt;&amp; data);
void remove_column_means(arma::Mat&lt;double&gt;&amp; data, const arma::Col&lt;double&gt;&amp; means);
arma::Col&lt;double&gt; compute_column_rms(const arma::Mat&lt;double&gt;&amp; data);
void normalize_by_column(arma::Mat&lt;double&gt;&amp; data, const arma::Col&lt;double&gt;&amp; rms);
void enforce_positive_sign_by_column(arma::Mat&lt;double&gt;&amp; data);
std::vector&lt;double&gt; extract_column_vector(const arma::Mat&lt;double&gt;&amp; data, long index);
std::vector&lt;double&gt; extract_row_vector(const arma::Mat&lt;double&gt;&amp; data, long index);
void assert_file_good(const bool&amp; is_file_good, const std::string&amp; filename);
template&lt;typename T&gt;
void write_matrix_object(const std::string&amp; filename, const T&amp; matrix) {
    assert_file_good(matrix.quiet_save(filename, arma::arma_ascii), filename);
}

template&lt;typename T&gt;
void read_matrix_object(const std::string&amp; filename, T&amp; matrix) {
    assert_file_good(matrix.quiet_load(filename), filename);
}
template&lt;typename T, typename U, typename V&gt;
bool is_approx_equal(const T&amp; value1, const U&amp; value2, const V&amp; eps) {
    return std::abs(value1-value2)&lt;eps ? true : false;
}
template&lt;typename T, typename U, typename V&gt;
bool is_approx_equal_container(const T&amp; container1, const U&amp; container2, const V&amp; eps) {
    if (container1.size()==container2.size()) {
        bool equal = true;
        for (size_t i=0; i&lt;container1.size(); ++i) {
            equal = is_approx_equal(container1[i], container2[i], eps);
            if (!equal) break;
        }
        return equal;
    } else {
        return false;
    }
}
double get_mean(const std::vector&lt;double&gt;&amp; iter);
double get_sigma(const std::vector&lt;double&gt;&amp; iter);

struct join_helper {
    static void add_to_stream(std::ostream&amp; stream) {}

    template&lt;typename T, typename... Args&gt;
    static void add_to_stream(std::ostream&amp; stream, const T&amp; arg, const Args&amp;... args) {
        stream &lt;&lt; arg;
        add_to_stream(stream, args...);
    }
};

template&lt;typename T, typename... Args&gt;
std::string join(const T&amp; arg, const Args&amp;... args) {
    std::ostringstream stream;
    stream &lt;&lt; arg;
    join_helper::add_to_stream(stream, args...);
    return stream.str();
}

template&lt;typename T&gt;
void write_property(std::ostream&amp; file, const std::string&amp; key, const T&amp; value) {
    file &lt;&lt; key &lt;&lt; "\t" &lt;&lt; value &lt;&lt; std::endl;
}

template&lt;typename T&gt;
void read_property(std::istream&amp; file, const std::string&amp; key, T&amp; value) {
    std::string tmp;
    bool found = false;
    while (file.good()) {
        file &gt;&gt; tmp;
        if (tmp==key) {
            file &gt;&gt; value;
            found = true;
            break;
        }
    }
    if (!found)
        throw std::domain_error(join("No such key available: ", key));
    file.seekg(0);
}

} //utils
</code></pre>
<p>至于具体的实现代码，我放在了在代码清单8<code>utils.cpp</code>中。</p>
<p>代码清单8，<code>utils.cpp</code>：</p>
<pre><code>#include "utils.h"
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;numeric&gt;

namespace utils {

arma::Mat&lt;double&gt; make_covariance_matrix(const arma::Mat&lt;double&gt;&amp; data) {
    return std::move( (data.t()*data) * (1./(data.n_rows-1)) );
}

arma::Mat&lt;double&gt; make_shuffled_matrix(const arma::Mat&lt;double&gt;&amp; data) {
    const long n_rows = data.n_rows;
    const long n_cols = data.n_cols;
    arma::Mat&lt;double&gt; shuffle(n_rows, n_cols);
    for (long j=0; j&lt;n_cols; ++j) {
        for (long i=0; i&lt;n_rows; ++i) {
            shuffle(i, j) = data(std::rand()%n_rows, j);
        }
    }
    return std::move(shuffle);
}

arma::Col&lt;double&gt; compute_column_means(const arma::Mat&lt;double&gt;&amp; data) {
    const long n_cols = data.n_cols;
    arma::Col&lt;double&gt; means(n_cols);
    for (long i=0; i&lt;n_cols; ++i)
        means(i) = arma::mean(data.col(i));
    return std::move(means);
}

void remove_column_means(arma::Mat&lt;double&gt;&amp; data, const arma::Col&lt;double&gt;&amp; means) {
    if (data.n_cols != means.n_elem)
        throw std::range_error("Number of elements of means is not equal to the number of columns of data");
    for (long i=0; i&lt;long(data.n_cols); ++i)
        data.col(i) -= means(i);
}

arma::Col&lt;double&gt; compute_column_rms(const arma::Mat&lt;double&gt;&amp; data) {
    const long n_cols = data.n_cols;
    arma::Col&lt;double&gt; rms(n_cols);
    for (long i=0; i&lt;n_cols; ++i) {
        const double dot = arma::dot(data.col(i), data.col(i));
        rms(i) = std::sqrt(dot / (data.col(i).n_rows-1));
    }
    return std::move(rms);
}

void normalize_by_column(arma::Mat&lt;double&gt;&amp; data, const arma::Col&lt;double&gt;&amp; rms) {
    if (data.n_cols != rms.n_elem)
        throw std::range_error("Number of elements of rms is not equal to the number of columns of data");
    for (long i=0; i&lt;long(data.n_cols); ++i) {
        if (rms(i)==0)
            throw std::runtime_error("At least one of the entries of rms equals to zero");
        data.col(i) *= 1./rms(i);
    }
}

void enforce_positive_sign_by_column(arma::Mat&lt;double&gt;&amp; data) {
    for (long i=0; i&lt;long(data.n_cols); ++i) {
        const double max = arma::max(data.col(i));
        const double min = arma::min(data.col(i));
        bool change_sign = false;
        if (std::abs(max)&gt;=std::abs(min)) {
            if (max&lt;0) change_sign = true;
        } else {
            if (min&lt;0) change_sign = true;
        }
        if (change_sign) data.col(i) *= -1;
    }
}

std::vector&lt;double&gt; extract_column_vector(const arma::Mat&lt;double&gt;&amp; data, long index) {
    if (index&lt;0 || index &gt;= long(data.n_cols))
        throw std::range_error(join("Index out of range: ", index));
    const long n_rows = data.n_rows;
    const double* memptr = data.colptr(index);
    std::vector&lt;double&gt; result(memptr, memptr + n_rows);
    return std::move(result);
}

std::vector&lt;double&gt; extract_row_vector(const arma::Mat&lt;double&gt;&amp; data, long index) {
    if (index&lt;0 || index &gt;= long(data.n_rows))
        throw std::range_error(join("Index out of range: ", index));
    const arma::Row&lt;double&gt; row(data.row(index));
    const double* memptr = row.memptr();
    std::vector&lt;double&gt; result(memptr, memptr + row.n_elem);
    return std::move(result);
}

void assert_file_good(const bool&amp; is_file_good, const std::string&amp; filename) {
    if (!is_file_good)
        throw std::ios_base::failure(join("Cannot open file: ", filename));
}

double get_mean(const std::vector&lt;double&gt;&amp; iter) {
    const double init = 0;
    return std::accumulate(iter.begin(), iter.end(), init) / iter.size();
}

double get_sigma(const std::vector&lt;double&gt;&amp; iter) {
    const double mean = get_mean(iter);
    double sum = 0;
    for (auto v=iter.begin(); v!=iter.end(); ++v)
        sum += std::pow(*v - mean, 2.);
    return std::sqrt(sum/(iter.size()-1));
}

} //utils
</code></pre>
<p>最后，我们来编写<code>pca.i</code>接口文件，也就是代码清单9的内容。</p>
<p>代码清单9，<code>pca.i</code>：</p>
<pre><code>%module pca

%include "std_string.i"
%include "std_vector.i"

namespace std {
  %template(DoubleVector) vector&lt;double&gt;;
}

%{
#include "pca.h"
#include "utils.h"
%}

%include "pca.h"
%include "utils.h"
</code></pre>
<p>这里需要注意的是，我们在C++代码中使用了熟悉的顺序容器<code>std::vector</code>，但由于模板类比较特殊，我们需要用<code>%template</code>声明一下。</p>
<p>一切就绪后，我们执行下面的命令行，生成<code>_pca.so</code>库供Python使用：</p>
<pre><code>$ swig -c++ -python pca.i # 解释接口定义生成包SWIG装器代码
$ g++ -fPIC -c pca.h pca.cpp utils.h utils.cpp pca_wrap.cxx -I/usr/include/python3.7 # 编译源代码
$ g++ -shared pca.o pca_wrap.o utils.o -o _pca.so -O2 -Wall -std=c++11 -pthread -shared -fPIC -larmadillo # 链接
</code></pre>
<p>接着，我们使用Python脚本，导入我们创建好的so动态库；然后，调用相应的类的函数。这部分内容，我写在了代码清单10中。</p>
<p>代码清单10，<code>testPCA.py</code>：</p>
<pre><code>import pca

pca_inst = pca.pca(2)
pca_inst.add_record([1.0, 1.0])
pca_inst.add_record([2.0, 2.0])
pca_inst.add_record([4.0, 1.0])

pca_inst.solve()

energy = pca_inst.get_energy()
eigenvalues = pca_inst.get_eigenvalues()

print(energy)
print(eigenvalues)
</code></pre>
<p>最后，我们分别对纯Python实现的代码，和使用SWIG封装的版本来进行测试，各自都执行1,000,000次，然后对比执行时间。我用一张图表示了我的机器上得到的结果，你可以对比看看。</p>
<p><img alt="" src="assets/8484ebbdab5749db9d30ae237970766f.jpg"/></p>
<p>虽然这样粗略的比较并不够严谨，比如我们没有认真考虑SWIG接口类型转换的耗时，也没有考虑在不同编程语言下实现算法的逻辑等等。但是，通过这个粗略的结果，你仍然可以看出执行类似运算时，两者性能的巨大差异。</p>
<h2 id="swig-c-常用工具">SWIG C++常用工具</h2>
<p>到这里，你应该已经可以开始动手操作了，把上面的代码清单当作你的工具进行实践。不过，SWIG本身非常丰富，所以这里我也再给你总结介绍几个常用的工具。</p>
<h3 id="1-全局变量"><strong>1.全局变量</strong></h3>
<p>在Python 中，我们可以通过cvar，来访问C++代码中定义的全局变量。</p>
<p>比如说，我们在头文件 <code>sample.h</code>中定义了一个全局变量，并在<code>sample.i</code>中对其进行引用，也就是代码清单 11和12的内容。</p>
<p>代码清单11，<code>sample.h</code>：</p>
<pre><code>#include &lt;cstdint&gt;
int32_t score = 100;
</code></pre>
<p>代码清单12，<code>sample.i</code>：</p>
<pre><code>%module sample
%{
#include "sample.h"
%}

%include "sample.h"
</code></pre>
<p>这样，我们就可以直接在Python脚本中，通过cvar来访问对应的全局变量，如代码清单13所示，输出结果为100。</p>
<p>代码清单13，<code>sample.py</code>：</p>
<pre><code>import sample
print sample.cvar.score
</code></pre>
<h3 id="2-常量"><strong>2.常量</strong></h3>
<p>我们可以在接口定义文件中，使用 <code>%constant</code>来设定常量，如代码清单14所示。</p>
<p>代码清单14，<code>sample.i</code>：</p>
<pre><code>%constant int foo = 100;
%constant const char* bar = "foobar2000";
</code></pre>
<h3 id="3-enumeration"><strong>3.Enumeration</strong></h3>
<p>我们可以在接口文件中，使用enum关键字来定义enum。</p>
<h3 id="4-指针和引用"><strong>4.指针和引用</strong></h3>
<p>在C++世界中，指针是永远也绕不开的一个概念。它无处不在，我们也无时无刻不需要使用它。因此，在这里，我认为很有必要介绍一下，如何对C++中的指针和引用进行操作。</p>
<p>SWIG对指针有着较为不错的支持，对智能指针也有一定的支持，而且在近期的更新日志中，我发现它对智能指针的支持一直在更新。下面的代码清单15和16，就展示了针对指针和引用的使用方法。</p>
<p>代码清单15，<code>sample.h</code>：</p>
<pre><code>#include &lt;cstdint&gt;

void passPointer(ClassA* ptr) {
   printf("result= %d", ptr-&gt;result);
}

void passReference(const ClassA&amp; ref) {
   printf("result= %d", ref.result);
}

void passValue(ClassA obj) {
   printf("result= %d", obj.result);
}
</code></pre>
<p>代码清单16，<code>sample.py</code>：</p>
<pre><code>import sample

a = ClassA() # 创建 ClassA实例
passPointer(a)
passReference(a)
passValue(a)
</code></pre>
<h3 id="5-字符串"><strong>5.字符串</strong></h3>
<p>我们在工业级代码中，时常使用<code>std::string</code>。而在SWIG的环境下，使用标准库中的字符串，需要你在接口文件中声明<code>%include “std_stirng.i”</code>，来确保实现C++ <code>std::string</code>到Python <code>str</code>的自动转换。具体内容我放在了代码清单17中。</p>
<p>代码清单17，<code>sample.i</code>：</p>
<pre><code>%module sample

%include "std_string.i"

</code></pre>
<h3 id="6-向量"><strong>6.向量</strong></h3>
<p><code>std::vector</code>是STL中最常见也是使用最频繁的顺序容器，模板类比较特殊，因此，它的使用也比字符串稍微复杂一些，需要使用<code>%template</code>进行声明。详细内容我放在了代码清单18中。</p>
<p>代码清单18，<code>sample.i</code>：</p>
<pre><code>%module sample

%include "std_string.i"
%include "std_vector.i"

namespace std {
 %template(DoubleVector) vector&lt;double&gt;;
}

</code></pre>
<h3 id="7-映射"><strong>7. 映射</strong></h3>
<p><code>std::map</code> 同样是STL中最常见也是使用最频繁的容器。同样的，它的模板类也比较特殊，需要使用<code>%template</code>进行声明，详细内容可见代码清单19。</p>
<p>代码清单19，<code>sample.i</code>：</p>
<pre><code>%module sample

%include "std_string.i"
%include "std_map.i"

namespace std {
 %template(Int2strMap) map&lt;int, string&gt;;
 %template(Str2intMap) map&lt;string, int&gt;;
}

</code></pre>
<h2 id="学习路径">学习路径</h2>
<p>到此，SWIG入门这个小目标，我们就已经实现了。今天内容可以当作一份SWIG的编程实践指南，我给你提供了19个代码清单，利用它们，你就可以上手操作了。当然，如果在这方面你还想继续精进，该怎么办呢？别着急，今天这节课的最后，我再和你分享下，我觉得比较高效的一条SWIG学习路径。</p>
<p>首先，任何技术的学习不要脱离官方文档。SWIG网站上提供了难以置信的详尽文档，通过文档掌握SWIG的用法，显然是最好的一个途径。</p>
<p>其次，要深入SWIG，对C++有一个较为全面的掌握，就显得至关重要了。对于高性能计算来说，C++总是绕不开的一个主题，特别是对内存管理、指针和虚函数的应用，需要你实际上手编写C++代码后，才能逐渐掌握。退一步讲，即便你只是为了封装其他C++库供Python调用，也需要对C++有一个基本了解，以便未来遇到编译或链接错误时，可以找到方向来解决问题。</p>
<p>最后，我再罗列一些学习素材，供你进一步学习参考。</p>
<p>第一便是SWIG文档。</p>
<ul>
<li>a. <a href="http://www.swig.org/doc.html" target="_blank">http://www.swig.org/doc.html</a></li>
<li>b. <a href="http://www.swig.org/Doc4.0/SWIGPlus.html" target="_blank">http://www.swig.org/Doc4.0/SWIGPlus.html</a></li>
<li>c. PDF版本：<a href="http://www.swig.org/Doc4.0/SWIGDocumentation.pdf" target="_blank">http://www.swig.org/Doc4.0/SWIGDocumentation.pdf</a></li>
</ul>
<p>第二是《C++ Primer》这本书。作为C++领域的经典书籍，这本书对你全面了解C++有极大帮助。</p>
<p>第三则是《高级C/C++编译技术》这本书。这本书的内容更为进阶，你可以把它作为学习C++的提高和了解。</p>
<p>好了，今天的内容就到此结束了。关于SWIG，你有哪些收获，或者还有哪些问题，都欢迎你留言和我分享讨论。也欢迎你把这篇文章分享给你的同事、朋友，我们一起学习和进步。</p>
</div>
</div>
<div>
<div id="prePage" style="float: left">
</div>
<div id="nextPage" style="float: right">
</div>
</div>
</div>
</div>
</div>
<div class="copyright">
<hr/>
<p>© 2019 - 2023 <a href="/cdn-cgi/l/email-protection#6a060606535e5b5b5a5d2a0d070b030644090507" target="_blank">Liangliang Lee</a>.
                    Powered by <a href="https://github.com/gin-gonic/gin" target="_blank">gin</a> and <a href="https://github.com/kaiiiz/hexo-theme-book" target="_blank">hexo-theme-book</a>.</p>
</div>
</div>
<a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9357d3a5fa43436c',t:'MTc0NTUyMTA1MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NPSEEVD756"></script>
<script src="/static/index.js"></script>
</head></html>